SergeyN19 
> Просто геймдев из крутого занятия превратился в фигню для неудачников. 
Жора Монтировка
> Просто программирование из крутого занятия превратилось в фигню для неудачников. 
Просто компьютеры из крутого занятия превратились в фигню для неудачников. 
Просто жизнь из крутого занятия превратилась в фигню для неудачников.
																	gamedev.ru ( 2018 )

Сразу посоветую задуматься о выноске окна на отдельный поток.														
												Надо инпут записывать в треде окна, а потом обрабатывать в треде логики. 
Если так не делать, то есть вероятность пропустить быстрое нажатие клавиши между двумя кадрами (при низком FPS), а с двумя потоками ни одно нажатие не пройдет мимо.
												
																	
how to output text: 
1. measure the text with XTextWidth()
2. use XCreateWindow to create a window or subwindow with padding for 
around the text.
3. create a Pixmap with XCreatePixmap() that is the size of the window.
4. use XFillRectangle to draw a background for the Pixmap.
5. XDrawText(), or XDrawString, or XDrawImageString on the Pixmap.
6. Use XCopyArea to copy the Pixmap to the Window.
7. call XMapWindow
8. call XFlush
9. save the Pixmap and copy the Pixmap to the Window whenever you 
receive an Expose event.

а че это такое MFC??
Кривое поделие от криворуких индусов, есть даже предположение, что M$ специально его выпустило, чтобы конкуренты себе мозг выносили,... т.к. сама M$ на MFC ничего не пишет.



Юникод определяет для каждого символа кодовую точку.
Например, кириллической букве "A" соответствует кодовая точка U+0410.
А вот то, как она будет представлена на уровне байтов, зависит уже от
конкретной кодировки, самые популярные - UTF-8 и UTF-16 (причем
бывает еще Big Endian / Little Endian и Byte Order Mark (BOM)).
UTF-8 - это тоже Юникод, но в нем символ может занимать от одного
до шести байтов. В Windows в качестве "родной" кодировки
используется UTF-16 LE.

HANDLE objects [2] = 
{ 
  timer_handle, 
  mouse_event 
}; 
// Запуск таймера 
LARGE_INTEGER due; 
SetWaitableTimer (......); 
// Основной цикл 
while (true) 
{ 
        DWORD result; 
        MSG msg; 
        // Обработаем имеющиеся сообщения 
  while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
  { 
    if (msg.message == WM_QUIT) 
      return; 
    ::DispatchMessage(&msg); 
  } 
  result = MsgWaitForMultipleObjects (......); 
  if (result == WAIT_OBJECT_0) 
  { 
                  // Сработал таймер. Рендерим картинку, возможны другие действия. 
        } 
          else 
        { 
                  // Обработаем мышь (DirectInput) 
        } 
}


BOOL bEnd = FALSE; 
  DWORD M = 0; 
  UpdateFrame = TRUE; 
  while(!bEnd) 
    { 
      M = MsgWaitForMultipleObjects(2,DIevents,FALSE,0, QS_ALLINPUT); 
    switch (M) 
    { 
    case WAIT_OBJECT_0: 
        event1(); 
      break; 
    case WAIT_OBJECT_0+1: 
        event2(); 
      break; 
    case WAIT_OBJECT_0+2: 
    while (PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE)) 
      { 
      if (msg.message == WM_QUIT) bEnd = TRUE; 
      else 
      {TranslateMessage(&msg); 
      DispatchMessage(&msg);} 
      } 
    break; 
    default: 
    if (Active && UpdateFrame) DX_timer_do(); 
  } 
  }
DIevents - массив из указателей на события DirectInput.


А за словом ANSI скрывается разнообразие однобайтовых кодировок
типа Windows-1251, ISO-8859-5 и т.д.

Кстати, можно даже не модифицируя код. 
Способом уже так давно не пользуются что возможно молодое поколение программистов и не подозревает о его существовании. 
Я и сам забыл честно говоря. 
Просто скормить линкеру .DEF файл. 
Раньше только так и делали. И никаких __declspec(export) не было и в помине.
P.S.

И .DEF должен работать даже если нет кода статической либы.

#include <fcntl.h>
#include #include <io.h>
if (AllocConsole()) 
{ 
int hCrt = _open_osfhandle((long)GetStdHandle(STD_OUTPUT_HANDLE), 4); 
*stdout = *(::_fdopen(hCrt, "w")); 
::setvbuf(stdout, NULL, _IONBF, 0); 
*stderr = *(::_fdopen(hCrt, "w")); 
::setvbuf(stderr, NULL, _IONBF, 0);
std::ios::sync_with_stdio();
}
Для удобства советую обернуть его в функцию. Например:
void CreateConsole()
{
if (AllocConsole()) 
{ 
int hCrt = _open_osfhandle((long)GetStdHandle(STD_OUTPUT_HANDLE), 4); 
*stdout = *(::_fdopen(hCrt, "w")); 
::setvbuf(stdout, NULL, _IONBF, 0); 
*stderr = *(::_fdopen(hCrt, "w")); 
::setvbuf(stderr, NULL, _IONBF, 0);
std::ios::sync_with_stdio();
}

https://docs.microsoft.com/en-us/windows/desktop/Dlls/using-run-time-dynamic-linking
http://www.firststeps.ru/mfc/winapi/r.php?41
http://rus-linux.net/MyLDP/BOOKS/Linux-tools/GUI_01.html
http://doc.pavlabor.net/gazette.linux.ru.net/lg78/articles/rus-tougher.html
для хлиб нужно всегда указывать -о ключ, а то иногда бажится

g++ -masm=intel превосходно генерит асм под ключём -S, именно интел, но асмовые вставки лучше делать на ат энд т шном асме

/usr/local/bin/gcc46 -O2 -march=i686 -S -c bswap.c
Необходимо указать тип процессора, потому что в i386 команды bswap не было. По умолчанию GCC ничего и никак не оптимизирует, потому флаг оптимизации также необходим.

The POSIX equivalents are dlopen and dlsym. I know Linux has them, and I would be surprised if OS X does not.

для андроид нужен андроид студио,а для цпп интелс++ и надо эти две вещи както совместить

как rust для быстрого прототипирования нынче?
прототипирования чего? Если не для околосистемщины, а для приклада типа промоделировать/посчитать-получить_результат-выкинуть, то необходимость возиться с временем жизни переменных будет только тормозить разработку.
В этом смысле даже С++ проще, и кстати, когда Страуструп решил его запилить, ему это ЕМНИП нужно было для исследований в области распределенных систем.

. Смотря для чего, но всякие virtual вещи - в С++ это не очень любят в высокопроизводительном коде. Обычно можно обойтись без, причем вполне с ООП, вполне в С++ стиле. Например вместо того чтобы в один класс передать другой в виде интерфейса, тип второго используют как параметр шаблона первого

Вот плохой код для производительности

class Dep: public DepInterface {...} 

class MyClass {
   MyClass(std::unique_ptr<DepInterface> dep) ...
};
Вот хороший

template<class DepT>
class MyClass {
   MyClass(std::unique_ptr<DepT> dep) ...
};
Во втором случае если ты вызовешь потом метод dep миллиард раз, то будет значительно быстрее.

opengl tutors http://ogldev.atspace.co.uk/

Мерзляк Алгебра\Геометрия. Шахмейстер Тригонометрия

Анализ любых экспериментальных данных (зависимости величин) - только диффуры!
А это - весь мир.

пеши экспортер к максу или майе + плагин реализующий твои собственные игровые сущности. Там, монстры, оружие и прочая дрянь. 
Оптика нужна, когда хорошенько в шейдеры втянетесь, а физика, когда физические движки достаточно освоите.

Медиана делит пополам противоложную углу стороны, а биссектриса делит пополам угол, из которого она проведена.
Высота треугольника   —   перпендикуляр, проведенный из вершины  
треугольника к прямой, содержащей противоположную сторону

Атомарные и неатомарные операции:
В любой момент времени когда два потока одновременно оперируют общей переменной, и один из них производит запись, оба потока обязаны использовать атомарные операции.
Если это условие нарушено, получаем дата рэйс ( не рэйс кондишн ).
Неатомарны операции из нескольких инструкций ( даже в одну строку асма )
64-bit long var is used under x86 ( requires two registers and two mov's )
Если поток, вызывающий function, будет прерван между двумя инструкциями записи, то он оставит в памяти значение 0x0000000000000002 — это разорванная операция записи

MOV неатомарна, если операнд не выровнен в памяти ( qword с адресом, не кратным четырем и тд )

Все операции C/C++ считаются неатомарными!!!!
Расслабленные (relaxed) атомарные операции
#include <atomic>

std::atomic<uint64_t> sharedValue(0);

void storeValue()
{
    sharedValue.store(0x100000002, std::memory_order_relaxed);
}

uint64_t loadValue()
{
    return sharedValue.load(std::memory_order_relaxed);
}

uint64_t loadValue()
{
    return mint_load_64_relaxed(&sharedValue);
}

_relaxed в идентификаторах. Этот суффикс напоминает об определенных гарантиях относительно упорядочивания памяти (memory ordering).

В частности, для таких операций допукается переупорядочивание операций с памятью в соответствии с переупорядочиванием компилятором либо с переупорядочиванием памяти процессором. Компилятор даже может оптимизировать избыточные атомарные операции, так же как и неатомарные. Но во всех этих случаях атомарность оперций сохраняется.
Нужно юзать атомарные операции!

lock-free data structs
основная задача программиста при проектировании и разработке сложных программных проектов, особенно серверных, — наиболее эффективно задействовать все имеющиеся ресурсы целевой платформы. 
лабое место современных API типа pthreads, Win32 API, предлагаемых операционными системами: API дают средство построения параллельных программ (это средство – потоки, threads), но не дают средств построения параллельных структур данных, обеспечивающих совместный доступ. Вместо этого API предоставляют средства ограничения доступа к данным в виде примитивов синхронизации. Однако синхронизация – это узкое место параллельных программ.
CRITICAL_SECTIONs плохие, они заставляют потоки ждать ради пары асмовых инструкций
При возрастании числа потоков синхронизированный доступ к данным становится узким местом программы; зачастую при увеличении степени параллельности вместо пропорционального увеличения производительности мы получаем её ухудшение в условиях большой нагрузки (high contention).
red-black tree: во многих задачах (и на многих архитектурах) AVL tree оказывалось быстрее.
Транзакционная память – это обширная область исследований, нацеленная в основном на будущее. Алгоритмы, основанные на транзакционной памяти, подразумевают, грубо говоря, что память поддерживает атомарные транзакции, которые можно атомарно принять (commit) или отклонить (rollback). Очевидно, что такая память должна быть реализована в железе; 
Fine-grained алгоритмы – это изощренные методы синхронизации, как правило, построенные не на применении примитивов синхронизации, предоставляемых OC, а на применении “легких” атомарных примитивов, например, на spin-lock.
Lock-free структурами данных я буду называть структуры данных, не требующие внешней синхронизации доступа. Это неформальное, чисто техническое определение, отражающее внутреннее строение контейнера и операций над ним. Слово “внешней” здесь выделено намеренно: надо понимать, что вовсе без применения специальной поддержки со стороны процессора lock-free структуры данных построить, скорее всего, не удастся. Но поддержка такого рода в lock-free контейнерах обеспечивается не синхронизацией доступа к последовательным методам контейнера, а механизмом атомарной модификации, зашитым внутрь методов контейнера, либо внутренней синхронизацией на уровне составных частей контейнера 
Формальное определение lock-free объекта звучит так [Her91]: разделяемый объект называется lock-free объектом (неблокируемым, non-blocking объектом), если он гарантирует, что некоторый поток закончит выполнение операции над объектом за конечное число шагов вне зависимости от результата работы других потоков (даже если эти другие потоки завершились крахом). Более строгое понятие wait-free объекта гласит: объект является wait-free, если каждый поток завершит операцию над объектом за конечное число шагов. Условие lock-free гарантирует продвижение как минимум какого-то одного потока, тогда как более сильное условие wait-free гарантирует успешное выполнение для всех потоков. В теории конкурентных структур данных существует также понятие linearizability [Her90], играющее важную роль в формальных доказательствах корректности lock-free алгоритмов. Грубо говоря, алгоритм является линеаризуемым (linearizable), если результат его работы виден по окончании алгоритма. 
При традиционном подходе мы действуем так: блокируем доступ к контейнеру, что-то с ним делаем (например, добавляем элемент), разблокируем. В момент разблокировки мы знаем, что вставленный элемент находится в контейнере. В lock-free контейнере всё не так. Нам не нужно блокировать доступ, мы просто вызываем метод добавления. Если он возвратил true, значит, вставка прошла успешно. Но это не значит, что элемент находится в контейнере, — он уже может быть удален конкурирующим потоком. Это демонстрирует важное отличие lock-free контейнеров от традиционных a la STL, — мы не можем вытаскивать внутренности реализации контейнера наружу; например, концепция итераторов, широко используемая в STL, не применима к конкурентным структурам данных. 
В lock-free очереди мы видим:
бесконечный цикл – мы пытаемся выполнить операцию, пока не получится. Это типичный паттерн применения атомарной операции compare_exchange;
защиту локальных переменных (guards) с помощью одного из методов безопасной работы с памятью (указателями) в lock-free алгоритмах, в данном случае – это метод Hazard Pointers;
применение атомарных примитивов C++11 – load, compare_exchange, барьеров памяти memory_order_xxx;
helping — очень распространенный прием в lock-free алгоритмах, когда один поток помогает другому сделать его работу;
применение back-off стратегий (функтор bkoff), которые не являются обязательными, но позволяют в некоторых случаях существенно разгрузить процессор в условиях сильной нагрузки, когда много потоков обращаются к очереди одновременно

В контексте же многопоточного программирования с разделяемой памятью, синхронизация — это совсем про другое (и для многих этот факт является большим сюрпризом). Здесь инструкции синхронизации означают всего лишь локальный запрет на переупорядочивания операций. Как я уже не раз писал, если я выдаю барьер памяти — это не означает, что я требую немедленно синхронизироваться с основной памятью, или кэшами соседних процессоров, это всего лишь означает, что я требую, чтобы эта синхронизация, когда бы она не произошла — выполнялась в определенном порядке. И это не какая-то там теория, все так на практике и есть: когда, на x86, вы выдаете lock add %esp, 0 — никакой глобальной синхронизации не происходит, процессор просто сбрасывает свой store buffer в свой же локальный кэш. Ни в основную память, ни в кэши соседних процессоров эти данные никто немедленно отправлять не будет (разумеется, на архитектурах без аппаратной кэш-когерентности, типа ARM-ов, этот процесс может выглядеть иначе — я точно не знаю, как). 
Таким образом взаимодействие потоков посредством разделяемой памяти состоит из двух частей: непосредственно передача данных между ядрами, и структурирование этой передачи — дабы данные не передавались в абы каком порядке. И вот вторая часть это вотчина инструкций синхронизации, а первая вообще происходит под ковром — но все-таки происходит, про это надо помнить. 
С точки же зрения же оптимизации — в многопоточных программах (точно так же, как и в распределенных системах) фокус должен быть на уменьшении трафика между потоками, а вовсе не на уменьшении количества инструкций синхронизации. Производительность хорошо написанного многопоточного кода упирается чаще всего именно в шину. Проблема здесь в том, что инструкции синхронизации — они вот, прямо в коде написаны, бери да вычеркивай. А физический обмен данными скрыт где-то под ковром, и возможности прямо на него влиять — нет

NO printf in signal handlers
It is not safe to call all functions, such as printf, from within a signal handler. A useful technique is to use a signal handler to set a flag and then check that flag from the main program and print a message if required.

Notice in example below, signal handler ding() set a flag alarm_fired to 1 as SIGALRM caught and in main function alarm_fired value is examined to conditionally call printf correctly.
Additionally, you need to take special care in writing handler functions because they can be called asynchronously. That is, a handler might be called at any point in the program, unpredictably. If two signals arrive during a very short interval, one handler can run within another. And It is considered better practice to declare volatile sigatomic_t, this type are always accessed atomically, avoid uncertainty about interrupting access to a variable. 





линукс файлсистем
http://linux.yaroslavl.ru/docs/book/burk/Part4.html

stack trace
backtrace
https://www.linuxjournal.com/article/6391
http://w3cgeek.com/c-stack-trace-from-unhandled-exception.html
http://man7.org/linux/man-pages/man3/backtrace.3.html

c/c++ extensions
https://habr.com/post/315676/

shared_ptr aliasing constructor
https://habr.com/post/263751/

copy_on_write
https://habr.com/post/229327/

shared_ptr operations
https://ru.cppreference.com/w/cpp/memory/shared_ptr/operator_cmp

периодическая дробь в обыкновенную
http://geleot.ru/education/math/arithmetic/rational_numbers/periodic_to_fraction

iterator_tag
https://en.cppreference.com/w/cpp/iterator/iterator_tags

инЪективность\сюрЪективность
http://www.cyberforum.ru/mathematical-logic-sets/thread1474083.html

fpathconf() получает значение параметра настроек name для открытого дескриптора файла fd.
pathconf() получает значение параметра настроек name для файла с именем path.

рухнет только в случае if(*i) аргументация:
операция if(somevar) - делает исключительно логическую проверку. если бы получая указатель
данная операция пыталась бы определить валидный он или нет - это был бы не C way.тк
проверка валидности того или иного адреса - прерогатива и основа гарбидж коллектора,
тк организовав такой механизм на кой чёрт нужна работа с памятью напрямую?

int *i = (int*)malloc(sizeof(*i));
free(i);
if (i) //узнаем, на чо указывает птр - на то же, что и до вызова фри, однако читай ниже
		i = NULL;																	
ISO C99 таки позволяет реализацию в которой при любом использовании указателя после вызова free может случиться фигня



быстрый доступ для каспи: отрицательная единица

readdir_r is deprecated
     It is recommended that applications use readdir(3) instead of
       readdir_r().  Furthermore, since version 2.24, glibc deprecates
       readdir_r().  The reasons are as follows:

       *  On systems where NAME_MAX is undefined, calling readdir_r() may be
          unsafe because the interface does not allow the caller to specify
          the length of the buffer used for the returned directory entry.

       *  On some systems, readdir_r() can't read directory entries with
          very long names.  When the glibc implementation encounters such a
          name, readdir_r() fails with the error ENAMETOOLONG after the
          final directory entry has been read.  On some other systems,
          readdir_r() may return a success status, but the returned d_name
          field may not be null terminated or may be truncated.

       *  In the current POSIX.1 specification (POSIX.1-2008), readdir(3) is
          not required to be thread-safe.  However, in modern
          implementations (including the glibc implementation), concurrent
          calls to readdir(3) that specify different directory streams are
          thread-safe.  Therefore, the use of readdir_r() is generally
          unnecessary in multithreaded programs.  In cases where multiple
          threads must read from the same directory stream, using readdir(3)
          with external synchronization is still preferable to the use of
          readdir_r(), for the reasons given in the points above.

       *  It is expected that a future version of POSIX.1 will make
          readdir_r() obsolete, and require that readdir(3) be thread-safe
          when concurrently employed on different directory streams.

А вот разъменование указателя, который позже проверяется на NULL — это не просто ошибка,
это катастрофа. Дело в том, что компилятор может после этого проверку на NULL просто
выкинуть. Именно потому что undefined behavior с точки зрения компилятора «не бывает» и
уж если ты указатель разименовал, то ты тем самым «пообещал», что соответствующий указатель
— не NULL.
XDR *xdrs = &clp->xdr_stream; это Разыменование
XDR *xdrs = &((*clp).xdr_stream); эквивалентно этому

// Members need to be reordered to gain minimum structure size

pc-lint patches
https://www.gimpel.com/html/ptch90.htm
Например, для Win64 систем выкачать файлы l9-h-i.lp, l9-i-j.lp, l9-j-k.lp.
Все файлы *.lp скопировать в папку с программой и выполнить команды
LPATCH.EXE l9-a-b.lp
LPATCH.EXE l9-b-c.lp
LPATCH.EXE l9-c-d.lp
LPATCH.EXE l9-d-e.lp
LPATCH.EXE l9-e-f.lp
LPATCH.EXE l9-f-g.lp
LPATCH.EXE l9-g-h.lp
LPATCH.EXE l9-h-i.lp
LPATCH.EXE l9-i-j.lp
LPATCH.EXE l9-j-k.lp

C Prog Language
Confusingly, the term "ANSI C" is still commonly (and incorrectly) used to refer to the language defined by the 1989/1990 editions, and gcc -ansi still refers to that version. I suggest that the term "ANSI C" is ambiguous and should be avoided. Refer to C89/C90, C99, or C11 instead. 	

если среди аргументов нет чисел типа
unsigned, то можно обойтись следующим неформальным набором правил.
■ Если один из операндов имеет тип long double, другой преобразуется в long
double.
■ В противном случае, если один из операндов — double, другой преобразуется в
double.
■ В противном случае, если один из операндов— float, другой преобразуется в
float.
■ В противном случае char и short преобразуются в int.
■ Затем, если среди операндов есть long, другой преобразуется в long.
Заметьте, что числа типа float в выражениях не преобразуются в double 
автоматически; это — изменение по сравнению с исходным определением языка.

Правила преобразования становятся сложнее, если в выражениях участвуют 
аргументы типа unsigned. Проблема состоит в том, что сравнение между величинами со 
знаком и без знака является системно-зависимым, потому что зависит от размеров 
целочисленных переменных. Для примера предположим, что тип int имеет длину 16 бит, а
long — 32 бита. Тогда - 1L < 1U, поскольку 1U, будучи числом типа int, расширяет-ся до signed long. Но при этом -1L > 1UL, потому что -1L расширяется до
unsigned long и становится большим положительным числом:
// 1111 == - 1
// cast to unsigned
// 2^4 - 1
// so that -1L > 1UL cuz we have to convert -1 to unsigned
// and that doesn't do what we would expect

Мы уже говорили о том, что оператор присваивания имеет значение, как любое 
другое выражение, и поэтому может сам входить в выражения. Вот самый 
распространенный пример такого рода:
while ((с = getcharO) != EOF)
Другие операции с присваиванием (+=, -= и т.д.) тоже могут фигурировать в 
выражениях, хотя и встречаются в них не так часто.
Во всех таких случаях тип выражения с присваиванием соответствует типу левого
операнда, а его значение равно значению этого операнда после присваивания.

z = (а > Ь) ? а : b; /* z = max(a, b) */

Как и в большинстве языков, в С в основном не указывается порядок вычисления
операндов в операциях. (Исключениями являются &&, | |, ? : и ', \) Например, в 
следующем операторе первой может вызываться как функция f (), так и функция g ():
х = f () + g();
Если в одной из функций, f или д, модифицируется переменная, от которой зависит
работа другой функции, то итоговое значение х будет зависеть от порядка вызова. Чтобы
гарантировать определенную последовательность операций, следует поместить 
промежуточный результат в какую-нибудь временную переменную.
Аналогичным образом, не определяется и порядок, в котором вычисляются 
аргументы функции при ее вызове. Поэтому следующий оператор может дать различные 
результаты при трансляции разными компиляторами:
printf("%d %d \n", ++n, power(2, n)); /* НЕПРАВИЛЬНО */
Результат будет зависеть от того, получает ли п приращение до или после вызова
функции power. Чтобы решить проблему, достаточно записать так:
++П;
printf("%d %d \n", n, power(2, n));

Таким образом, из всего вышесказанного можно сделать вывод, что писать код, 
зависящий от порядка вычисления аргументов или операндов, — это плохой стиль в любом
языке программирования. Разумеется, необходимо знать, каких вещей избегать, однако
если вы вообще не знаете, как те или иные операции выполняются в разных системах, у
вас не возникнет искушения воспользоваться свойствами конкретной реализации.

Если у функции отсутствует прототип, она объявляется в неявном виде - своим
первым появлением в таком выражении, как
sum				+= atof ( line );
Если в выражении встречается имя, которое ранее не объявлялось, и если после него
стоят круглые скобки, оно по контексту объявляется функцией. По умолчанию 
считается, что эта функция возвращает число типа int, а относительно ее аргументов не 
делается никаких предположений. Более того, если объявление функции не содержит 
аргументов, то и в этом случае не делается никаких предположений относительно их типа и
количества, как в этом примере:
double atof();
Это для обратной совместмости, но если указывать, что агументов нет, пиши воид.

При наличии функции atof, объявленной должным образом, с ее помощью можно
написать функцию atoi (для преобразования строки в целое число):
/* atoi: преобразует строку s в целое число с помощью atof */
int atoi(char s[])
{
86
Глава 4double atof(char s [] ) ;
return (int) atof(s);
}
Обратите внимание на структуру объявления и на оператор return, обычная форма
которого такова:
return выражение;
Стоящее в операторе выражение всегда преобразуется к возвращаемому типу перед
выполнением оператора. Поэтому значение atof, имеющее тип double, автоматически
преобразуется в тип int в том случае, если оно фигурирует в этом операторе, поскольку
функция atoi возвращает тип int. При выполнении этой операции возможна 
частичная потеря информации, поэтому некоторые компиляторы в таких случаях выдают 
предупреждения. А вот при наличии явного приведения типов компилятору становится ясно,
что операция выполняется намеренно, так что он не выдает предупреждений.
Внешнее связывание external linkage это когда все ссылки по одним и тем же именам, являются ссылками
на один и тот же объект программы.

Скобки парсятся обратной польской записью ( Форз и постскрипт ) и инифксной
Что такое getch и ungetch? Часто бывает, что программа не может определить,
достаточно ли она прочитала данных, до тех пор, пока не прочитает их слишком много.
Один из примеров — это накопление символов, составляющих число. Пока не 
встретится первый символ, не являющийся цифрой, ввод числа не завершен; но как только он
встретится, он оказывается лишним, и программа не знает, как его обрабатывать.
К счастью, возврат символа в поток довольно легко смоделировать, написав для 
этого пару специальных функций. Функция getch будет извлекать следующий символ из
потока ввода, а функция ungetch — запоминать символы, возвращаемые в поток, 
чтобы при следующем вызове getch вначале вводились они, а потом уже те, которые 
действительно поступают из потока ввода.
Стандартная библиотека содержит функцию ungetc, которая возвращает в поток
один символ;

Область видимости
Важно понимать различие между объявлением внешней переменной и ее 
определением. Объявление сообщает, что переменная обладает определенными свойствами (в 
основном типом), а определение выделяет место в памяти для ее хранения. Если 
следующие строки фигурируют вне функций, то они являются определениями внешних 
переменных sp и val:
int sp;
double val[MAXVAL];
Благодаря этому определению выделяется память для хранения переменных. Кроме
того, это еще и объявление, действительное до конца файла. С другой стороны, 
следующие строки дают только объявление, также действительное до конца файла, согласно 
которому sp имеет тип int, a val является массивом типа double (его размер 
определяется в другом месте). При этом память не выделяется и переменные не создаются.
extern int sp;
extern double val[];
Во всех файлах, образующих исходный текст программы, должно быть в общей
сложности не больше одного определения внешней переменной; в других файлах могут
содержаться объявления со словом extern, чтобы оттуда можно было к ней 
обращаться. (В файле, содержащем определение переменной, также могут находиться и extern-
объявления ее же.) Размеры массивов обязательно указываются в определении, но 
необязательно — в объявлении со словом extern.
Инициализация внешней переменной выполняется только в определении.

Инициализация
При отсутствии явной инициализации внешние и статические переменные 
гарантированно инициализируются нулями, а автоматические и регистровые получают 
неопределенные начальные значения ("мусор").

Фактически инициализация автоматической переменной— это сокращенная запись
для комбинации объявления и оператора присваивания. Какую из форм записи 
предпочесть — это, в общем-то, вопрос вкуса. Мы обычно употребляем явные операторы 
присваивания, поскольку инициализации в объявлениях труднее разглядеть и они дальше от
точки использования той или иной переменной.

Включение файлов
Директива #include — это оптимальный способ собрать все объявления в нужном
месте в большой программе. Этот способ гарантирует, что все файлы исходного кода 
будут включать одни и те же макроопределения и объявления внешних переменных, таким
образом ликвидируя возможность появления особенно неприятных ошибок. Разумеется,
при внесении изменений во включаемый файл все файлы, которые ссылаются на него,
должны быть перекомпилированы.

Выражение наподобие х = 0, i++ или printf (...) становится оператором, если
после него поставить точку с запятой:

Обычная практика — ставить все определения внешних переменных в начале файла 
исходного кода, а затем опускать все объявления extern.

В тернарной операции каждый из исходов вычилсяется только раз.
В иф елсе по очереди, пока  условие !тру

else всегда ассоциируется с ближайшим предыдущим оператором if без else.
рекомендуется всегда использовать фигурные скобки для выделения
вложенных операторов if.

запятые, которые разделяют аргументы функций, переменные в объявлениях
и т.п., не являются знаками операций и не гарантируют порядок вычисления слева 
направо.
Операцию "запятая" следует использовать как можно реже и с осторожностью. 
Наиболее уместно ее применение в конструкциях, где объединяются в единое целое 
связанные друг с другом операции,

Запятую
вполне можно применить при обмене местами элементов в функции reverse, 
поскольку этот обмен можно представить себе единой операцией:
int i, j, c; 
char *s;
for (i = 0, j = strlen(s)-1; i < j; i++, j--)
c = s[i], s[i] = s[j], s[j] = c;

есть несколько ситуаций, в которых и goto может найти свое место
под солнцем. Наиболее распространенная— это необходимость прекратить работу
управляющей структуры с большим количеством вложений, например выйти сразу из
двух и более вложенных циклов. Оператор break тут не применим непосредственно,
поскольку он обеспечивает выход только из внутреннего, ближайшего цикла.

Pointers
Операция & применима только к 
объектам, хранящимся в оперативной памяти: переменным и элементам массивов.
Ее нельзя
применить к выражениям, константам и регистровым переменным (register).
Выражение s+ +
не оказывает никакого влияния на символьную строку во внешней функции, вызвавшей
strlen, а всего лишь инкрементирует локальную копию указателя, действительную in strlen only

Alloc Free
Самый простой вариант реализации alloc — это раздача ею по запросам небольших
фрагментов большого текстового массива, который мы назовем allocbuf. Этот массив
будет закрытым — доступным только функциям alloc и afree. Поскольку эти 
функции оперируют не индексами, а указателями, другим модулям программы вообще 
незачем знать имя этого массива, который можно объявить статическим (static) в файле
исходного кода, содержащем alloc и afree, и таким образом сделать массив 
невидимым снаружи. В практических приложениях этот массив может и вовсе не иметь 
имени — например, он может быть создан вызовом функции malloc или получен по 
запросу к операционной системе, которая в ответ выдает указатель на неименованный блок
памяти.
В каждый момент необходимо знать, какая часть массива allocbuf уже 
израсходована. Мы используем указатель allocp для указания на следующий свободный элемент.
Когда у функции alloc запрашивают п символов, она проверяет, осталось ли в
allocbuf достаточно места. Если да, то alloc возвращает текущее значение allocp
(т.е. начало свободного блока) и затем увеличивает его на п, чтобы теперь указатель 
указывал на начало следующей свободной области. Если свободного места нет, alloc 
возвращает нуль. Функция afree просто делает allocp равным аргументу р, если р 
указывает на место внутри allocbuf.
Любой указатель можно сравнивать с нулем, и это сравнение всегда будет иметь
смысл. Но если указатели не указывают на один и тот же массив, то арифметические
операции и сравнения с их участием не будут определены. (Есть одно исключение: в 
адресной арифметике можно применять также первый элемент после конца массива.)
К числу разрешенных операций с указателями относятся:
■ присваивание указателей одного типа;
■ сложение или вычитание указателя и целого числа;
■ вычитание или сравнение указателей, указывающих на один и тот же массив 
данных;
■ присваивание нуля или сравнение с ним.

Между следующими двумя определениями есть важное различие:
char amessage[] = "now is the time"; /* массив */
char *pmessage = "now is the time"; /* указатель */
В первом из них amessage — это массив, ровно такой длины, чтобы в него 
поместилась инициализирующая строка символов и завершающий ' \ 0 '. Отдельные символы
в строке можно изменять, но переменная amessage всегда будет указывать на один и
тот же участок памяти. А вот pmessage — это указатель, который после инициализации
указывает на строковую константу; впоследствии этот указатель можно изменить так,
чтобы он указывал в другое место, но попытка изменить содержимое строки после этого
даст неопределенный результат.

Многомерные массивы
Если двумерный массив необходимо передать в функцию, среди ее параметров 
должно быть количество столбцов. Количество строк необязательно, поскольку фактически
передается, как и раньше, указатель на массив строк, каждая длиной 13 элементов типа
char. Другими словами, это указатель на объект, представляющий собой массив из 13
элементов типа char.

Командная строка
По определению argv [ 0 ] содержит имя, под которым запускается программа, 
поэтому argc всегда не меньше 1. Если счетчик argc равен 1, то после имени программы
нет никаких аргументов командной строки. В приведенном выше примере argc равен 3,
a argv[0], argv[l] и argv [2] содержат соответственно "echo", "hello," и
"world". Первый необязательный аргумент хранится в argv[l], а последний— в
argv [argc-1]. Кроме того, стандарт требует, чтобы элемент argv [argc] был 
нулевым указателем.

Функптр
Алгоритм сортировки часто состоит из трех частей: процедуры сравнения, 
определяющей способ упорядочения любой пары объектов; процедуры обмена местами, 
изменяющей порядок следования такой пары; собственно процедуры сортировки, 
выполняющей сравнение и обмен, пока объекты не окажутся упорядоченными. Сама 
сортировка независима от вида операций сравнения и обмена, поэтому можно задать сортировку
по различным критериям, передавая в алгоритм разные функции сравнения и обмена.
Любой указатель кастится к воид птр и обратно без потери информации.
Сердцевина программы del — это пара функций del и dirdcl, которые 
раскладывают объявление согласно приведенной выше грамматике. Поскольку грамматика 
определена рекурсивно, функции также вызывают друг друга рекурсивно, распознавая 
соответствующие фрагменты объявления. Поэтому программа называется синтаксическим
анализатором по методу рекурсивного спуска,
Поскольку эти программы всего лишь демонстрационные, они не отличаются
"дуракоустойчивостью" и работают лишь со значительными ограничениями.
Функция gettoken пропускает пробелы и табуляции, затем находит следующую
лексему (смысловой элемент объявления) в потоке. Под лексемой {token) будем 
понимать имя, пару круглых скобок, пару квадратных скобок (возможно, с числом между 
ними) или любой другой одиночный символ.

структуры
struct point addpoint(struct point p1, struct point p2)
{
	p1.x += p2.x;
	p1.у + = p2.y;
	return p1;
}
Здесь структурами являются как аргументы, так и возвращаемое значение. Вместо 
того чтобы помещать результат во временную переменную, мы инкрементировали 
компоненты структуры p1, чтобы подчеркнуть тот факт, что параметры-структуры передаются
по значениям, как и любые другие параметры.
Функция ptinrect анализирует, находится ли точка
внутри прямоугольника. При этом условно считается, что прямоугольнику принадлежат
его левая и нижняя сторона, но не принадлежат правая и верхняя.
/* ptinrect: возвращает 1, если р в г, 0 в противном случае */
int ptinrect(struct point p, struct rect r)
{
return p.x >= r.ptl.x && p.x < r.pt2.x
&& p.у >= r.ptl.y ScSl p.у < r.pt2.y;
}
Здесь предполагается, что прямоугольник представлен в стандартной форме, в 
которой координаты ptl меньше, чем координаты pt2. Следующая функция возвращает
прямоугольник, гарантированно приведенный к канонической форме:
#define min(a, b) ((a) < (b) ? (а) : (b))
#define max(a, b) ((a) > (b) ? (a) : (b))
/* canonrect: приведение координат прямоугольника
к каноническому виду */
struct rect canonrect(struct rect r)
{
struct rect temp;
temp.ptl.x = min(r.ptl.x, r.pt2.x);
temp.ptl.у = min(r.ptl.y, r.pt2.y);
temp.pt2.x = max(r.ptl.x, r.pt2.x);
temp.pt2.y = max(r.ptl.y, r.pt2.y);
return temp
}
Если в функцию необходимо передать большую структуру, это лучше сделать, передав птр, а не
копию ее данных

Операции обращения к структурам (точка и - >) наряду с круглыми скобками для 
вызовов функций и квадратными для индексов массивов находятся на самой вершине 
иерархии приоритетов, а потому применяются к своим аргументам всегда в первую 
очередь. Пусть имеется объявление:
struct {
int len;
char *str;
} *P;
Тогда выражение ++p->len инкрементирует len, а не р. По умолчанию скобки в
нем расставляются следующим образом: ++(р->1еп).С помощью скобок можно 
изменить порядок применения операций: выражение (++р) ->1еп инкрементирует р до 
обращения к len, а (р++) ->1еп инкрементирует его после обращения. (В последнем
случае скобки не обязательны.)

Проблема состоит в
том, что как &tab [-1], так и &tab [n] находятся за пределами массива tab. Первый
из указателей категорически запрещен к употреблению, а по второму нельзя ссылаться.
Тем не менее стандарт языка гарантирует, что адресная арифметика с участием первого
элемента после конца массива (т.е. &tab [n]) будет работать корректно.

Поскольку список слов
заранее неизвестен, их нельзя предварительно удобно отсортировать и применить двоичный поиск. И все-таки не хочется выполнять линейный поиск (перебор) каждого вновь
поступающего слова в таблице уже имеющихся; такая программа выполнялась бы 
слишком долго. (Строго говоря, время выполнения зависело бы квадратично от количества
поступающих слов.)

Узлы должны быть организованы так, чтобы в каждом из них левое поддерево 
содержало только слова, "меньшие" по алфавиту, чем слово в узле, а правое поддерево —
только "большие".

Чтобы выяснить, есть ли вновь поступившее слово в дереве, начинают с корня и
сравнивают новое слово с тем, которое помещено в этот корень. Если они совпадают,
ответ на вопрос получен. Если новое слово меньше, чем корень дерева, следует 
продолжить поиск в левом поддереве; в противном случае — в правом поддереве. Если в 
выбранном направлении нужного дочернего узла нет, значит, нового слова вообще нет в
дереве, и пустое место, до которого мы добираемся при поиске, — это как раз место для
нового слова. Этот процесс имеет рекурсивный характер, поскольку поиск с началом в
любом узле включает в себя поиск по одному из его дочерних узлов.

Практическое примечание: если дерево станет "несбалансированным", потому что
слова поступают не в случайном порядке, время работы программы может сильно 
увеличиться. В самом худшем случае — если все слова уже упорядочены — программа
выполняет довольно затратную симуляцию линейного поиска.

о мем аллокаторе
как удовлетворить требование большинства реальных систем к 
выравниванию объектов некоторых типов по границам машинных слов (например, целые числа
часто выравниваются по четным адресам)?
Требования к выравниванию обычно удовлетворить нетрудно за счет некоторых 
избыточных затрат памяти. Для этого нужно сделать так, чтобы функция распределения
памяти всегда возвращала указатель, удовлетворяющий всем возможным требованиям к
выравниванию.


Поиск по таблице
#define IN 1
Как только в тексте программы встречается такая директива, имя IN и его 
подстановка 1 записываются в таблицу. Позже, всякий раз, когда имя IN встретится в тексте, его
следует заменить на 1, например:
state = IN;
Всю работу с именами и текстами подстановки выполняют две функции. Первая,
install(s,t), записывает имя s и текст подстановки t в таблицу; s и t — простые
текстовые строки. Функция lookup (s) разыскивает строку s в таблице и возвращает
указатель на место, в котором она ее нашла, или NULL, если не нашла.
Алгоритм основан на поиске в хэш-таблице: поступающее имя конвертируется в 
небольшое неотрицательное число, которое используется как индекс в массиве указателей.
Каждый элемент массива указывает на начало связанного списка блоков, описывающих
имена, которые соответствуют данному хэш-коду. Если какому-либо хэш-коду не 
соответствуют никакие имена, возвращается NULL.

тупедеф
Обратите внимание, что имя нового типа, объявляемое в typedef, стоит не сразу
после ключевого слова, а на месте имени переменной. Синтаксически ключевое слово
typedef можно считать аналогом идентификатора класса памяти— например,
extern, static и т.п. Новые типы, определяемые с помощью typedef, начинаются с
прописной буквы, чтобы можно было их легко различить.
с его помощью определяется новое имя для некоторого уже 
существующего типа данных. Нет в нем и никаких смысловых тонкостей: переменные,
объявленные таким образом, имеют точно такие же свойства, как и переменные, тип 
которых выписан явно, без "псевдонима". Фактически оператор typedef очень 
напоминает директиву #def ine с тем исключением, что, поскольку он анализируется 
компилятором, он может допускать такие текстовые подстановки, которые препроцессору не по
силам. Например:
typedef int (*PFI)(char *, char *);

Юнионы
Объединение — это переменная, которая может содержать объекты различных типов
и размеров (но не одновременно); при этом удовлетворение требований к размеру и 
выравниванию возлагается на компилятор. С помощью объединений можно работать с
данными различных типов в пределах одного участка памяти, не привнося в программу
элементы низкоуровневого, машинно-зависимого программирования.
union u_tag {
int ival;
float fval;
char *sval;
} u;
Переменная и будет иметь достаточную длину, чтобы содержать данные самого
длинного из трех типов; конкретный размер зависит от системы и реализации. 
Переменной и можно присваивать данные любого типа, а затем использовать их в выражениях
(строго по правилам работы с конкретным типом). Извлекать можно данные только того
типа, какие были помещены при последнем обращении к переменной. Следить и 
помнить, какие именно данные были помещены в объединение, — это забота программиста;
Фактически объединение является структурой, в которой все элементы имеют 
нулевое смещение от ее начала, сама она имеет достаточную длину, чтобы в нее поместился
самый длинный элемент, и при этом выравнивание выполняется правильно для всех 
типов данных в объединении.
Объединение можно инициализировать только данными того типа, который имеет его
первый элемент.

Битфилды
Практически все, что связано с битовыми полями, является системно-зависимым. 
Например, только в конкретной реализации определяется, могут ли поля перекрывать 
границы слов. Поля не обязаны иметь имена; безымянные поля (двоеточия с размером после них) часто используются для пропуска и резервирования отдельных битов. Для 
принудительного выравнивания по границе следующего слова можно использовать 
специальное значение длины поля, равное 0.

printf.
Буква h, если целое число следует вывести как короткое (short), или буква 1, 
если как длинное (long) after %
Число (точность представления), задающее максимальное количество символов
при выводе строки, или количество цифр в вещественном числе после десятичной
точки, или минимальное количество цифр для целого числа.
Ширину или точность можно указать в виде символа *. В этом случае нужное 
значение будет вычисляться по следующему аргументу (который должен иметь тип int). 
Например, вывод не более max символов из строки s выполняется так:
printf("%.*s", max, s);
Следует также иметь в виду разницу между этими двумя вызовами:
printf(s); /* ОШИБКА, ЕСЛИ s СОДЕРЖИТ % */
printf("%S", s); /* БЕЗОПАСНО */
Вот как на самом деле объявляется функция printf:
int printf(char *fmt, ...)
Макрос va_start инициализирует ар так,
чтобы переменная указывала на первый безымянный аргумент.
Функция должна иметь как
минимум один аргумент с именем; последний именованный аргумент используется 
макросом va_start для инициализации своей работы.
Каждый вызов va_arg возвращает один аргумент и передвигает указатель ар на
следующий. Чтобы определить, какого типа аргумент нужно возвращать и на сколько
передвигать указатель, va_arg использует заданное ему имя типа. Наконец, макрос
va_end выполняет необходимые завершающие операции. Его необходимо вызвать до
возвращения из функции.

scanf
Функция scanf ( из стд инпут ) игнорирует пробелы и табуляции в строке формата. Более того, при
поиске данных во входном потоке она пропускает вообще все символы пустого 
пространства (пробелы, табуляции, концы строк и т.д.). Считывание потока, формат 
которого не фиксирован, лучше выполнять по одной строке, которую затем разбирать функцией
sscanf ( из строки ).

Аналогичным образом
vfprintf и vsprintf повторяют возможности соответственно fprintf и sprintf.

Напомним, что файлы в стандартной библиотеке описываются файловыми 
указателями, а не дескрипторами. Файловый указатель — это указатель на структуру, 
содержащую набор данных о файле. Набор данных включает в себя указатель на буфер, через 
который файл можно читать большими фрагментами; счетчик количества символов, 
оставшихся в буфере; указатель на очередную символьную позицию в буфере; дескриптор
файла; различные флаги, задающие режим чтения и записи, текущие ошибки и т.д.
Начнем с краткого обзора устройства файловой системы Unix. Каталогом {directory)
в ней называется файл, содержащий список имен файлов и информацию об их 
местоположении. Эта информация представляет собой ссылку на другую таблицу — список 
файловых индексов. Файловый индекс (inode) представляет собой структуру данных, 
содержащую всю информацию о файле, кроме его имени. Каждый пункт списка файлов в 
каталоге обычно состоит из имени файла и соответствующего номера индекса.

malloc
Поскольку в ходе других операций в программе также может 
запрашиваться память без помощи этой функции распределения памяти, управляемое malloc
пространство может оказаться не непрерывным. Таким образом, свободная память будет
храниться в виде списка свободных блоков. Каждый блок содержит свой размер, 
указатель на следующий блок и сам участок памяти. Блоки хранятся в порядке возрастания
адресов, а последний блок (с самым старшим адресом) ссылается на первый.
Когда поступает запрос на память, выполняется перебор списка свободных блоков,
пока не обнаруживается достаточно большой блок. Этот алгоритм кратко называется
"первый подходящий" — в отличие от "наилучшего подходящего", в котором 
отыскивается наименьший из блоков, подходящих по размеру. Если блок имеет точно такой 
размер, как запрашивается, он отсоединяется от списка и передается пользователю. Если
блок имеет больший размер, он делится на части, и пользователь получает столько,
сколько просил, а остаток остается в списке. Если не удается найти достаточно большой
блок, у операционной системы запрашивается очередной большой фрагмент памяти, 
который подключается к списку.
При освобождении также выполняется поиск по списку свободных блоков: 
отыскивается место для вставки освобождаемого блока. Если освобождаемый блок вплотную гра
Глава граничит со свободным блоком с какой-либо из двух сторон, то он сливается с ним в 
единый блок большего размера, чтобы не слишком фрагментировать память. Определить,
как граничат блоки, нетрудно, поскольку список свободных блоков организован по 
возрастанию адресов.
Одна проблема, на наличие которой мы намекали в главе 5, заключается в том, чтобы
обеспечить правильное выравнивание блока памяти, получаемого от mall ос, для 
хранения помещаемых в нее объектов.
Свободный блок содержит указатель на следующий блок в цепочке, размер блока и
собственно участок свободной памяти; управляющая информация в начале называется
"заголовком". Чтобы упростить выравнивание, все блоки по длине кратны размеру 
заголовка, а сам заголовок выровнен надлежащим образом. Это делается с помощью 
объединения, содержащего желаемую структуру заголовка и экземпляр самого требовательного
типа данных, которым мы назначили long:
typedef long Align; /* для выравнивания по границе long */
union header { /* заголовок блока */
struct {
union header *ptr; /* следующий блок, если есть */
unsigned size; /* размер этого блока */
} s;
Align x; /* принудительное выравнивание блоков */
};
typedef union header Header;
Поле длины, size, необходимо, поскольку блоки, распределяемые функцией
malloc, не обязаны занимать сплошную область, — поэтому вычислить их длину с 
помощью адресной арифметики невозможно.
В функции malloc запрашиваемое количество памяти (в символах) округляется до
размера, кратного длине заголовка. Выделяемый участок содержит на один такой блок
больше, чем нужно, — для помещения заголовка. Именно эта длина и записывается в
поле size заголовка. Указатель, возвращаемый из malloc, указывает на свободное
пространство, а не на заголовок. Пользователь может делать с полученным участком 
памяти все, что захочет, но если что-либо будет записано за пределами выделенной памяти,
весь список скорее всего будет испорчен.
Для начала работы используется переменная base. Если f reep равен NULL, как это
имеет место при первом вызове malloc, создается вырожденный список свободных
блоков. Он содержит один блок нулевого размера и указывает сам на себя. В любом 
случае затем выполняется поиск по списку. Поиск свободного блока подходящей длины 
начинается в точке (f re ер), в которой был найден последний запрошенный блок; такая
схема позволяет поддерживать единообразие работы со списком. Если найден слишком
длинный блок, пользователю возвращается его "хвост"; благодаря этому в заголовке 
исходного блока остается исправить только размер. Во всех случаях указатель, 
возвращаемый пользователю, указывает на свободное пространство в блоке, которое начинается
через один блок после заголовка.
Функция morecore запрашивает и получает память от операционной системы. 
Детали реализации такого запроса меняются от системы к системе. Запрос памяти у 
системы — это сравнительно трудоемкая операция, и ее не стоит выполнять при каждом 
вызове malloc. Вот почему функция morecore запрашивает сразу как минимум NALLOC
блоков; полученный большой блок потом будет "нарезаться" по мере необходимости.
После установки поля размера morecore добавляет полученную память в общий фонд,
вызывая функцию free.
Системный вызов Unix под названием sbrk(n) возвращает указатель на
п дополнительных байт памяти. Эта функция возвращает -1, если места в памяти 
недостаточно, хотя возвращать NULL в этом случае было бы удачнее. Число -1 следует 
привести к типу char *, чтобы можно было сравнивать его с возвращаемым значением.
Приведение типов делает функцию сравнительно устойчивой к различиям представлений
указателей в разных системах. Правда, здесь сделано предположение о том, что 
указатели на различные блоки, возвращаемые из sbrk, можно сравнивать и получать при этом
правильные ответы. Стандарт этого не гарантирует, поскольку разрешает сравнивать
указатели только в пределах массива. Поэтому данная версия та 11 ос переносима 
только между системами, в которых сравнение произвольных указателей имеет смысл и 
реализовано корректно.
И последней в нашем наборе функций идет free. Она перебирает список свободных
блоков, начиная с freep, в поисках места для вставки освобождаемого блока. Такое 
место может найтись либо между двумя блоками, либо на одном из концов списка. В 
любом случае, если освобождаемый блок примыкает вплотную к одному из соседей, 
соседние блоки объединяются в один. Единственное, о чем следует тщательно 
позаботиться,— это о том, чтобы указатели указывали на правильные места и были заданы
правильные размеры.
Хотя распределение памяти — по самой своей сути всегда системно-зависимая 
операция, приведенный код иллюстрирует, как эту зависимость можно сделать управляемой
и локализовать в очень малой части программы. Выравнивание регулируется с помощью
typedef и объединений (при условии, что sbrk возвращает правильный указатель).
Приведение типов, применяемое к указателям, сделано явным и даже приспособлено к
неудачному системному интерфейсу. Хотя подробности реализации приведенных 
функций относятся к распределению памяти, общий подход можно применять и к решению
других проблем.

одна причина применить f с lose к открытому файлу— в результате очищается и
сбрасывается в файл буфер, в котором функция put с накапливает выходные данные.
Функция f close вызывается автоматически для каждого открытого файла во время
нормального завершения программы. (Можно даже закрыть stdin и stdout, если они
не нужны. Их можно затем переназначить библиотечной функцией f reopen.)

Программа сигнализирует об ошибках двумя способами. Во-первых, диагностика
ошибок посылается функцией fprintf в поток stderr и гарантированно появляется
на экране, а не исчезает где-то в недрах файла или конвейера. В сообщения включается
имя программы из argv [0], чтобы при использовании данной программы параллельно
с другими можно было легко определить источник ошибки.

Аргумент exit становится доступным тому процессу,
который запустил программу на выполнение, так что успешность или ошибочность ее
завершения может проанализировать другая программа — та, которая вызвала ее в 
качестве подчиненного процесса. Принято, что возвращаемое значение 0 сигнализирует о
нормальном завершении; различные ненулевые значения обычно обозначают аварийные
ситуации. Функция exit вызывает fclose для закрытия каждого открытого файла,
очищая тем самым буферы вывода.

Функция f error возвращает ненулевое число, если произошла ошибка в потоке f р:
int ferror(FILE *fp)
Хотя ошибки при выводе очень редки, они все же случаются (например, при 
заполнении всего дискового пространства), поэтому программа профессионального 
коммерческого качества должна проверять и такие случаи.
Функция feof (FILE *) похожа на f error— она возвращает ненулевое число,
если в указанном файле достигнут его конец.
int feof(FILE *fp)
Мы пока не обращаем внимание на то, с какими кодами завершения заканчиваются
наши небольшие иллюстративные программы, но в любой серьезной программе в таких
случаях необходимо возвращать разумные и полезные значения.

В стандартной библиотеке имеется функция ввода fgets, аналогичная функции
get line, разработанной и использованной в предыдущих главах:
char *fgets(char *line, int maxline, FILE *fp)
Что касается вывода, строка записывается в файл функцией fputs (строка не 
обязана содержать символ конца):
int fputs(char *line, FILE *fp)
Функция fputs возвращает EOF в случае ошибки и 0 в противном случае.
Библиотечные функции gets и puts аналогичны fgets и fputs, но работают с
потоками stdin и stdout. Функция gets удаляет завершающий символ ' \п', a puts
добавляет его, что часто вызывает путаницу.

unix
В операционной системе Unix весь ввод-вывод осуществляется путем чтения и записи
файлов, поскольку все периферийные устройства, даже клавиатура и экран монитора, 
являются файлами единой файловой системы. Это означает, что любая передача данных
между программой и периферийными устройствами управляется через единообразный
интерфейс.
Вся информация об открытом файле нахо-дится в ведении операционной системы; прикладная программа обращается к файлу
только по его дескриптору.
Поскольку ввод-вывод с применением клавиатуры и экрана очень распространен, для
удобства его выполнения приняты некоторые дополнительные меры. Когда программа
запускается на выполнение в командном интерпретаторе (системной выполняющей 
среде или оболочке), автоматически открываются три файла с дескрипторами 0, 1 и 2. Они
называются стандартными потоками ввода, вывода и ошибок. Если программа вводит
данные только из файла 0, а выводит в 1 и 2, ей нет нужды беспокоиться об открытии
файлов.
В ходе одного вызова можно записать или прочитать любое количество байт. 
Наиболее распространенные случаи— это один символ за раз ("небуферизованный ввод-
вывод") либо количество наподобие 1024 или 4096, которое соответствует размеру 
физического блока данных на периферийном устройстве. Большими блоками передавать
данные эффективнее, поскольку при этом выполняется меньше системных вызовов.
Здесь функциональные прототипы системных вызовов считаются собранными в файл
syscalls.h, который будет включаться в программы этой главы. Имя этого файла не
является стандартным.

Справочное руководство по языку С
31 октября 1988 года.
Размер объектов, объявляемых как символы (char), позволяет хранить любой 
символ из символьного набора, принятого в системе во время выполнения программы. Если
в объекте типа char хранится действительно символ из данного набора, то его значение
эквивалентно коду этого символа и неотрицательно. Переменные типа char могут 
содержать и другие значения, но тогда диапазон их значений и особенно вопрос о том,
имеют ли эти значения знак, определяется конкретной реализацией языка.

Обычные объекты типа int имеют 
естественный размер, принятый в архитектуре конкретной системы, другие размеры 
предназначены для специальных целей. Более длинные целые типы имеют как минимум не
меньшую длину в памяти, чем более короткие, однако в некоторых реализациях обычные
целые типы могут быть эквивалентны коротким (short) или длинным (long). Все типы
int по умолчанию представляют числа со знаком, если не оговорено обратное.

Целые числа без знака объявляются с помощью ключевого слова unsigned и 
подчиняются правилу автоматического взятия остатка от деления 2П, где п — количество 
битов в представлении числа. Следовательно, в арифметике целых чисел без знака никогда
не бывает переполнения. Множество неотрицательных значений, которые могут 
храниться в объектах со знаком, является подмножеством значений, которые могут 
храниться в соответствующих объектах без знака; представления таких чисел со знаком и без
знака совпадают ( а вот в цпп нет, там чар -128...127 ...)
Любые два из вещественных типов с плавающей точкой— с одинарной (float), с
двойной (double) и с повышенной (long double) точностью— могут быть 
синонимичными (обозначать одно и то же), но каждый следующий тип в этом списке должен
обеспечивать точность по крайней мере не хуже предыдущего.

Объект — это именованная область памяти; именующее выражение {lvalue) — это
выражение, обозначающее объект или ссылающееся на него. Очевидным примером 
именующего выражения является идентификатор с соответствующим типом и классом 
памяти. Существуют операции, которые выдают именующее выражение в качестве 
результата. Например, если Е — выражение типа "указатель", то *Е — именующее выражение
для объекта, на который указывает Е. Термин lvalue образован от leftside value
("левостороннее значение") в контексте записи присваивания Е1 = Е2, в которой левый
операнд Е1 должен быть как раз именующим выражением, чтобы присваивание было
допустимым. При описании тех или иных операций мы сообщаем, требуют ли они 
именующих выражений в качестве операндов и выдают ли они такое выражение в качестве
результата.

Если тип int позволяет представить все 
значения исходного типа операнда, то операнд приводится к int, в противном случае— к
unsigned int. Эта процедура называется расширением целочисленного типа (integral
promotion).
Чтобы привести целое число к некоторому заданному типу без знака, ищется 
конгруэнтное (т.е. имеющее то же двоичное представление) наименьшее неотрицательное 
значение, а затем получается остаток от деления его на UMAX+1, где UMAX — наибольшее
число в данном типе без знака. При использовании двоичного представления в 
дополнительном коде ("дополнения к двойке") для этого либо отбрасываются лишние левые 
разряды, если двоичное представление беззнакового типа уступает в длине исходному типу,
либо недостающие старшие разряды заполняются нулями (в числах без знака) или 
значением знака (в числах со знаком), если тип без знака шире исходного.
В результате приведения целого числа к знаковому типу его значение не меняется,
если оно представимо в этом новом типе; в противном случае результат зависит от 
реализации.

Во многих операциях преобразование типов операндов и определение типа 
результата следуют одной и той же схеме. В результате операнды приводятся к некоторому 
общему типу, который также является и типом результата. Эта схема включает в себя
обычные арифметические преобразования.
■ Во-первых, если какой-либо из операндов имеет тип long double, то и другой
приводится к long double.
■ Иначе, если какой-либо из операндов имеет тип double, то и другой приводится
к double.
■ Иначе, если какой-либо из операндов имеет тип float, то и другой приводится к
float.
■ Иначе, для обоих операндов выполняется расширение целого типа; затем, если
один из операндов имеет тип unsigned long int, то и другой преобразуется в
unsigned long int.
■ Иначе, если один из операндов имеет тип long int, а другой — unsigned int,
то результат зависит от того, представляет ли long int все значения
unsigned int; если это так, то операнд типа unsigned int приводится к long
int; если нет, то оба операнда преобразуются в unsigned long int.
■ Иначе, если один из операндов имеет тип long int, то и другой приводится к
long int.
■ Иначе, если один из операндов— unsigned int, то и другой приводится к
unsigned int.
■ Иначе, оба операнда имеют тип int.
Указатель можно привести к целочисленному типу, достаточно большому для его
хранения; требуемый размер зависит от реализации.
Объект целочисленного типа можно явно преобразовать в указатель. Если целое 
число получено из указателя и имеет достаточно большой размер, такое преобразование
всегда даст тот же указатель; в противном случае результат зависит от реализации.
Указатель на один тип можно преобразовать в указатель на другой тип. Если 
исходный указатель не ссылается на объект, должным образом выровненный по границам слов
памяти, в результате может возникнуть исключительная ситуация, связанная с 
адресацией. Если требования к выравниванию у нового типа менее строгие или такие же, как у
первоначального типа, то гарантируется, что преобразование указателя к другому типу и
обратно не изменит его. Само понятие "выравнивания" зависит от реализации, однако в
любой реализации объекты типа char предъявляют наименее строгие требования к 
выравниванию. Как описано в разделе А.6.8, указатель может также преобразовываться в
void * и обратно без изменения своего значения.
Указатель можно преобразовать в другой указатель того же типа с добавлением или
удалением модификаторов (разделы А.4.4, А.8.2) того типа объектов, на которые он 
указывает.
Наконец, указатель на функцию можно преобразовать в указатель на функцию 
другого типа. Вызов функции по преобразованному указателю зависит от реализации; но если
указатель снова преобразовать к его исходному типу, результат будет идентичен вызову
по первоначальному указателю.
Выражение можно преобразовать в тип void операцией приведения типа. Например,
операция приведения к void применительно к вызову функции, используемому в роли
выражения-оператора, подчеркивает тот факт, что результат функции отбрасывается.

Термин аргумент используется для выражения, передаваемого при вызове функции;
термин параметр — для обозначения получаемого ею объекта (или его идентификатора)
в объявлении или определении функции. В том же смысле иногда используются термины
"фактический аргумент (аргумент)" и "формальный аргумент (параметр)".




Связывание операторов в стандартах Си и C++ определено через грамматику языка, а не через таблицу. Это может создать конфликт
Пример: условная операция. в С она условная и в ++ она ассигнмент

Приоритет	Оператор	Описание	Ассоциативность
1
Наивысший
::	Раскрытие области видимости	Нет

2	++	Суффиксный инкремент	Слева направо
	--	Суффиксный декремент
	()	Вызов функции
	[]	Взятие элемента массива
	.	Выбор элемента по ссылке
	->	Выбор элемента по указателю
	typeid()	RTTI (только C++; см typeid)
	const_cast	Приведение типа (C++) (см const cast)
	dynamic_cast	Приведение типа (C++) (см dynamic cast)
	reinterpret_cast	Каламбур типизации (C++) (см reinterpret_cast)
	static_cast	Приведение типа (C++) (см static cast)
3	++	Префиксный инкремент	Справа налево
	--	Префиксный декремент
	+	Унарный плюс
	-	Унарный минус
	!	Логическое НЕ
	~	Побитовое НЕ
	(type)	Приведение типа
	*	Разыменование указателя
	&	Взятие адреса объекта
	sizeof	Size-of (размер)
	new, new[]	Выделение динамической памяти (C++)
	delete, delete[]	Освобождение динамической памяти (C++)
4	.*	Указатель на член (C++)	Слева направо
	->*	Указатель на член (C++)
5	*	Умножение
	/	Деление
%	Получение остатка от деления
6	+	Сложение
	-	Вычитание
	7	<<	Побитовый сдвиг влево
	>>	Побитовый сдвиг вправо
8
	<	Меньше
	<=	Меньше или равно
	>	Больше
	>=	Больше или равно
9
	==	Равенство
	!=	Неравенство
10	
	&	Побитовое И (and)
11	
	^	Побитовое исключающее ИЛИ (xor)
12	
	|	Побитовое ИЛИ (or)
13	
	&&	Логическое И
14	
	||	Логическое ИЛИ
15	
	?:	Тернарная условная операция	Справа налево
16	
	=	Присваивание
	+=	Сложение, совмещённое с присваиванием
	-=	Вычитание, совмещённое с присваиванием
	*=	Умножение, совмещённое с присваиванием
	/=	Деление, совмещённое с присваиванием
	%=	Вычисление остатка от деления, совмещённое с присваиванием
	<<=	Побитовый сдвиг влево, совмещённый с присваиванием
	>>=	Побитовый сдвиг вправо, совмещённый с присваиванием
	&=	Побитовое «И», совмещённое с присваиванием
	|=	Побитовое «ИЛИ», совмещённое с присваиванием
	^=	Побитовое «исключающее ИЛИ» (xor), совмещённое с присваиванием
17	
	throw	Оператор создания исключения (C++)
18	
	,	Оператор «запятая»	Слева направо

// BAD
int		smt ( )
{
	if ( event )
	{
		return	smt2( );
	}
	else
	{
		return	error;
	}
}

// GOOD
int		smt ( )
{
	if ( event )
	{
		return	smt2( );
	}

	return			error;
}

56.3
Используйте счетчик экземпляров объектов вместо инициализирующих функций
( т.е мы инициализируем в креате функции 
В С++ вы можете для этой цели использовать статический член класса.)

56.2.
лучше статик переменная, статик рекурсивная функция и глобальная функция
( а еще лучше статик локал для рекурсии, она не жрет стек и модифается всеми экземплярами ) для
управления этим, чем глобальная переменная и функция

56.4. Если оператор if завершается оператором return , то не используйте
else .
обычно лучше записать:
if ( условие )
return xxx;
делать_массу_вещей();

57. Помещайте более короткий блок условного оператора if/else первым.
не делайте так:
if ( !некая_ошибка() )
{
// Здесь следуют 30 строк кода
}
else
error( "ААААхххх!!!!" );

58. Старайтесь сдвинуть ошибки с этапа выполнения на этап
компиляции.
Например, вы можете разделить подпрограмму на части для того, чтобы
переместить объявления в начало блока, чтобы вам их было легче найти. Подпрограмма, подобная
следующей:
f()
{
	// код, который не использует переменную i
	int i = init_val;
	// код, который использует переменную i
}
может быть разделена следующим образом:
f()
{
	// код, который не использует переменную i
	g( init_val );
}
g( int init_val )
{
	int i = init_val;
	// код, который использует переменную i
}

59
typedef struct _shape
{
void ( *print )( struct _shape* );
    union shape_data
    {
    // здесь данные для различных фигур.
    };
} shape;

extern void print_circle( shape *p );
extern void print_line ( shape *p );
extern void print_text ( shape *p );

shape a_circle = { print_circle };
void print_shape( shape *p )
{
( p->print )( p );
}

61. В цикле со счетчиком его значение должно по возможности
уменьшаться это быстрее
Используйте

for ( i = max; --i >= 0; )
;
вместо:
for ( i = 0;
;
i < max; ++i )

62
указатели, как правило, более эффективны, устраняя неявную операцию умножения в
выражении a[i], интерпретируемом как:
( a + ( i* sizeof(a[0])))

while ( current <= end )
*current++ = 0;
for ( current = array; current <= end; ++current )
{
// ...f( current - array );
// передать функции f() текущий индекс массива
}

66.
66.1. Рассчитывайте на невозможное.

70. C-style casts 
Приведение типа должно рассматриваться
как операция времени выполнения, которая создает временную переменную типа, определенного для
приведения, затем инициализирует эту временную переменную от операнда. В С++, конечно, эта
инициализация может обернуться очень большими накладными расходами, так как возможен вызов
конструктора.
В следующем
фрагменте не говориться "malloc() на самом деле возвращает указатель, а не тип int":
int *p = (int *) malloc( sizeof(int) );
а скорее код говорит "я полагаю, что malloc() возвращает тип int, так как тут нет предшествующего
прототипа, и преобразую этот int в указатель для присваивания его значения p). Если тип int имеет
размер 16 бит, а указатель 32-битовый, то вы теперь в глубокой луже. Вызов malloc() может вернуть и
32-битовый указатель, но так как компилятор полагает, что malloc() возвращает 16-битовый int, то он
игнорирует остальные 16 бит. Затем компилятор округляет возвращенное значение до 16-бит и
преобразует его в 32-битовый тип int принятым у него способом, обычно заполняя старшие 16 бит
нулями. Если указатель содержал адрес больше, чем 0xffff, что вероятно для большинства
компьютеров, то вы просто теряете старшие биты. Единственным способом урегулирования этой
проблемы является указание для malloc() соответствующего прототипа, который подскажет, что
malloc() возвращает указатель (обычно путем включения файла <stdlib.h>).
1. Компилятор, не видя объявдение маллок, трактует его как возвращающий инт
2. Видя каст он преобразует инт к типу поинтер для присваивания его int* ptr
3. Если инт 16-битный, а птр 32-битный - это аллес
4. Маллок может вернуть и 32битный указатель, но т.к компилятор считает, что маллок ретурнит
	16-битный инт, он игнорирует остальные 16-бит.
5. Округляет возвращенное значение до 16-бит и кастит в 32-битный инт, заполняя старшие биты нулями.
6. Если адресс птр был больше, чем 0хфффф, что вероятно, то старшие биты теряются

Не нужно кастить, чтобы заткнуть компилер, например:
f( int x );
// ...
unsigned y;
f( y );
тут каст к инту может вызвать потерю значения

компилер выравнивает все падла, нет ошибки
short x;
long *lp = (long*)( &x ); // икс может быть не кратным четырем, тогда это аллес
*lp = 0;
Эта ошибка особенно опасна, потому что *lp = 0 не сработает лишь тогда, когда x окажется по
нечетному или не кратному четырем адресу
p = (char *)(long *); это более сэйф вариант

73. Помещайте код, динамически распределяющий и освобождающий
память, в одном и том же месте.
74. Динамическая память - дорогое удовольствие
Я однажды сократил время
выполнения на 50% путем замены многочисленных вызовов malloc() и free() на другую стратегию.
Когда вызываем кастомную фри, там мы добавляем в лист адрес.
Когда вызываем фри алл, то лучше квиксортнуть по базовому адресу, а потом освобождать.
А когда аллокатим, то, если фрилист не нулл, туда закидываем новый объект,
иначе аллокатим через сисвызов. Короче как пул.

А я думал, что как-то одни фри получится......

76. Сообщение об ошибке должно подсказывать пользователю, как ее
исправить.
Сообщение об ошибке должно подсказывать вам, как исправить эту ситуацию, что-нибудь типа:
Числа должны быть в диапазоне от 17 до 63 включительно.
или:
Даты должны иметь формат дд-мм-гггг.
А не просто писать "ты лох"
77. Не выводите сообщения об ошибке, если она исправима.
#include <stdio.h>
#include <sdarg.h>
#ifdef WINDOWS
void error( const char* format, ... )
{
	char buf[255]; // надеемся, что такой размер будет достаточен
	va_list args;
	va_start( args, format );
	if ( vsprintf( buf, format, args ) < sizeof(buf) )
	::MessageBox(NULL, buf, "*** ОШИБКА ***", MB_OK | MB_ICONEXCLAMATION );
	else
	{
		::MessageBox(NULL, "Переполнение буфера при печати сообщения об ошибке.",
		"Фатальная ошибка",
		MB_OK | MB_ICONEXCLAMATION );
		ExitProcess( -1 );
	}
	va_end( args );
}

#elif MOTIF
// Здесь следует функция обработки ошибки, используемая в ОС Motif
#else
void error( const char* format, ... )
{
	va_list args;
	va_start( args, format );
	vfprintf(stderr, format, args );
	va_end ( args );
}
#endif

Вообще, множество переходов goto к одной точке выхода лучше, чем много операторов return
Если вы пропускаете объявление, то вы пропускаете и вызов конструктора, а деструктор вызовется.
Поэтому лучше избегать такой шняги в цпп, но попробовать надо.

int	f ( )
{
	/*
	* Bad thing: if horrible then constructor 
	* for result won't be called, but destrcutor will
	*/
	if ( horrible )
	{
		goto		exit;
	}

	CLASS result	= error;

	if ( something )
	{
		result 		= smt1;
		goto 		exit;
	}
	else
	{
		result 		= panic;
		goto exit;
	}

	exit:
	return			result;
}

m for members
c for constants/readonlys
p for pointer (and pp for pointer to pointer)
v for volatile
s for static
i for indexes and iterators
e for events

Consider using boost::ptr_vector which requires less overhead. 


%. 2 f — вывести аргумент как вещественное число с двумя цифрами после десятичной точки.
%. 0 f подавляет вывод десятичной точки и дробной части, которая равна null

empty operator - ;





References bulshit and POINTERS YEEEEY

template<typename T, size_t N> constexpr size_t len(T (&)[N]) noexcept {
    return N;
}

Если вы напишите int x[2] или int x[] в заголовке функции, то это будет эквивалентно int *x и в функцию всегда будет передаваться указатель (sizeof от переданной переменной будет таким, как у указателя).

struct TS {
    int a;
    int b;
    int c[0];
};

struct TS *d = (struct TS *)malloc (sizeof (struct TS));
d->c[0] = 0;

В этом случае вы обращаетесь к нулевому элементу, которого нет, т. к. элементов ноль. И вы можете схватить сегфолт.


Но бывает, что после структуры в памяти лежат некие инты, и нам как раз нужно уметь к ним обращаться (как в вашем примере). Вот тогда такой хак с полем в виде массива длины ноль действительно используют.

void f (int (&x)[5])
{
  // sizeof (x) здесь равен 5 * sizeof (int)
}

int main (void)
{
  int x[5];
  f (x); // OK
  f (x + 0); // Нельзя
  int y[7];
  f (y); // Нельзя, не тот размер
}

#include <iostream>
#include <string>

std::string f() {
    return "test";
}

int main() {
	// standard guarantees that object will be avialable at the moment of use
	// it extends the lifetime of temporary object returned by f( )
    const std::string& ttt = f();
    std::cout << ttt << std::endl;
    // object returned by f is deleted here
}

rvalue reference может быть привязана у rvalue object or subobject thereof

Но эта странность имеет практическую пользу. Зная о ней, можно писать
const std::string& aaa = ...
и не задумываться о том, возвращают ли нам ссылку или временную переменную. Это позволяет писать код, который не придётся менять, если используемые в нём геттеры станут возвращать не ссылки, а временные переменные.

Действительно, стандарт позволяет при адресной арифметике выходить за пределы массива только на 1 элемент (но не разыменовывать!). Далее одного элемента — UB.

Но вообще это все на самом деле очень мутная тема. Например, непонятно даже, валиден ли указатель, если он указывает на что-то валидное внутри массива, но был получен арифметикой из другого массива, даже если стандарт гарантирует непрерывное размещение в памяти. Например, если есть:
int a[2][3];

И мы взяли указатель на &a[0][2], а потом сдвинули его на два элемента вперед. По логике вещей, мы должны попасть в &a[1][1], и стандарт гарантирует именно такое размещение в пемяти. Но ведь исходный указатель был взят от массива a[0], и в стандарте есть этот параграф, который явно запрещает сдвигать его за пределы (плюс один элемент в конце), т.е. вроде как это UB. На эту тему в comp.std.c++ был длинный тред несколько лет назад, но в итоге консенсуса не было.

массивы в стеке и на куче работают по разному.
«Массив массивов» и «указатель на указатель» — это разные сущности. 
Динамические массивы динамических массивов — вот чего нужно избегать, потому что они медленные.
( x + 2 )[ 3 ] == x[ 5 ] == *( ( x + 2 ) + 3 )



Выражение наподобие х = 0, i++ или printf (...) становится оператором, если после него поставить точку с запятой

Почему оператор = не void ?
для того чтоб можно было делать так: a = b = c = d = e;

действия при выходе из скоупа
https://gamedev.ru/code/forum/?id=124629&page=2



iterator
You don't force an iterator to be single-pass, it is usually a side effect, e.g. from reading input once and discarding previous values.
 Input iterators do not force single pass. THey just do not work as expected if you will try to make a second pass: stream iterators will just read next entry from a stream instead of returning earlier value, move iterators might invoke undefined behavior on second pass, etc


ref quailifeied member functions
#include <iostream>
struct S {
    void f() & { std::cout << "lvalue\n"; }
    void f() &&{ std::cout << "rvalue\n"; }
};

int main(){
    S s;
    s.f();            // prints "lvalue"
    std::move(s).f(); // prints "rvalue"
    S().f();          // prints "rvalue"
}
So during overload resolution the compiler looks for the function &-qualified if the caller object is an lvalue or for the function &&-qualified if the caller object is an rvalue.

std::mutex
https://habr.com/post/328362/
http://rsdn.org/forum/cpp/5958518.hot

shared_ptr
Foo *foo = new Foo; 
Foo::ptr p1 = foo; 
Foo::ptr p2 = foo; // ошибка! p1 и p2 не знают о существовании друг друга! Объект будет удаляться дважды! 
надо так: 
Foo::ptr p2 = p1; // и только так

У тебя это совершается в bar.add(Foo::ptr(this));
Надо построить код так чтобы с момента первой записи указателя на объект в Foo::ptr никто и никогда больше не обращался к объекту через указатель. Только через smart_ptr-ы и в smart_ptr-ы же.

shared_weak
http://www.gamedev.ru/code/forum/?id=17974

intrusive указатель. Как понял, делает работу по подсчету ссылок на объект автоматически. Т.е. объект хранит у себя счетчик, а intrusive только им манипулирует и при обнулении удаляет. Это уже интереснее чем shared_ptr, с его ограничением единственности для одного объекта.


Dangling pointer
https://en.wikipedia.org/wiki/Dangling_pointer

https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful

https://stackoverflow.com/questions/41142315/why-is-stdshared-ptrunique-deprecated
A good example would be a cache.
For recently accessed objects, you want to keep them in memory, so you hold a strong pointer to them. Periodically, you scan the cache and decide which objects have not been accessed recently. You don't need to keep those in memory, so you get rid of the strong pointer.
But what if that object is in use and some other code holds a strong pointer to it? If the cache gets rid of its only pointer to the object, it can never find it again. So the cache keeps a weak pointer to objects that it needs to find if they happen to stay in memory.
This is exactly what a weak pointer does -- it allows you to locate an object if it's still around, but doesn't keep it around if nothing else needs it.
/*
#include <iostream>
#include <memory>

int main()
{
    // OLD, problem with dangling pointer
    // PROBLEM: ref will point to undefined data!

    int* ptr = new int(10);
    int* ref = ptr;
    delete ptr;

    // NEW
    // SOLUTION: check expired() or lock() to determine if pointer is valid

    // empty definition
    std::shared_ptr<int> sptr;

    // takes ownership of pointer
    sptr.reset(new int);
    *sptr = 10;

    // get pointer to data without taking ownership
    std::weak_ptr<int> weak1 = sptr;

    // deletes managed object, acquires new pointer
    sptr.reset(new int);
    *sptr = 5;

    // get pointer to new data without taking ownership
    std::weak_ptr<int> weak2 = sptr;

    // weak1 is expired!
    if(auto tmp = weak1.lock())
        std::cout << *tmp << '\n';
    else
        std::cout << "weak1 is expired\n";

    // weak2 points to new data (5)
    if(auto tmp = weak2.lock())
        std::cout << *tmp << '\n';
    else
        std::cout << "weak2 is expired\n";
}
*/

MMX
http://www.gamedev.ru/articles/?id=70007


https://gamedev.ru/flame/forum/?id=206836 enum tricks

c# flame
https://gamedev.ru/flame/forum/?id=228017





http://www.gamedev.ru/flame/forum/?id=236368
Есть несколько разных понятий, связанных с областью параллельных вычислений.

Конкурентное исполнение (concurrency)
Параллельное исполнение (parallel execution)
Многопоточное исполнение (multithreading)
Асинхронное исполнение (asynchrony)
Каждый из этих терминов строго определен и имеет четкое значение.

Конкурентность (concurrency)
Конкурентность (*) (concurrency) - это наиболее общий термин, который говорит, что одновременно выполняется более одной задачи. Например, вы можете одновременно смотреть телевизор и комментить фоточки в фейсбуке. Винда, даже 95-я могла (**) одновременно играть музыку и показывать фотки.
(*) К сожалению, вменяемого русскоязычного термина я не знаю. Википедия говорит, что concurrent computing - это параллельные вычисления, но как тогда будет parallel computing по русски?
(**) Да, вспоминается анекдот про Билла Гейтса и многозадачность винды, но, теоретически винда могла делать несколько дел одновременно. Хотя и не любых.
Конкурентное исполнение - это самый общий термин, который не говорит о том, каким образом эта конкурентность будет получена: путем приостановки некоторых вычислительных элементов и их переключение на другую задачу, путем действительно одновременного исполнения, путем делегации работы другим устройствам или еще как-то. Это не важно.
Конкурентное исполнение говорит о том, что за определенный промежуток времени будет решена более, чем одна задача. Точка.
Параллельное исполнение
Параллельное исполнение (parallel computing) подразумевает наличие более одного вычислительного устройства (например, процессора), которые будут одновременно выполнять несколько задач.
Параллельное исполнение - это строгое подмножество конкурентного исполнения. Это значит, что на компьютере с одним процессором параллельное программирование - невозможно;)
Многопоточность
Многопоточность - это один из способов реализации конкурентного исполнения путем выделения абстракции "рабочего потока" (worker thread).
Потоки "абстрагируют" от пользователя низкоуровневые детали и позволяют выполнять более чем одну работу "параллельно". Операционная система, среда исполнения или библиотека прячет подробности того, будет многопоточное исполнение конкурентным (когда потоков больше чем физических процессоров), или параллельным (когда число потоков меньше или равно числу процессоров и несколько задач физически выполняются одновременно).
Асинхронное исполнение
Асинхронность (asynchrony) подразумевает, что операция может быть выполнена кем-то на стороне: удаленным веб-узлом, сервером или другим устройством за пределами текущего вычислительного устройства.

Основное свойство таких операций в том, что начало такой операции требует значительно меньшего времени, чем основная работа. Что позволяет выполнять множество асинхронных операций одновременно даже на устройстве с небольшим числом вычислительных устройств.
CPU-bound и IO-Bound операции
Еще один важный момент, с точки зрения разработчика - разница между CPU-bound и IO-bound операциями. CPU-Bound операции нагружают вычислительные мощности текущего устройства, а IO-Bound позволяют выполнить задачу вне текущей железки.
Разница важна тем, что число одновременных операций зависит от того, к какой категории они относятся. Вполне нормально запустить параллельно сотни IO-Bound операций, и надеяться, что хватит ресурсов обработать все результаты. Запускать же параллельно слишком большое число CPU-bound операций (больше, чем число вычислительных устройств) бессмысленно.
Возвращаясь к исходному вопросу: нет смысла выполнять в 1000 потоков метод Calc, если он является CPU-Intensive (нагружает центральный процессор), поскольку это приведет к падению общей эффективности вычислений. ОС-ке придется переключать несколько доступных ядер для обслуживания сотен потоков. А этот процесс не является дешевым.
Самым простым и эффективным способом решения CPU-Intensive задачи, заключается в использовании идиомы Fork-Join: задачу (например, входные данные) нужно разбить на определенное число подзадач, которые можно выполнить параллельно. Каждая подзадача должна быть независимой и не обращаться к разделяемым переменным/памяти. Затем, нужно собрать промежуточные результаты и объединить их.
Именно на этом принципе основан PLINQ. О чем можно почитать тут: Джозеф Албахари. Параллельное программирование.
Выглядит это очень интересно:
IEnumerable<Data> yourData = GetYourData();
var result = yourData.AsParallel() // начинаем обрабатывать параллельно
  .Select(d => ComputeMD5(d)) // Вычисляем параллельно
  .Where(md5 => IsValid(md5))
  .ToArray(); // Возврвщаемся к синхронной модели
В этом случае, число потоков будет контролироваться библиотечным кодом в недрах CLR/TPL и метод ComputeMD5 будет вызван параллельно N-раз на компьютере с N-процессорами (ядрами).








юникод
Важно ещё следующее: один символ Юникода — не значит визуально один элемент.

Во-первых, есть combining character'ы. Это символы, которые визуально меняют предшествующие символы (например, добавляют какую-то диактрику). Т.е. строка Юникода состоит из т.н. base character'ов («обычные» символы, например «е») и т.н. combining character sequence'ов, каждый из последних (в норме, иначе это invalid combining character sequence) состоит из base character'а и одного-или-более combining character'а (например, «е»+« ̈»+« ̸»=«ё̸»). Не путать это с суррогатными парами (суррогатная пара — это представление ОДНОГО символа несколькими двухбайтными словами в UTF-16).

Во-вторых, даже base character'ы (которые формально не относятся к combining character'ам) могут лепиться несколько штук в один визуальный элемент. Сюда относятся, например, корейские согласные/гласные/завершающие. Например, «ᄒ»+«ᅡ»+«ᇶ»=«하ᇶ» (но «ᄒя» или «яᅡ» или «ᅡᄒ» не слепляются). Это Hangul (корейский алфавит), возможно, существуют и другие письменности, которые лепят символы в один визуальный элемент.

Для визуального элемента существует отдельный термин (grapheme, что ли?).

P.S.: Рекомендую сервис http://qaz.wtf/u/show.cgi, чтобы увидеть из чего состоит строка. Например, вставляете «ё̸», а оно выдаёт.
UTF-16 (англ. Unicode Transformation Format) в информатике — один из способов кодирования символов из Юникода в виде последовательности 16-битных слов. Данная кодировка позволяет записывать символы Юникода в диапазонах U+0000..U+D7FF и U+E000..U+10FFFF (общим количеством 1 112 064). При этом каждый символ записывается одним или двумя словами (суррогатная пара).



holywar
https://www.linux.org.ru/forum/development/11513142/page1#comments

https://eax.me/kolkhoz-doctrine/
https://eax.me/vcs-practice/
https://eax.me/avoid-metaprogramming/

setjmp-longjmp
https://ru.stackoverflow.com/questions/592529/%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-setjmp-longjmp
Один из методов обработки исключений — SJLJ — означает «setjmp/longjmp».

сопрограммы, многопоточность или чотооеще
https://ru.stackoverflow.com/questions/496002/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BA%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B-coroutine-%D1%87%D1%82%D0%BE-%D1%8D%D1%82%D0%BE



Компьютерная программа в целом или её отдельная процедура называется реентера́бельной (от англ. reentrant — повторно входимый), если она разработана таким образом, что одна и та же копия инструкций программы в памяти может быть совместно использована несколькими пользователями или процессами. При этом второй пользователь может вызвать реентерабельный код до того, как с ним завершит работу первый пользователь и это как минимум не должно привести к ошибке, а при корректной реализации не должно вызвать потери вычислений (то есть не должно появиться необходимости выполнять уже выполненные фрагменты кода).
А́рность предиката, операции или функции в математике — количество их аргументов или операндов. Слово образовалось из названий предикатов небольшой арности (унарный — один аргумент, бинарный — два, тернарный — три). Также для этих целей употребляется термин валентность. В общем случае предикат с {\displaystyle n} n аргументами называют {\displaystyle n} n-арным. Также употребляются термины местность ( {\displaystyle n} n-местный) и, соответственно, вместимость.

Нульарный означает 0-арный.
Унарный означает 1-арный.
Бинарный означает 2-арный.
Тернарный означает 3-арный.
Кватернарный означает 4-арный.
Полиадический, мультарный или мультиарный означает любое количество операндов (или параметров).
n-арный означает n операндов (или параметров), но часто используется и как синоним слова «полиадический».

Плоская модель памяти — метод организации адресного пространства оперативной памяти вычислительных устройств. В плоской модели код и данные используют одно и то же адресное пространство. Для 16-битных процессоров плоская модель памяти позволяет адресовать 64 кБ оперативной памяти; для 32-битных процессоров 4 ГБ, для 64-битных — до 16 эксабайт (для amd64 размер ограничен 256 ТБ [1] ).

Управление памятью все ещё (на 2011 год) реализуется на основе плоской модели, в целях содействия функциональности операционной системы, защиты ресурсов, многозадачности или увеличения объёма памяти за пределы ограничений, налагаемых физическим адресным пространством процессора.

Legacy cod - Устаревший код, который более не поддерживается и не обновляется, но используется. Второе значение — код от сторонних разработчиков, или из старых версий

аппаратная поддержка DirectX
Ну например Радеон 9600 поддерживает DX9 а радеон 9200 поддерживает только DX8.1, перекладывая обработку DX9 на плечи процессора. 
Вот что-то вроде этого и есть "аппаратная поддержка DirectX" со стороны видеокарты. 
в директх железки под софт пилятся, а лучше вообще-то наоборот
Потому что, в отличие от всех остальных систем, виндовся не в состоянии обеспечить полную функциональность железок при помощи одних только обычных драйверов.
Лучше не директинпут а асинхронный ввод

Драйвер занимается реализацией некоторого программного интерфейса средствами имеющейся аппаратуры. В виндах программный интерфейс - DirectX, в Linux - OpenGL.
Чем мощнее аппаратура, тем больше работы можно на неё переложить с ЦП. Но проблема, как я уже говорил, в том, что производители сами драйверов не пишут и спецификаций не дают, так что, сторонние разработчики тоже не могут задействовать все возможности аппаратуры. Это правде не ко всем в полном объёме относится.
аппаратные возможности карточки реализуются посредством вызовов DX. если в DX есть вызов, а карточка аппаратно не может его выполнить, то естественно это будет делать процессор, либо не будет делать никто (тогда в игре будет отсутствовать какой-нибудь эффект)

Игры на приставки
тут вообще история другая, на приставке железо фиксировано и игра затачивается конкретно под него, работающий процесс один - сама игра, то есть максимум что нужно это только лоадер, загружающий игры, а ОСь нахер
есть API и ситуация такова, что игры/программы пишут именно под API, а не под дрова, а что какая-то специфическая фича железяки реализуется каким-то специфическим расширением дров это никого ни#б#т. и вот приходится производителям выкручиваться.
Афаик, сабж является костылём для винды, то есть более непосредственным, прямым способом предоставления доступа пользовательским приложениям к ресурсам железа, а не через жопу, то есть HAL (hardware abstraction layer - по-нашему "кал"), как обычно принято в виндах.

В линуксе, как справедливо было замечено, доступ аппликух к ресурсам железа производится посредством драйверов, без всякого кала.

opengl32.dll всего лишь обёртка, по сути она ничего не делает. настоящий OpenGL драйвер находится в дровах от производителя карточки, у Nvidia например это nvoglnt.dll

Бенчмарк (программирование) — эталонный тест производительности компьютерной системы. 

многопотоки
В принципе, поток — Процесс не выполняется на процессоре (он служит контейнером потоков). Процесс — группирует ресурсы (адресное пространство, потоки, ресурсы). Поток — исполняется на процессоре. Каждый процесс состоит хотя бы из одного потока. Процессы изолированы друг от друга, а потоки (находящиеся внутри одного процесса) могут использовать одно и тоже АП., выполнение которого контролирует планировщик (scheduler) ОС, и который может быть заблокирован. Потоки создаются внутри процесса и пользуются общими ресурсами. Это означает, что, например, память и декскрипторы файлов, являются общими для всех потоков процесса. Подобный подход и принято называть native threads.
кто использовал pthreads и потоки win32, тот знает, что разница в их работе разительна…

Green threads — Поскольку работает только один native thread, то в каждый момент времени может выполняться только один поток из виртуальных потоков. Переключение между потоками производится в момент, когда поток выполняет блокирующую операцию (синхронизация, I/O, sleep(), wait(), etc...). Более того, некоторые JVM искусственно вставляют в код потока операции переключения. В модели m: n после блокирующей операции виртуальный поток может быть продолжен другим m из имеющихся native потоков, поэтому выполнение всех потоков в этой модели происходит более-менее равномерно.
Даже если у вас несколько процессоров и несколько green threads, только один процессор может вызывать green thread. И всё потому, что с точки зрения планировщика заданий ОС всё это выглядит одним потоком.

Python включает в себя модуль, позволяющий манипулировать native threads, поэтому он может пользоваться всеми благами настоящей многопоточности. Но есть и одна проблема.

Python использует глобальную блокировку интерпретатора (Global Interpreter Lock, GIL). Эта блокировка необходима для того, чтобы потоки не могли испортить глобальное состояние интерпретатора. Поэтому две инструкции Python не могут выполняться одновременно.
Расширения С также освобождают её когда не взаимодействуют с Python/C API, поэтому интенсивные вычисления можно перенести в C и избежать блокировки выполняющихся потоков Python

Perl сделал глобальное состояние локальным и фактически запускает новый интерпретатор для каждого нового потока. Это позволяет использовать настоящие native threads. Не обошлось и без пары загвоздок.
Во-первых, вы должны явно указывать переменные доступными для других потоков. Вот что происходит, когда всё становится локальным для потока. Приходится синхронизировать значения для межпоточного взаимодействия.
Во-вторых, создание нового потока стало очень дорогой операцией. Интерпретатор — большая штука и многократное копирование его съедает много ресурсов.

Erlang, использует архитектуру «ничего-общего» (shared nothing), которая стимулирует использование лёгких пользовательских процессов вместо потоков. Подобная архитектура просто великолепна для параллельного программирования, так как она устраняет всю головную боль насчёт синхронизации, а процессы настолько легки, что вы можете создать любое их количество.
Модель работы с потоками в JavaScript очень похожа на ту, что используется в Perl.
C# использует native threads.
// http://bsvi.ru/test/
// in GCC, it's better to write
// #define offsetof(st, m) __builtin_offsetof(st, m)

#undef offsetof
//  This is the same as doing this:
//  typedef struct { char a; char b;} someStruct;
//  someStruct str;
//  offset = (size_t) &(str.b) - (size_t) &str;
#define offsetof( s, m ) ( size_t ) & ( ( ( s* ) 0 )->m )
// we cast nullptr to struct type, so this struct has address 0x00000000,
// then we take offset of member m which is m - s
// take it's address and cast it to int
// we in fact work with abstract struct. this is undefined behaviour though

struct some
{
    short   b;
    char    a;
    char    c;
}; // struct some


А если для душевного спокойствия нужно, чтобы клиент имел в своём коде точно такое же извращение, как и на сервере, то можно поступить так:

C
/* Предположим, в этот буфер уже записаны данные из сети */
char buf[sizeof(double];
 
/* Сюда мы хотим записать наше число */
double d;
 
char *p = (char*) &d;
for (i = 0; i < sizeof(double); i++)
  p[i] = buf[i];
Либо копировать в обратном порядке (p[i] = buff[sizeof(double) - 1 - i]), всё зависит от того, в каком порядке байты передаются по сети


#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned int ihl:4;
    unsigned int version:4;
#elif __BYTE_ORDER == __BIG_ENDIAN
    unsigned int version:4;
    unsigned int ihl:4;
#else
# error "Please fix <bits/endian.h>"

little-endian
https://habr.com/post/121811/


можно делать псевдонимы типов так
typedef unsigned __int8 s8;
typedef signed __int8 s8;
так может круто больше, чем тайпедфить тайпдевы uint32_t и тд

// msvc херня, код замедляет, лучше не использовать никогда
// а просто выровнять поля руками
#pragma pack(push, 1)
struct Foo
{
    // ...
};
#pragma pack(pop)

выравнивать надо, чтобы напрямую читать из сети или файла бинарные блобы в структуры вместо того, чтобы написать нормальный парсинг.
битовые поля — это thread unsafe штука

выравнивание структур:
struct foo2 {
    char c; /* 1 байт */
    char pad[7]; /* 7 байт */
    char *p; /* 8 байт */
    long x; /* 8 байт */
};
Если бы мы рассматривали отдельные переменные, c мог бы начинаться с произвольного байта и размер заполнения мог бы варьироваться. Но выравнивание структуры foo2 идет по указателю, c также должен быть выровнен по указателю. В итоге мы получаем фиксированое заполнение в 7 байт.
структуры выравниваются так по самому большому члену, т.е, то, что не кратно,
заполняем мусором, чтобы было кратно.
также выравниваем конец структуры по кратности ее размера, для массивов
структур

Ограничения битового поля на выход за пределы машинного слова приведет к тому, что на 32-битной машине первые две структуры поместятся в одно или два слова, но третья (foo8) займет три слова, причем у последнего будет занят только первый бит.
struct foo6 {
    int bigfield:31; /* Начало первого 32-битного слова */
    int licodelefield:1;
};

struct foo7 {
    int bigfield1:31; /* Начало первого 32-битного слова */
    int licodelefield1:1;
    int bigfield2:31; /* Начало второго 32-битного слова */
    int licodelefield2:1;
};

struct foo8 {
    int bigfield1:31; /* Начало первого 32-битного слова */
    int bigfield2:31; /* Начало второго 32-битного слова */
    int licodelefield1:1;
    int licodelefield2:1; /* Начало третьего 32-битного слова */
};

pahole - прога для замерения структур

Скаляр - Это физическая величина, которая имеет только одну характеристику – численное значение. Скалярная величина может быть положительной или отрицательной


ASCIIZ - null-terminated string

порядок байтов
https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2#.D0.9A.D0.BE.D0.BD.D0.B2.D0.B5.D1.80.D1.82.D0.B0.D1.86.D0.B8.D1.8F

n
E a(k) - сумма a(k), где k принимает значения от 1 до n
k=1

4
E k^2	= 1^2 + 2^2 + 3^2 + 4^2	=	30;
k=1

http://www.codinglabs.net/article_world_view_projection_matrix.aspx


Атомарная (атом от греч. atomos — неделимое) операция — операция, которая либо выполняется целиком, либо не выполняется вовсе; операция, которая не может быть частично выполнена и частично не выполнена.
В данной статье описываются простейшие атомарные операции (инкремент, чтение, запись и т. п.), хотя термин может относиться к более высокоуровневым операциям, таким как, например, серия запросов к СУБД в рамках одной транзакции.




Позиционная систе́ма счисле́ния — система счисления, в которой значение каждого числового знака (цифры) в записи числа зависит от его позиции (разряда).

Порядок от старшего к младшему (англ. big-endian — большим концом):
Этот порядок соответствует привычному порядку записи арабских цифр, например, число сто двадцать три было бы записано при таком порядке как 123.
Этот порядок является стандартным для протоколов TCP/IP, он используется в заголовках пакетов данных и во многих протоколах более высокого уровня, разработанных для использования поверх TCP/IP. Поэтому порядок байтов от старшего к младшему часто называют «сетевым порядком байтов» (англ. network byte order). 

Порядок от младшего к старшему (англ. little-endian — малым концом):
Это обратный порядок по отношению к привычному порядку записи арабских цифр, например, число сто двадцать три было бы записано при таком порядке как 321.
При таком порядке байтов очень удобно то обстоятельство, что при увеличении размера («байтовости») операнда его значение не изменится.

Смешанный порядок байтов (англ. middle-endian) иногда используется при работе с числами, длина которых превышает машинное слово.

1101111100111111

БИТОВЫЕ ХАКИ
http://graphics.stanford.edu/~seander/bithacks.html

to get nice stack trace compile like this $ gcc -g -rdynamic ./test.c -o test

метод дихотомии
https://prog-cpp.ru/digital-find/

я так экономил память: «Hello\0Привет», сдвигая строку перед печатью в зависимости от выбранного языка.



чтобы не делать strcpy and strlen ( cuz they slow )
А как основной подход к решению — выделять чуть больше и использовать функции,
принимающие саму строку и максимальный размер (как snprintf). Ну и в случае,
если не получилось — делать realloc.

А, и структура ещё может выглядеть как
typedef struct { size_t len; char data[]; } String;
(память выделяется так: xmalloc(offsetof(String, data) + len)).
В зависимости от ситуации, так может быть оптимальнее или наоборот.

как выделить память на куче для строки, созданной форматированием
// snprintf возвращает необходимый размер под строку
// мы передаем ноль, как колво символов нужных записать
// мы можем писать в нулевой указатель безопасно
// есть GNU extension asprintf ( char** ptr, char* const format ),
// которая сама выделяет память. но это же оч долго!





a portable snprintf implementation cuz it sucks on windows, but works well on unix 
код надо писать так, как будто его будет читать неуравновешенный психопат, который знает где ты живешь.
// тут строка форматится дважды
size_t needed_mem = snprintf(NULL, 0, "Hello, %s!\n", "Habr") + sizeof('\0'); 
char *str = malloc(needed_mem);
snprintf(str, needed_mem, "Hello, %s!\n", "Habr");
printf("->\t%s", str);
free(str);


1. не надо вызывать конструктор из другого конструктора явно!
CSlideBarGroup::CSlideBarGroup(CSlideBarGroup& Group)
{
  this->CSlideBarGroup::CSlideBarGroup(
    Group.GetName(), Group.GetIconIndex(), Group.GetListBox());
}

CSlideBarGroup::CSlideBarGroup(CSlideBarGroup& Group)
{
  new (this) CSlideBarGroup(
    Group.GetName(), Group.GetIconIndex(),
    Group.GetListBox());
}

если в классе только под-типы, то все вроде как норм. но если есть наследование, то в таком
случае при создании потомка, базовый класс уже создан и произойдет перезапись, а следовательно
утечка памяти.

С С++11 есть делегация
class MyClass {
  std::string m_s;
public:
    MyClass(std::string s) : m_s(s) {}
    MyClass() : MyClass("default") {}
};

бул retIsOkPass = 
    universalPassword != NULL &&
    strcmp(password.c_str(), universalPassword) == 0;


2. пиши printf("%s", name); а не printf(name);, а то взломают хд
т.к можно просматривать стек через строку форматирования, и модифицировать память с помощью
флага %n

матчасть:
Умножение 16-битного регистра на ячейку памяти с использованием инструкции MUL на процессоре 8086 требует порядка 124-139 тактов!
Сдвиг 16-битного регистра на N позиций с использованием инструкции SHL на процессоре 8086 требует 8+4*N тактов. То есть в худшем случае получается 72 такта.

НЕЛЬЗЯ СДВИГАТЬ НА ОТРИЦАТЕЛЬНОЕ ЧИСЛО И НА ЧИСЛО, КОЛ-ВО БИТОВ КОТОРОГО БОЛЬШЕ, ЧЕМ У ЛЕВОГО ОПЕРАНДА
// так можно
char A = 1;
int B = A << 20;
Слева от оператора << находится переменная A, состоящая только из 8 бит. Но перед началом операции сдвига, левая часть будет расширена до типа int. Соответственно, значение типа 'int' можно сдвинуть на 20 бит.

int A = (-1) << 5; // undefined behavior
int B = (-1) >> 5; // unspecified behavior

лучше делать ((~0u)<<1) | 1, чем (-1)<<1) + 1. т.к знаковые значения это плохо
(-1) << N" теперь объявлены некорректными

http://www.steps3d.narod.ru

http://bbs.vbstreets.ru/viewtopic.php?f=54&t=49301]
https://stackoverflow.com/questions/27615444/how-to-capture-output-of-strace-in-c-program


https://stackoverflow.com/questions/34501602/fast-capture-stack-trace-on-windows-64-bit-mixed-mode
https://forum.sources.ru/next/index.php?s=65cf13b3ddb91e7498f8b2b3538ac577&showtopic=384422&st=0
https://stackoverflow.com/questions/3899870/print-call-stack-in-c-or-c
http://rsdn.org/forum/src/1374157.flat

http://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197

template <typename...>
struct WhichType;

typedef void fcn_t(void);
typedef void (*ptr_t)(void);

// constexpr auto one = WhichType<fcn_t>{};
// constexpr auto two = WhichType<fcn_t*>{};
// constexpr auto three = WhichType<ptr_t>{};

fcn_t f;

void f() {}

int main() {
    f();
}
Uncommenting the commented lines will likely give you a compiler error that tells you what types the WhichType instance is being instantiated with, and as a result it should show you the exact types of all three things you asked about. It's a trick I picked up from Scott Meyers' book "Effective Modern C++".

binaries нужно хранить в папке где engine
хранить компиляторы на флешке
он либы подцепляет из PATH, повозиться



фс архитектура:
enum file type: regular, dir etc
path - represents path and ONLY path, c_string method for example
operator/ concatenates paths
directory_entry - stores path and additional info: size
has members is_directory is_regular
directory_iterator iterates over directory_entry elements of directory,
but not subdirs, the order unspecifide, dot and dot-dot are skipped.
when comes to and end( ) it becomes default directory_iterator

У НАС БУДУТ МЕТОДЫ ТИПА READ_FILE, ЧТОБЫ МОЖНО БЫЛО ЧИТАТЬ ИНФУ О ФАЙЛЕ
ДЛЯ DIRECTORY_ENTRY И ИСПОЛЬЗОВАТЬ ЭТО ЖЕ В ИТЕРАТОРЕ
....... ВЕЛОСИПЕДЫ, ВЕЛОСИПЕДЫ
а в стд там у них через внешние функции, может так реально легче, не надо хранить
данные файла в директори_ентри. начинается это тока с директори_итератора, там уже
через пимпл или както еще

namespace detail
    {
      class dir_itr_imp;
      // shared_ptr provides shallow-copy semantics required for InputIterators
      typedef boost::shared_ptr< dir_itr_imp > dir_itr_imp_ptr;
      BOOST_FILESYSTEM_DECL void dir_itr_init( dir_itr_imp_ptr & m_imp,
                                               const path & dir_path );
      BOOST_FILESYSTEM_DECL path & dir_itr_dereference(
                                               const dir_itr_imp_ptr & m_imp );
      BOOST_FILESYSTEM_DECL void dir_itr_increment( dir_itr_imp_ptr & m_imp );
    } // namespace detail
	
	и directory_iterator имеет этот член
	
	private:
      detail::dir_itr_imp_ptr  m_imp;

A recursive_directory_iterator typically holds a reference-counted pointer (to satisfy shallow-copy semantics of InputIterator) to an implementation object, which holds:

a container (such as std::vector) of non-recursive directory_iterators that forms the recursion stack
the recursion depth counter (accessible with depth())
the directory options used at construction (accessible with options())
the pending recursion flag (accessible with recursion_pending(), may be combined with the directory options to save space)

я думаю, надо делать переписать все хД, рекурсивный итератор норм,
но нужно сделать кроссплатформ функции типа FindFirstFile
обернуть это в хз че, директори_итератор обычный штоль

 и & - 1 если хоть одно 1
исключающее или ^ - если оба бита равны дает - 0, иначе - 1
включающее или 	- если оба бита 0 - 0, иначе - 1
побитовая инверсия - ~
сдвиги влево вправо << >>

for cb
cmd /k post_build.bat

opaque data type is a data type whose concrete data structure is not defined in an interface.

memset + malloc or calloc
https://stackoverflow.com/questions/2688466/why-mallocmemset-is-slower-than-calloc
USE calloc instead of malloc + memset( 0 )

Essentially thread contention is a condition where one thread is waiting for a lock/object that is currently being held by another thread. Therefore, this waiting thread cannot use that object until the other thread has unlocked that particular object.
https://stackoverflow.com/questions/1970345/what-is-thread-contention

In certain computer programming languages, the Elvis operator, often written ?:, or or ||, is a binary operator that returns its first operand if that operand is considered true, and otherwise evaluates and returns its second operand.
like the binary Elvis operator used as x ?: y, the null coalescing operator is a binary operator and thus evaluates its operands at most once, which is significant if the evaluation of x has side-effects.

Маши́нный цикл — промежуток времени между двумя последовательными обращениями центрального процессора к внешней оперативной памяти команд/данных, или обмена 1 словом данных с периферийными устройствами, в том числе в циклах обработки аппаратных прерываний и является составляющей частью исполнения машинной команды.
В процессе исполнения одной машинной команды может выполняться один или несколько машинных циклов. В свою очередь, каждый машинный цикл может состоять из нескольких машинных тактов.
Тактовый сигнал или синхросигнал — сигнал, использующийся для согласования операций одной или более цифровых схем.

Valgrind по сути является виртуальной машиной, использующей методы JIT-компиляции, среди которых — динамическая перекомпиляция. То есть, оригинальная программа не выполняется непосредственно на основном процессоре. Вместо этого Valgrind сначала транслирует программу во временную, более простую форму, называемую промежуточным представлением (Intermediate Representation, сокр. IR), которая сама по себе не зависит от процессора и находится в SSA-виде. 

JIT-компиляция (англ. Just-in-time compilation, компиляция «на лету»), динамическая компиляция (англ. dynamic translation) — технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы.

Большинство реализаций JIT имеют последовательную структуру: сначала приложение компилируется в байт-код виртуальной машины среды исполнения (AOT-компиляция), а потом JIT компилирует байт-код непосредственно в машинный код. В итоге при запуске приложения тратится лишнее время, что впоследствии компенсируется более быстрой его работой.

Байт-код (байтко́д; англ. bytecode, также иногда p-код, p-code от portable code) — стандартное промежуточное представление[en], в которое может быть переведена компьютерная программа автоматическими средствами. По сравнению с исходным кодом, удобным для создания и чтения человеком, байт-код — это компактное представление программы, уже прошедшей синтаксический и семантический анализ. В нём в явном виде закодированы типы, области видимости и другие конструкции. С технической точки зрения, байт-код представляет собой машинно-независимый код низкого уровня, генерируемый транслятором из исходного кода.
Байт-код называется так, потому что длина каждого кода операции традиционно составляет один байт

Common Intermediate Language (сокращённо CIL) — «высокоуровневый ассемблер» виртуальной машины .NET. Промежуточный язык, разработанный фирмой «Microsoft» для платформы .NET Framework. JIT-компилятор CIL является частью CLR (англ. common language runtime) — общей среды выполнения программ, написанных на языках .NET. 
По синтаксису и мнемонике язык CIL напоминает язык ассемблера. 

Модуль предсказания переходов  — устройство, входящее в состав микропроцессоров, имеющих конвейерную архитектуру, предсказывающее, будет ли выполнен условный переход в исполняемой программе. Предсказание ветвлений позволяет сократить время простоя конвейера за счёт предварительной загрузки и исполнения инструкций, которые должны выполниться после выполнения инструкции условного перехода. Прогнозирование ветвлений играет критическую роль, так как в большинстве случаев позволяет оптимально использовать вычислительные ресурсы процессора.

Трансля́ция програ́ммы — преобразование программы, представленной на одном из языков программирования, в программу на другом языке. Транслятор обычно выполняет также диагностику ошибок, формирует словари идентификаторов, выдаёт для печати текст программы и т. д.[1]
Язык, на котором представлена входная программа, называется исходным языком, а сама программа — исходным кодом. Выходной язык называется целевым языком, а выходная (результирующая) программа — объектным кодом.

Код операции, операционный код, опкод — часть машинного языка, называемая инструкцией и определяющая операцию, которая должна быть выполнена.

Перфока́рта (перфорационная карта, перфорированная карта, от лат. perforo — пробиваю и лат. charta — лист из папируса; бумага) — носитель информации из тонкого картона, представляет информацию наличием или отсутствием отверстий в определённых позициях карты. Наиболее широко перфокарты применялись во второй половине XX века для ввода и хранения данных в системах автоматизированной обработки информации. В настоящее время, как и перфолента, практически вытеснены более компактными, быстрыми и удобными полупроводниковыми, магнитными и оптическими носителями.

Компьютеры первого поколения, в 1920-х—1950-х годах, использовали перфокарты в качестве основного носителя при хранении и обработке данных. Затем, в течение 1970-х — начале 1980-х годов, они использовались только для хранения данных и постепенно были замещены магнитными лентами. 

QR-код состоит из чёрных квадратов, расположенных в квадратной сетке на белом фоне, которые могут считываться с помощью устройств обработки изображений, таких как камера, и обрабатываться с использованием кодов Рида — Соломона до тех пор, пока изображение не будет надлежащим образом распознано. Затем необходимые данные извлекаются из шаблонов, которые присутствуют в горизонтальных и вертикальных компонентах изображения

Логистика — управление материальными, информационными и людскими потоками с целью их оптимизации (минимизации затрат)
Логистика как наука — методология разработки рациональных методов управления материальными и информационными потоками, нацеленных на их оптимизацию.

Коды Боуза — Чоудхури — Хоквингема (БЧХ-коды) — в теории кодирования это широкий класс циклических кодов, применяемых для защиты информации от ошибок
Код Рида — Соломона является частным случаем БЧХ-кода.

Фронтенд (англ. front-end) — клиентская сторона пользовательского интерфейса к программно-аппаратной части сервиса.
Бекенд (англ. back-end) — программно-аппаратная часть сервиса.
Фронт- и бекенд — это вариант архитектуры программного обеспечения.
Термины появились в программной инженерии вследствие развития принципа разделения ответственности между внешним представлением и внутренней реализацией.
Back-end создает некоторое API, которое использует front-end. Таким образом front-end разработчику не нужно знать особенностей реализации сервера, а back-end разработчику — реализацию front-end.

Си́мвол-джо́кер — символ, используемый для замены других символов или их последовательностей, приводя таким образом к символьным шаблонам. Развитием символов-джокеров являются регулярные выражения.

Регуля́рные выраже́ния (англ. regular expressions) — формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов

В области информатики граничный указатель (англ. bounded pointer) — указатель, дополненный добавочной информацией, обозначающей границы хранилища, внутрь которого указатель может ссылаться. Эта дополнительная информация иногда приобретает вид двух указателей, обозначающих верхний и нижний адреса хранилища, занятого объектом, на который указывает граничный указатель. Применение подобных указателей помогает обнаружить ошибки класса «выход за пределы массива».

// declares typedef for function and makes s_SymInitialize point to that function
typedef int 
	SymInitialize_type (
		int				hProcess,
		pstr*			UserSearchPath
    );
static SymInitialize_type*				s_SymInitialize = 0;

void	lol ( int( int, pstr* ) )
{

}


// i don't produce debugging symbols in both projects
// to reduce their size

int main( int argc, pstr* argv )
{
    using namespace inex::core::log;
	s_SymInitialize	=	&main;
	// is this pointer to function or wat?
	lol	( s_SymInitialize );
}


if(((i/2)*2)==i) // checking for being even

The typedef defines PConnectionFunction to be a member function pointer, not a plain function pointer. You can call member functions only on an object, like this:

template <typename T, typename BaseClass> 
T TConnectionPoint<T,BaseClass>::Call(BaseClass& b)
{
    return (b.*_func)();
}
If instead you want to call static member functions ob BaseClass, then the function pointer needs to be a normal function pointer, not a member function pointer:

typedef   T (* PConnectionFunction)();



I don't know of any C++03 solution exactly like that, and it's not built into the language, but in C++11, this is possible with using aliases:

template<typename T>
using TouchCallBack = void (*)(GLRenderer*, const MotionEvent&, std::vector<T >);
One workaround for C++03 is using a struct:

template<typename T>
struct TouchCallBack {
    typedef void (*type)(GLRenderer*, const MotionEvent&, std::vector<T >);
};


если провести вдоль любой стороны выпуклого многоугольника прямую, то он весь останется по одну сторону от прямой. если тоже проделать с невыпуклой то часть будет по одну сторону часть по другую. 
к выпуклым многоугольникам можно отнести треугольники, к невыпуклям такие фигуры как например звезда


bool CreatePolygon(Polygon&);//заполняет многоугольник данными, возвращает false при ошибке
int  CreatePolygon(Polygon&);//заполняет многоугольник данными, возвращает 0 или код ошибки

перегруженные операторы должны поддерживать семантику builtin операторов

std::vector<int> values(10);
int v = values[11]; // не выкидывает exception (в каких-то версиях в debug режиме может и выкидывать, но по стандарту не должен)
int v = values.at(11); // обязан выкинуть exception

bool Intersection ( Polygon p1, Polygon p2, Polygon& p12 );
// возвращает true, если пересекаются; p12 - пересечение многоугольников p1, p2 
// возвращает false, если не пересекаются


// declares typedef for function and makes s_SymInitialize point to that function
typedef int 
	SymInitialize_type (
		int				hProcess
    );
static SymInitialize_type*				s_SymInitialize = 0;

// cant use overloading cuz theyre considered the same - they use function address
void	lol1 ( int( func_ptr )( int ) )
{
	// using * and no operator with func_ptr gives the address of ptr
	// but & gives address of temp var i think
	std::cout << "LOL1:\t" << func_ptr << '\n';
}

void	lol ( int ( *func_ptr )( int ) )
{
	std::cout << "LOL:\t"  << func_ptr << '\n';
}

int		five ( int )
{
	return 5u;
}

int		six ( int )
{
	return 6u;
}

int*	ret_ptr ( )
{
	std::cout << "LOL\n";
	return 0;
}

//When function is used as an argument, the real thing that is passed is the ADDRESS of the function.


// to get stack trace try "try" whole main instructions
// and catch anything or..

// операции распределены на группы и первыми выполняются операции с
// более высоким приоритетом.
// если у операций одинаковый приоритет, решает ассоциативность
// она бывает слева направо или справа налево
// слева значит первоочередное выполнение самой левой операции,
// с справа - правой, соответственно

int main( int argc, pstr* argv )
{
    using namespace inex::core::log;
	// functions HAVE only address to work with so can only use pointers!
	int* not_ptr ( int );
	//not_ptr			=	ret_ptr;	

	int*				ptr			= 0;
	&*ptr; // take address of value ptr points to ..?

	int ( *ptrf1 ) ( int )			= five;
	int ( *ptrf2 ) ( int )			= six;

	// so & means address of var, and * or empty means
	// address pointed to, what a surprise
	std::cout << &ptrf1 << '\n';
	std::cout << &ptrf2 << '\n';

	lol								( ptrf1 );
	lol								( ptrf2 );

	lol1							( *ptrf1 );
	lol1							( *ptrf2 );

	// массив из двух элементов - указателей на функцию
	int	( *func_ar[ 2 ] )( int )	= { five, six };
	// and if we have
	// ( *func_arc )[ 2 ] это указатель на массив из двух лементов 

	// 	указатель на указатель на массив указателей на функции из двух элементов?
	int ( *( *ptr_ptr_ar )[ 2 ] ) ( int )	= &func_ar; 
											// func_ar == &func_ar[ 0 ]
											// &func_ar - адресс массива
											// know the difference
	// ptr_ptr_ar + 1 - next element
	// &ptr_ptr_ar + 1 - next memory block after ptr_ptr_ar
	// access to first dereferenced element
	//**&func_ar == *func_ar = func_ar[ 0 ];

	// *ptr_ptr_ar - сам массив, а ( *ptr_ptr_ar )[ 0 ] - обращение к элеметнам
	 lol1							( ( *ptr_ptr_ar )[ 1 ] );
									// получаем указатель на ф-ию так

	// указатель на указатель на функцию
	int ( **ptr_ar ) ( int )				= func_ar;

	lol1							( *ptr_ar );
	lol								( *( ptr_ar[ 1 ] ) );











schelipov.fedor@yandex.ru ( kz )

#include "stdafx.h"

#include <inex/engine/ie_engine.h>
#include <inex/stl_extensions_vector.h>

#include <process.h>
#include <iostream>
#include <Windows.h>
#include "dbghelp.h"

using namespace std;

const int MaxNameLen = 256;

#pragma comment(lib,"Dbghelp.lib")

void printStack( CONTEXT* ctx ) //Prints stack trace based on context record
{
    BOOL    result;
    HANDLE  process;
    HANDLE  thread;
    HMODULE hModule;

    STACKFRAME64        stack;
    ULONG               frame;    
    DWORD64             displacement;

    DWORD disp;
    IMAGEHLP_LINE64 *line;

    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
    char name[ MaxNameLen ];
    char module[MaxNameLen];
    PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;

    memset( &stack, 0, sizeof( STACKFRAME64 ) );

    process                = GetCurrentProcess();
    thread                 = GetCurrentThread();
    displacement           = 0;
#if !defined(_M_AMD64)
    stack.AddrPC.Offset    = (*ctx).Eip;
    stack.AddrPC.Mode      = AddrModeFlat;
    stack.AddrStack.Offset = (*ctx).Esp;
    stack.AddrStack.Mode   = AddrModeFlat;
    stack.AddrFrame.Offset = (*ctx).Ebp;
    stack.AddrFrame.Mode   = AddrModeFlat;
#endif

    SymInitialize( process, NULL, TRUE ); //load symbols

    for( frame = 0; ; frame++ )
    {
        //get next call from stack
        result = StackWalk64
        (
#if defined(_M_AMD64)
            IMAGE_FILE_MACHINE_AMD64
#else
            IMAGE_FILE_MACHINE_I386
#endif
            ,
            process,
            thread,
            &stack,
            ctx,
            NULL,
            SymFunctionTableAccess64,
            SymGetModuleBase64,
            NULL
        );

        if( !result ) break;        

        //get symbol name for address
        pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
        pSymbol->MaxNameLen = MAX_SYM_NAME;
        SymFromAddr(process, ( ULONG64 )stack.AddrPC.Offset, &displacement, pSymbol);

        line = (IMAGEHLP_LINE64 *)malloc(sizeof(IMAGEHLP_LINE64));
        line->SizeOfStruct = sizeof(IMAGEHLP_LINE64);       

        //try to get line
        if (SymGetLineFromAddr64(process, stack.AddrPC.Offset, &disp, line))
        {
            printf("\tat %s in %s: line: %lu: address: 0x%0X\n", pSymbol->Name, line->FileName, line->LineNumber, pSymbol->Address);
        }
        else
        { 
            //failed to get line
            printf("\tat %s, address 0x%0X.\n", pSymbol->Name, pSymbol->Address);
            hModule = NULL;
            lstrcpyA(module,"");        
            GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, 
                (LPCTSTR)(stack.AddrPC.Offset), &hModule);

            //at least print module name
            if(hModule != NULL)GetModuleFileNameA(hModule,module,MaxNameLen);       

            printf ("in %s\n",module);
        }       

        free(line);
        line = NULL;
    }
}

//******************************************************************************

void function2()
{
    int a = 0;
    int b = 0;
    //throw new exception;
}

void function1()
{
    int a = 0;
    function2();
}

void function0()
{
    function1();
}

int seh_filter(_EXCEPTION_POINTERS* ex)
{
    printf("*** Exception 0x%x occured ***\n\n",ex->ExceptionRecord->ExceptionCode);    
    printStack(ex->ContextRecord);

    return EXCEPTION_EXECUTE_HANDLER;
}

CONTEXT Context;

static void threadFunction(void *param)
{    

      function0();
		printStack(&Context);
  
}
// for dx11
//#include <d3d11.h>

// i don't produce debugging symbols in both projects
// to reduce their size

int main( int argc, pstr* argv )
{
	RtlCaptureContext(&Context); 
    using namespace inex::core::log;

	threadFunction( 0 );
    //_initialize();

    //Msg("some text");

    //char ch1;std::cin>>ch1;
    //_destroy();
	//lol::file_writer* log11=new lol::file_writer("log.log");

	//log11->w		("some str\n");
	//log11->w		("new str 123");

	//delete log11;

	//inex::engine::engine en{argc, argv};
	//ASSERT_S(1==1);


   //inex::core::CFileSystem ie_FS	={};
   //auto it = ie_FS.files.begin();

   	//inex::core::reader* r = ie_FS.r_open("engine.log");
	//r->r_stringZ(0,0);
	//ie_FS.r_close(r);

    //u8* data =(u8*)MapViewOfFile((*it).m_mapped_file, FILE_MAP_READ, 0,0,0);
   	//inex::core::reader r(data,0);
	//r.r_stringZ(0,0);

	inex::engine::engine en{ argc, argv };
   // auto it = ie_FS.files.begin();
    //inex::core::read_file(&(*it));

	Msg( "sz ptr: %u", sizeof ( pvoid ) );
	//read_file(0);

    char ch;
	std::cin >> ch;

   	return 0;
} //




http://rutracker.org/forum/viewtopic.php?t=5602685

утром: 		яйцо
днем: 		фрукты
полдник: 	овощи
ужин:		овощи
ночь:		чай








Башня (сериал)
Иван Грозный (сериал)
Доктор Живаго (сериал
Казус Кукоцкого (сериал

достоевский
Маяковский. Два дня (сериал)

Кирюха
Слуга народа (сериал)
Ищу жену с ребёнком
Между нами, девочками
Сыщик Самоваров (сериал)
Золушка с прицепом (сериал)
Деревенская комедия
Приключения солдата Ивана Чонкина
Родственнички (сериал
Фарца (сериал)
Жизненные обстоятельства (сериал)
Департамент (сериал)
Сеть (сериал)
Вы все меня бесите (сериал)

Митяй
Найти мужа Дарье Климовой ( сериал )
Погоня за шедевром ( сериал )
Три королевы ( сериал )
Неподсудные ( сериал )
Людмила Гурченко ( сериал )
Трюкач (сериал)
Алхимик. Эликсир Фауста (сериал)
Мой любимый папа
Аленка из Почитанки
Невеста (сериал
Дом с лилиями
Разведчицы (сериал)
Новогодний переполох
Хранимые судьбой (сериал)
Отрыв (сериал)
Вендетта по-русски
Танец нашей любви (сериал)
«Кедр» пронзает небо (сериал)
Серафима прекрасная (сериал)
Подарок судьбы (сериал)
Гаражи (сериал)
Шериф (сериал)
Судмедэксперты (сериал)
Одну тебя люблю (сериал)
Вердикт (мини-сериал)
Одна семья (сериал)
Вербное воскресенье (сериал)
Террористка: Особо опасна
Мины в фарватере
Шальной ангел (сериал)
Батюшка (сериал)
Афганский призрак
Александр Македонский (сериал)
Черный снег
Срочно в номер (сериал)
Атлантида (сериал)
Прииск (сериал)
Национальное достояние (сериал)
Жизнь – поле для охоты
Атаман (сериал)
Шахматист (сериал)
Спасти и выжить (сериал)
Сибирочка (сериал)
Нина (мини-сериал)
Семейные тайны (мини-сериал
Новый год в ноябре (сериал)
Черная комната (сериал)

лабан
Забытый (мини-сериал)
Форс-мажор (сериал
Майор полиции (сериал)
Верю (сериал)
Откричат журавли (сериал)
Сильнее огня (мини-сериал)
Острог. Дело Федора Сеченова

будько
Наружное наблюдение (сериал
Последний секрет Мастера (сериал)
У каждого своя война (сериал)
Марево (мини-сериал)
Девять неизвестных (мини-сериал)
Дорогая передача (сериал)
Золотой теленок (сериал)
Моя большая армянская свадьба (мини-сериал)
32 декабря (мини-сериал)
Бульварный переплет (мини-сериал)
Шукшинские рассказы (сериал)
Подозрение (мини-сериал)
Искатели (сериал)

olia
Домик у реки.
.Проснемся вместе? (сериал)
.Фантом (сериал)
.Амазонки (сериал)
.Отблески (сериал)
.
для мастеринга cubase или nuendo или флстудио
https://www.patreon.com/posts/3525086

math http://www.webstaratel.ru/2011/10/stepeni-chisla-dva.html
mathus.ru com?

pointers to functions, oop in c and templates with func ptrs

inline
s32     sum ( s32 const& a, s32 const& b )
{
    return  a + b;
}

inline
void     square ( pvoid raw_pointer )
{
    *( s32* ) raw_pointer    = 10;
}

inline
void     zero_even ( pvoid raw_pointer )
{
    *( s32* ) raw_pointer   = 0;
}

void    modify_array ( pvoid array, u32 size, u32 size_of_type,  void (* function_pointer )( pvoid  ) )
{
    char* pointer   = ( char* ) array;

    for ( u32 i( 0 ); i < size; ++i )
    {
        function_pointer( ( pvoid ) ( pointer + ( i * size_of_type ) ) );
    }
}

void	edit ( s32* pointer )
{
	std::cout 			<< "address of ptr in edit is " << pointer << '\n';
	// pointer points to copy of pointer but has the same address
	// we can freely change it and it works.. BUT
	// when we do such a thing: pointer = nullptr
	// pointer points to 0, but our original argument isn't changing
	// in other words, dereferencing works only, cuz temp var points to same address
	*pointer			= 5; 
}

// here we can change value of the pointer directly cuz we pass address of pointer and
// work with it
void	edit ( s32** pointer )
{
	// by dereferencing, we set a new address for pointer;
	*pointer			= new s32 ( 15 );
}

void bar(int a)
{
	std::cout << a << std::endl;
}
 
typedef void ( *func_ptr )( int );

template< func_ptr func >
void foo()
{
	func(5);
}

struct object;

typedef struct
{
    void ( *prop ) ( object* obj, s32 const& rhs );
} method; // struct method

struct object
{
    method*   impl;
    s32         n;
}; // struct object

void    plus_impl ( object* obj, s32 const& rhs )
{
    obj->n          += rhs;
}

void    minus_impl ( object* obj, s32 const& rhs )
{
    obj->n          -= rhs;
}

method plus_ = { &plus_impl };
method minus_ = { &minus_impl };

object objects[ 2 ]     =
                {
                    {
                        &plus_,
                        10
                    },
                    {
                        &minus_,
                        20
                    }
                };

struct str
{
	s32 	data;
	s32 ( *open )( str* );
}; // struct str

s32     prop ( str* self )
{
    return              self->data;
} 

s32	    open_str ( str* obj )
{
	obj->data			= 50;
	return 				obj->data;
}


int     main ( int argc, pcstr argv[ ] )
{

    objects[ 0 ].impl->prop( &objects[ 0 ], 50 );
    objects[ 1 ].impl->prop( &objects[ 1 ], 25 );

    std::printf     ( "o1: %d\no2: %d\n", objects[ 0 ].n, objects[ 1 ].n );

	str s 			= { 0, &open_str };
	
	std::printf		( "%d\n", s.open( &s ) );

	foo< bar >( );

	s32* p							= new s32 ( 54 );
	std::printf						( "%p\n", p );
	edit 							( &p );
	std::printf						( "%p\n", p );

	delete 							p; p = nullptr;

	s32* e							= ( s32* ) std::malloc( sizeof( s32 ) );
	*e								= 6;
	std::printf						( "%d\n", *e );
	s32 i							= 6;
	std::cout 						<< "address of I " << &i << '\n';
	edit							( &i );
	std::printf						( "%d\n", i );

	std::free 						( e );
	e								= nullptr;

    u32 const   container_size      ( 10 );
    s32*        container           = ( s32* ) std::malloc( sizeof( s32 ) * container_size );
 
    for ( u32 i( 0 ); i < container_size; ++i )
    {
        container[ i ]              = i;
    }
// defines void_function_pointer as pointer to function returning void and taking pvoid
//	void ( * )( pvoid )
    typedef     void            ( *void_function_pointer )( pvoid );

    void_function_pointer
        function_pointer		= &square;
    modify_array                    ( container, container_size, sizeof( s32 ), function_pointer );

    for ( u32 i( 0 ); i < container_size; ++i )
    {
        std::printf                 ( "%d elem\t=\t%d\n", i, container[ i ] );
    }

    function_pointer                = &zero_even;
    
    modify_array                    ( container, container_size, sizeof( s32 ), function_pointer );
    
    for ( u32 i( 0 ); i < container_size; ++i )
    {
        std::printf                 ( "Z: %d elem\t=\t%d\n", i, container[ i ] );
    }

    std::free                       ( container );
    container                       = nullptr;




А последний чудо-метод можно подкорректировать и так:
Во всех скобках нам нужно сделать выражение вида: ( X-a) или (X+a)(канонический вид множителя), т.е. чтобы Х был с плюсом. Где такое выражение и есть - ничего не трогаем. Где минус пришлось вынести за скобки - считаем количество таких минусов: если их нечетное количество, то меняем знак неравенства на противоположный, если их четное количество (они сами перемножаясь, дают знак плюс) - то знак неравенства не трогаем. И ВСЁ!

Теперь расставляем знаки СПРАВА - Налево, Начиная С ПЛЮСА:

ПРИМЕР: 
было (x−5) (x−4) (x+2 )(7−x) > 0

стало (x−5) (x−4) (x+2) (x−7) <0 !!!

Ответы на это неравенство < 0 будут такими же , как и на первое неравенство >0.
( Знак поменяли в одной скобке - вышел один минус, поэтому и знак неравенства поменялся на противоположный)

корни: x=5, x=4, x=-2, x=7. 

x=7 - самый правый корень, после неё + , остальные знаки в порядке чередования 
СПРАВА- НАЛЕВО ( в этом примере повторений знака не будет, так как нет множителей в четной степени - у нас все скобки - в первой (нечетной) степени).
+ (-2) - (4) + (5) - (7) +

ОТВЕТ: (-2;4) U (5;7)



vs++ C::B
https://stackoverflow.com/questions/43242185/how-can-i-use-codeblocks-with-the-most-recent-versions-of-the-vc-compiler#



В 64-разрядной системе (например, Windows 7) поместите 32-разрядные .dll в папку C:/Windows/SysWOW64, в которой хранятся 32-разрядные динамические библиотеки. Папка System32, напротив, предназначена для хранения 64-разрядных .dll, из-за чего иногда возникает путаница.

http://ru.solverbook.com/spravochnik/trigonometriya/trigonometricheskie-neravenstva-ix-resheniya/
https://babaev-an.ru/sine_inequalities_decision/#example_3
https://egemaximum.ru/prostejshie-trigonometricheskie-neravenstva-primery/#comments

GLEW Mingw-w64
http://www.glfw.org/docs/3.2/compile.html#compile_deps_mingw_cross

https://www.opengl.org/discussion_boards/showthread.php/198730-How-do-I-build-GLEW-for-mingw-w64-using-cmake-on-Windows

on certain popular compilers, if the destructor is the only virtual method defined for the class, it is a good idea to make it non-inline, to help the implementation deal with its polymorphism magic.

http://fierymusic.ru/rabota-so-zvukom/sintez-zvuka/sozdanie-basa
scoobyDoo https://kinohd777.ru/board/multserialy/novoe_shou_skubi_i_skrehppi_du_multserial/21-1-0-23491

http://oldshatalov.ghost17.ru/ru/articles/math/foreword.html

https://www.khanacademy.org/math/trigonometry/trigonometry-right-triangles/intro-to-the-trig-ratios/a/opposite-adjacent-hypotenuse


cli

http://yandex.kz/clck/jsredir?bu=4dp91u&from=yandex.kz%3Bsearch%2F%3Bweb%3B%3B&text=&etext=1806.1vqgN1DGr26I4Dgjztn2eYYaeRo2VogVM51g56tu9cI.ce50be39cce817d8a215668fb7aa969fe6a8fc4a&uuid=&state=PEtFfuTeVD5kpHnK9lio9dFa2ePbDzX7kPpTCH_rtQkH2bBEi5M--bO-cYhaTVRUybkq5bCQtn6JVk60aPrx4khDLPAEn9-o&&cst=AiuY0DBWFJ5Hyx_fyvalFL1IJbEfibPkqkOte5dyNG72W5NN4ULzVHukBTZHG7_FEu9QeVaVeAgIOljZj3tKlklTEW71GQAfh5mHTziMgMAFSHuWgG8IyOGWLv_oA9d9erP-3Y0gKFJfPW02-h-VlnFi1LHQensrWuQcszOIaRfxVpndp7jXOYFZ1P35dfgiWbucV2NOxkiaHvBmaSGi3O7V6w4DxZ3ZBQN_doeQqJka6_ZgiGubIuWi6T_9TraXof13uYvSSYdmL7AWW4Y7UX0PbxMfqVpE54wZ3AgSiLQwIjIMyWaNAz1rDXcJaf6jjBvThQ2kqh0boQ-6MgGHU3FYYpCjP72f6vKZibOHrO4,&data=UlNrNmk5WktYejY4cHFySjRXSWhXR0RMeGtWVHpUTWhCMWtUU2VfaFlycXViSWg1azdycUhvT0FQLXBYc2x6WWpzN3VDbnJUNV9TMmNORmNqcVA3ei1zaFYxb1RMaUFhLXdqazlteHhMNnRyNk1rR3hhUGNSZyws&sign=5d00390ed565b1d9ea72aae5818e367c&keyno=0&b64e=2&ref=orjY4mGPRjkm1GYumWD8VpzF_kJ2sVs544x6EUKVdvk,&l10n=ru&cts=1527949181736&mc=4.483617685440307
http://yandex.kz/clck/jsredir?bu=4dp91u&from=yandex.kz%3Bsearch%2F%3Bweb%3B%3B&text=&etext=1806.1vqgN1DGr26I4Dgjztn2eYYaeRo2VogVM51g56tu9cI.ce50be39cce817d8a215668fb7aa969fe6a8fc4a&uuid=&state=PEtFfuTeVD5kpHnK9lio9dFa2ePbDzX7kPpTCH_rtQkH2bBEi5M--bO-cYhaTVRUybkq5bCQtn6JVk60aPrx4khDLPAEn9-o&&cst=AiuY0DBWFJ5Hyx_fyvalFL1IJbEfibPkqkOte5dyNG72W5NN4ULzVHukBTZHG7_FEu9QeVaVeAgIOljZj3tKlklTEW71GQAfh5mHTziMgMAFSHuWgG8IyOGWLv_oA9d9erP-3Y0gKFJfPW02-h-VlnFi1LHQensrWuQcszOIaRfxVpndp7jXOYFZ1P35dfgiWbucV2NOxkiaHvBmaSGi3O7V6w4DxZ3ZBQN_doeQqJka6_ZgiGubIuWi6T_9TraXof13uYvSSYdmL7AWW4Y7UX0PbxMfqVpE54wZ3AgSiLQwIjIMyWaNAz1rDXcJaf6jjBvThQ2kqh0boQ-6MgGHU3FYYpCjP72f6vKZibOHrO4,&data=UlNrNmk5WktYejY4cHFySjRXSWhXR0RMeGtWVHpUTWhCMWtUU2VfaFlycXViSWg1azdycUhvT0FQLXBYc2x6WWpzN3VDbnJUNV9TMmNORmNqcVA3ei1zaFYxb1RMaUFhLXdqazlteHhMNnRyNk1rR3hhUGNSZyws&sign=5d00390ed565b1d9ea72aae5818e367c&keyno=0&b64e=2&ref=orjY4mGPRjkm1GYumWD8VpzF_kJ2sVs544x6EUKVdvk,&l10n=ru&cts=1527949220823&mc=4.63388527193723

айвор хортон c++ cli

lobanchikov
http://yandex.kz/clck/jsredir?bu=3yn1fr&from=yandex.kz%3Bsearch%2F%3Bweb%3B%3B&text=&etext=1805.3zxfR6lloj6sdZxwDPOmritoUeiQjPHHrw5SuIZR98Few_YFgLtXeZj9oIW41mar.2190a2b2dcc544622fe6b1ec8f9f6ef46c4bebe7&uuid=&state=PEtFfuTeVD4jaxywoSUvtB2i7c0_vxGdgvKc46qzPyd-ujzmIIyXCJD0CnpIUwtUJgA8npTk82ayP5ETpaot3rDAtf6F7g4roiXuh99naL4,&&cst=AiuY0DBWFJ5Hyx_fyvalFC2Hvr2ycG1O63NBf0LYbyLq4WURxRS9mrsAMIKVT09CJqwc-FUi4DcESBk0Q3143ULrLEhzKOXAD_cdlslvXqLSesJRAVyL_xNJkNOLDJtjfAf9jV2kr-9jEucH8PnwxzH9GDH26tVtvtXtTahBdMENsXk4w4umXR3wAnXuArXizoHQN_ZOMz--Z2J53385kSPmzznWuTFmWdmmJ88egqpjadJZDPRiW_rVXC_UtRLEO9Eq3wQlx3tUti40KJ9_4llInEc_x15Uc5hyAvrgkwgSJicmvZwxj5jQVgxb1qdpJ7gPQ7Cv0i80DczMKOUh4A,,&data=UlNrNmk5WktYejY4cHFySjRXSWhXTVdnWUhmLU5pZzdzUlpIYS1HZ1ZISm82ZFhrbFNSdi0wSFZ0WkZQeUJHUWx3aUpOSjQwTGFZc2NVeDROanRYejNEdWRnTzNaYm12QTFndWRkVUxaSEQzSDltMWRuV0tJZEUtZ3RsQ01wTmcwSEszeU1fRjFYcyw,&sign=d938360082388f82e5c7e16cebd18f6e&keyno=0&b64e=2&ref=orjY4mGPRjkm1GYumWD8VpzF_kJ2sVs544x6EUKVdvk,&l10n=ru&cts=1527845927075&mc=3.454822399946607

https://stackoverflow.com/questions/12297021/is-there-any-difference-between-list-x-and-list-x

https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82
https://gamedev.ru/code/forum/?id=203101&page=2

https://bytes.com/topic/c/answers/168392-cross-platform-any-alternatives-pimpl

VS
а профессиональном уровне стоит использовать VS. Помимо дебагера шейдеров, существует незаменимый плагин Wholetomato Visual Assist, позволяющий физически ускорить написание кода в несколько раз за счет всплывающих подсказок и дополнения ввода, и который очень актуален для DX, поскольку последний изобилует функциями с немалым числом передаваемых параметров и длинными именами типов данных.


x32 to x64
https://habrahabr.ru/company/pvs-studio/blog/80936/
https://www.viva64.com/ru/a/0004/#ID0EEDNM

https://stackoverflow.com/questions/115703/storing-c-template-function-definitions-in-a-cpp-file
https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl
RC.EXE issue
https://forum.qt.io/topic/78454/qt-debugger-problem/9

memcpy speed
https://public.kitware.com/pipermail/vtk-developers/2000-March/000012.html

POSIX <dirent.n>
https://www.ibm.com/developerworks/ru/library/au-unix-readdir/

PIMPL
http://www.gotw.ca/gotw/024.htm // nothing useful
https://habr.com/post/118010/

crossplatform
https://stackoverflow.com/questions/18238477/cross-platform-c-code-and-single-header-multiple-implementations
http://www.crossplatform.ru/node/146

версия гнук
https://sourceforge.net/p/predef/wiki/Compilers/
https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html

MinGW-w64 defines both __MINGW32__ and __MINGW64__, so 
__MINGW32__ only will work for both mingw and mingw-w64. 

This is very handy when writing portable software, because mingw-w64 
automatically gets all the __MINGW32__ stuff which is often also good 
for mingw-w64. You only need __MINGW64__ when the code needs to be 
different for 64 bit compared to 32 bit. 


http://jemalloc.net/jemalloc.3.html и есть pdf в папке
https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919
http://blog.reverberate.org/2009/02/one-malloc-to-rule-them-all.html
https://www.ibm.com/developerworks/linux/library/l-memory/
delegate c++
http://rsdn.org/article/cpp/delegates.xml

собеседование
http://blog.gamedeff.com/?p=64
https://gamedev.ru/code/forum/?id=150166
как работает hash table. Не помнят, как посчитать dot product, потому что мол пользуются библиотечной функцией. С трудом могут выразить мысль, когда linked list предпочительнее динамического массива.  


FLOAT
https://gamedev.ru/code/articles/FloatingPoint
https://habrahabr.ru/post/112953/

// GCC asm
http://www.iakovlev.org/index.html?p=1483
https://gamedev.ru/code/articles/gcc_inline_asm


// crossplatform things//
https://www.backblaze.com/blog/10-rules-for-how-to-write-cross-platform-code/
https://stackoverflow.com/questions/3103568/how-to-write-portable-code-in-c
http://www.pvsm.ru/linux/253157
http://rsdn.org/forum/cpp/100265.flat
http://itw66.ru/blog/c_plus_plus/477.html
http://www.pvsm.ru/linux/253157
// singleton
http://itw66.ru/blog/c_plus_plus/65.html
http://itw66.ru/blog/c_plus_plus/71.html

// CoW
http://www.gotw.ca/gotw/043.htm
http://gotw.ca/publications/optimizations.htm // IS COW SHIT?
https://hackerboss.com/i-have-seen-the-future-and-it-is-copy-on-write/
http://www.cyberforum.ru/cpp-beginners/thread574860.html

// openMP
http://www.cyberforum.ru/blogs/18334/blog2965.html
// cpu cores
http://code.i-harness.com/ru/q/2c46be
http://code.i-harness.com/ru/q/24b53





/*
void get_cpu_feats  ()
{
    // put that in enumeration
    bool HW_MMX;

    //  SIMD: 128-bit
    bool HW_SSE;
    bool HW_SSE2;
    bool HW_SSE3;
    bool HW_SSSE3;
    bool HW_SSE41;
    bool HW_SSE42;
    bool HW_SSE4a;
    bool HW_3DNow;
    bool HW_3DNowExt;
    bool HW_HTT;

    s32 info[4]; // EAX, EBX, ECX, EDX
    cpuid(info, 0);
    s32 nIds = info[0];

    cpuid(info, 0x80000000);
    u32 nExIds = info[0];

    //  Detect Features
    if (nIds >= 0x00000001){
        cpuid(info,0x00000001);
        HW_MMX      =(info[3] & ((int)1 << 23)) != 0;
        HW_SSE      =(info[3] & ((int)1 << 25)) != 0;
        HW_SSE2     =(info[3] & ((int)1 << 26)) != 0;
        HW_SSE3     =(info[2] & ((int)1 <<  0)) != 0;

        HW_SSSE3    =(info[2] & ((int)1 <<  9)) != 0;
        HW_SSE41    =(info[2] & ((int)1 << 19)) != 0;
        HW_SSE42    =(info[2] & ((int)1 << 20)) != 0;


    }
    if (nIds >= 0x00000007){
        cpuid(info,0x00000007);

    }
    if (nExIds >= 0x80000001){
        cpuid(info,0x80000001);
        HW_SSE4a    =(info[2] & ((int)1 <<  6)) != 0;
        HW_3DNow    =(info[3] & ((int)1 << 31)) != 0;
        HW_3DNowExt =(info[3] & ((int)1 << 30)) != 0;
        HW_HTT      =(info[3] & ((int)1 << 28)) != 0;
    }
    string128 fts{0};
    if(HW_MMX)strcat(fts, "MMX");
    if(HW_SSE)strcat(fts, ", SSE");
    if(HW_SSE2)strcat(fts, ", SSE 2");
    if(HW_SSE3)strcat(fts, ", SSE 3");
    if(HW_SSE41)strcat(fts, ", SSE 4.1");
    if(HW_SSE42)strcat(fts, ", SSE 4.2");
    if(HW_SSE4a)strcat(fts, ", SSE 4.a");
    if(HW_SSSE3)strcat(fts, ", SSSE 3");
    if(HW_3DNow)strcat(fts, ", 3D Now!");
    if(HW_3DNowExt)strcat(fts, ", 3D Now! Ext.");
    if(HW_HTT)strcat(fts, ", HTT");
    Msg("* CPU Features: %s\n", fts);
}
*/

#include <cstdio>
#include <cstdint>

typedef uint32_t ui32;

ui32 max_cpuid_level;
char vendor[12]; // not ASCIIZ !

ui32 model,brand,feat0,feat1;

static const char *flag_names0[32][2]=
{
    {"bit  0 (SSE3)","SSE3, MXCSR, CR4.OSXMMEXCPT, #XF, if FPU=1 then also FISTTP"},
    {"bit  1 (PCLMUL)","PCLMULQDQ"},
    {"bit  2 (DTES64)","64-bit Debug Trace and EMON Store MSRs"},
    {"bit  3 (MON)","MONITOR/MWAIT, MISC_ENABLE.MONE, MISC_ENABLE.LCMV MONITOR_FILTER_LINE_SIZE MSR also see standard level 0000_0005h setting MISC_ENABLE.MONE=0 causes MON=0 "},
    {"bit  4 (DSCPL)","CPL-qualified Debug Store"},
    {"bit  5 (VMX)","CR4.VMXE, VM* and VM*"},
    {"bit  6 (SMX)","CR4.SMXE, GETSEC"},
    {"bit  7 (EST)","Enhanced SpeedStep Technology"},
    {"bit  8 (TM2)","MISC_ENABLE.TM2E THERM_INTERRUPT and THERM_STATUS MSRs xAPIC thermal LVT entry THERM2_CONTROL MSR "},
    {"bit  9 (SSSE3)","SSSE3"},
    {"bit 10 (CID)"," context ID: the L1 data cache can be set to adaptive or shared mode MISC_ENABLE.L1DCCM "},
    {"bit 11 (SDBG)","DEBUG_INTERFACE MSR for silicon debug"},
    {"bit 12 (FMA)","FMA"},
    {"bit 13 (CX16)","CMPXCHG16B"},
    {"bit 14 (ETPRD)","MISC_ENABLE.ETPRD"},
    {"bit 15 (PDCM)","Performance Debug Capability MSR"},
    {"bit 16","reserved"},
    {"bit 17 (PCID)","CR4.PCIDE"},
    {"bit 18 (DCA)"," Direct Cache Access (that is, the ability to prefetch data from MMIO) also see standard level 0000_0009h "},
    {"bit 19 (SSE4.1)","SSE4.1, MXCSR, CR4.OSXMMEXCPT, #XF"},
    {"bit 20 (SSE4.2)","SSE4.2"},
    {"bit 21 (x2APIC)"," x2APIC, APIC_BASE.EXTD, MSRs 0000_0800h...0000_0BFFh 64-bit ICR (+030h but not +031h), no DFR (+00Eh), SELF_IPI (+040h) also see standard level 0000_000Bh "},
    {"bit 22 (MOVBE)","MOVBE"},
    {"bit 23 (POPCNT)","POPCNT"},
    {"bit 24 (TSCD)","local APIC supports one-shot operation using TSC deadline value"},
    {"bit 25 (AES)","AES*"},
    {"bit 26 (XSAVE)","CR4.OSXSAVE, XCRn, XGETBV, XSETBV, XSAVE(OPT), XRSTOR also see standard level 0000_000Dh "},
    {"bit 27 (OSXSAVE)","non-privileged read-only copy of current CR4.OSXSAVE value"},
    {"bit 28 (AVX)","AVX"},
    {"bit 29 (F16C)","VCVTPH2PS and VCVTPS2PH"},
    {"bit 30 (RDRAND)","RDRAND"},
    {"bit 31 (unused)","reserved"}
};

static const char *flag_names1[32][2]=
{
    {"bit  0 (FPU)","FPU"},
    {"bit  1 (VME)","CR4.VME/PVI, EFLAGS.VIP/VIF, TSS32.IRB"},
    {"bit  2 (DE)","CR4.DE, DR7.RW=10b, #UD on MOV from/to DR4/5"},
    {"bit  3 (PSE)","PDE.PS, PDE/PTE.res, CR4.PSE, #PF(1xxxb)"},
    {"bit  4 (TSC)","TSC, RDTSC, CR4.TSD (doesn't imply MSR=1)"},
    {"bit  5 (MSR)","MSRs, RDMSR/WRMSR"},
    {"bit  6 (PAE)","64-bit PDPTE/PDE/PTEs, CR4.PAE"},
    {"bit  7 (MCE)","MCAR/MCTR MSRs, CR4.MCE, #MC"},
    {"bit  8 (CX8)","CMPXCHG8B #5"},
    {"bit  9 (APIC)","APIC #3, #4"},
    {"bit 10","reserved"},
    {"bit 11 (SEP)","SYSENTER/SYSEXIT, SEP_* MSRs #2"},
    {"bit 12 (MTRR)","MTRR* MSRs"},
    {"bit 13 (PGE)","PDE/PTE.G, CR4.PGE"},
    {"bit 14 (MCA)","MCG_*/MCn_* MSRs, CR4.MCE, #MC"},
    {"bit 15 (CMOV)","CMOVcc, if FPU=1 then also FCMOVcc/F(U)COMI(P)"},
    {"bit 16 (PAT)","PAT MSR, PDE/PTE.PAT"},
    {"bit 17 (PSE36)","4 MB PDE bits 16...13, CR4.PSE"},
    {"bit 18 (PSN)","PSN (see standard level 0000_0003h), MISC_CTL.PSND #1"},
    {"bit 19 (CLFL)","CLFLUSH"},
    {"bit 20","reserved"},
    {"bit 21 (DTES)","Debug Trace and EMON Store MSRs"},
    {"bit 22 (ACPI)","THERM_CONTROL MSR"},
    {"bit 23 (MMX)","MMX"},
    {"bit 24 (FXSR)","FXSAVE/FXRSTOR, CR4.OSFXSR"},
    {"bit 25 (SSE)","SSE, MXCSR, CR4.OSXMMEXCPT, #XF"},
    {"bit 26 (SSE2)","SSE2, MXCSR, CR4.OSXMMEXCPT, #XF"},
    {"bit 27 (SS)","selfsnoop"},
    {"bit 28 (HTT)","Hyper-Threading Technology, PAUSE"},
    {"bit 29 (TM1)","MISC_ENABLE.TM1E THERM_INTERRUPT and THERM_STATUS MSRs xAPIC thermal LVT entry "},
    {"bit 30 (IA-64)","IA-64, JMPE Jv, JMPE Ev"},
    {"bit 31 (PBE)","Pending Break Event, STPCLK, FERR#, MISC_ENABLE.PBE"}
};

void cpuid()
{
    ui32 eax,ebx,ecx,edx;
    asm volatile
    (
        "movl $0,%%eax\n\t"
        "cpuid\n\t"
        :"=a"(eax),"=b"(ebx),"=c"(ecx),"=d"(edx)
    );
    max_cpuid_level=eax;
    for(int i=0;i<4;++i)
        vendor[0+i]=(ebx>>(8*i))&0xFF;
    for(int i=0;i<4;++i)
        vendor[4+i]=(edx>>(8*i))&0xFF;
    for(int i=0;i<4;++i)
        vendor[8+i]=(ecx>>(8*i))&0xFF;
    asm volatile
    (
        "movl $1,%%eax\n\t"
        "cpuid\n\t"
        :"=a"(eax),"=b"(ebx),"=c"(ecx),"=d"(edx)
    );
    model=eax;
    brand=ebx;
    feat0=ecx;
    feat1=edx;
}

int main()
{
    //if(test_cpuid_present())
    if(true) // 64-bit CPU here. 
    {
        cpuid();
        printf("Maximum supported standard level: %u\n",max_cpuid_level);
        printf("Vendor ID string:");
        for(int i=0;i<12;++i) putc(vendor[i],stdout);
        printf("\n");
        printf("Processor type/family/model/stepping: %u\n",model);
        printf("  Extended family: %u\n",(model>>20)&0xFF);
        printf("  Extended model: %u\n",(model>>16)&0x0F);
        printf("  Type: %u\n",(model>>12)&0x03);
        printf("  Family: %u\n",(model>>8)&0x0F);
        printf("  Model: %u\n",(model>>4)&0x0F);
        printf("  Stepping: %u\n",(model>>0)&0x0F);
        printf("Brand ID/CLFLUSH/CPU count/APIC ID: %u\n",brand);
        printf("  Brand ID: %u\n",(brand>>0)&0xFF);
        printf("  CLFLUSH: %u\n",(brand>>8)&0xFF);
        printf("  CPU count: %u\n",(brand>>16)&0xFF);
        printf("  APIC ID: %u\n",(brand>>24)&0xFF);
        printf("Feature flags, part 0: %u\n",feat0);
        for(int i=0;i<32;++i)
            printf("  %s %s\n",(feat0&(1<<i))?"+ (yes)":"  (no)",flag_names0[i][0]);
        printf("Feature flags, part 1: %u\n",feat1);
        for(int i=0;i<32;++i)
            printf("  %s %s\n",(feat1&(1<<i))?"+ (yes)":"  (no)",flag_names1[i][0]);
    }
    else
    {
        printf("No CPUID support detected.\n");
    }
    return 0;
}

void getCPUInfo()
{
 
#ifdef _WIN32
 
   #include <intrin.h>
 
   // Get extended ids.
   int CPUInfo[4] = {-1};
   __cpuid(CPUInfo, 0x80000000);
   unsigned int nExIds = CPUInfo[0];
 
   // Get the information associated with each extended ID.
   char CPUBrandString[0x40] = { 0 };
   for(unsigned int i=0x80000000; i<=nExIds; ++i)
   {
       __cpuid(CPUInfo, i);
 
       // Interpret CPU brand string and cache information.
       if  (i == 0x80000002)
       {
           memcpy( CPUBrandString, CPUInfo, sizeof(CPUInfo));
       }
       else if(i == 0x80000003)
       {
           memcpy( CPUBrandString + 16, CPUInfo, sizeof(CPUInfo));
       }
       else if(i == 0x80000004)
       {
           memcpy(CPUBrandString + 32, CPUInfo, sizeof(CPUInfo));
       }
   }
 
#elif _linux_
 
   #include <string>
   #include <iostream>
   #include <fstream>
   #include <sstream>
 
   std::string line;
   std::ifstream finfo("/proc/cpuinfo");
 
   while(getline(finfo,line))
   {
       std::stringstream str(line);
       std::string itype;
       std::string info;
 
       if (getline( str, itype, ':' ) && getline(str,info) && itype.substr(0,10) == "model name")
       {
          std::cout << "CPU: " << info << std::endl;
          break;
       }
   }
   ////////////////////////////OR
   /*
   #include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int main()
{
    FILE *hand;
    char     outstr[FILENAME_MAX], *tmp;
    
    outstr[FILENAME_MAX-1]=0;
    hand=popen("cat /proc/cpuinfo | grep name","r");
    
    if(hand==NULL)
        {perror("Can`t open shell process:");
         return -1;
        }
 
   fgets(outstr,FILENAME_MAX-1,hand);
   
   tmp=strchr(outstr,':');
   if(tmp == NULL)
   {puts("Damn, format /proc/cpuinfo unrecognized");
   fclose(hand);
   return -2;}
   
   tmp++;
 
   if(tmp == NULL)
   {puts("Damn, format /proc/cpuinfo unrecognized");
   fclose(hand);
   return -2;}
 
   tmp++;
 
   if(tmp == NULL)
   {puts("Damn, format /proc/cpuinfo unrecognized");
   fclose(hand);
   return -2;}
 
   
   puts(tmp);
   
   fclose(hand);
 return 0;
}

///////////////////////////or
#include <stdio.h>
#include <stdlib.h>
 
int main(int argc, char **argv)
{
   FILE *cpuinfo = fopen("/proc/cpuinfo", "rb");
   char *arg = 0;
   size_t size = 0;
   while(getdelim(&arg, &size, '\n', cpuinfo) != -1)
   {
      printf("%s", arg);
   }
   free(arg);
   fclose(cpuinfo);
   return 0;
}
   */
   
   ////////////////////////CPUID
   /*

#include <cstdio>
#include <cstdint>
#include <iostream>

   #ifdef _WIN32

//  Windows
#define cpuid(info, x)    __cpuidex(info, x, 0)

#else

//  GCC Intrinsics
#include <cpuid.h>
void cpuid(int info[4], int InfoType){
    __cpuid_count(InfoType, 0, info[0], info[1], info[2], info[3]);
}



#endif

int main()
{
bool HW_MMX;
bool HW_x64;
bool HW_ABM;      // Advanced Bit Manipulation
bool HW_RDRAND;
bool HW_BMI1;
bool HW_BMI2;
bool HW_ADX;
bool HW_PREFETCHWT1;

//  SIMD: 128-bit
bool HW_SSE;
bool HW_SSE2;
bool HW_SSE3;
bool HW_SSSE3;
bool HW_SSE41;
bool HW_SSE42;
bool HW_SSE4a;
bool HW_AES;
bool HW_SHA;

//  SIMD: 256-bit
bool HW_AVX;
bool HW_XOP;
bool HW_FMA3;
bool HW_FMA4;
bool HW_AVX2;

//  SIMD: 512-bit
bool HW_AVX512F;    //  AVX512 Foundation
bool HW_AVX512CD;   //  AVX512 Conflict Detection
bool HW_AVX512PF;   //  AVX512 Prefetch
bool HW_AVX512ER;   //  AVX512 Exponential + Reciprocal
bool HW_AVX512VL;   //  AVX512 Vector Length Extensions
bool HW_AVX512BW;   //  AVX512 Byte + Word
bool HW_AVX512DQ;   //  AVX512 Doubleword + Quadword
bool HW_AVX512IFMA; //  AVX512 Integer 52-bit Fused Multiply-Add
bool HW_AVX512VBMI; //  AVX512 Vector Byte Manipulation Instructions

int info[4];
cpuid(info, 0);
int nIds = info[0];

cpuid(info, 0x80000000);
unsigned nExIds = info[0];

//  Detect Features
if (nIds >= 0x00000001){
    cpuid(info,0x00000001);
    HW_MMX    = (info[3] & ((int)1 << 23)) != 0;
    HW_SSE    = (info[3] & ((int)1 << 25)) != 0;
    HW_SSE2   = (info[3] & ((int)1 << 26)) != 0;
    HW_SSE3   = (info[2] & ((int)1 <<  0)) != 0;

    HW_SSSE3  = (info[2] & ((int)1 <<  9)) != 0;
    HW_SSE41  = (info[2] & ((int)1 << 19)) != 0;
    HW_SSE42  = (info[2] & ((int)1 << 20)) != 0;
    HW_AES    = (info[2] & ((int)1 << 25)) != 0;

    HW_AVX    = (info[2] & ((int)1 << 28)) != 0;
    HW_FMA3   = (info[2] & ((int)1 << 12)) != 0;

    HW_RDRAND = (info[2] & ((int)1 << 30)) != 0;
}
if (nIds >= 0x00000007){
    cpuid(info,0x00000007);
    HW_AVX2   = (info[1] & ((int)1 <<  5)) != 0;

    HW_BMI1        = (info[1] & ((int)1 <<  3)) != 0;
    HW_BMI2        = (info[1] & ((int)1 <<  8)) != 0;
    HW_ADX         = (info[1] & ((int)1 << 19)) != 0;
    HW_SHA         = (info[1] & ((int)1 << 29)) != 0;
    HW_PREFETCHWT1 = (info[2] & ((int)1 <<  0)) != 0;

    HW_AVX512F     = (info[1] & ((int)1 << 16)) != 0;
    HW_AVX512CD    = (info[1] & ((int)1 << 28)) != 0;
    HW_AVX512PF    = (info[1] & ((int)1 << 26)) != 0;
    HW_AVX512ER    = (info[1] & ((int)1 << 27)) != 0;
    HW_AVX512VL    = (info[1] & ((int)1 << 31)) != 0;
    HW_AVX512BW    = (info[1] & ((int)1 << 30)) != 0;
    HW_AVX512DQ    = (info[1] & ((int)1 << 17)) != 0;
    HW_AVX512IFMA  = (info[1] & ((int)1 << 21)) != 0;
    HW_AVX512VBMI  = (info[2] & ((int)1 <<  1)) != 0;
}
if (nExIds >= 0x80000001){
    cpuid(info,0x80000001);
    HW_x64   = (info[3] & ((int)1 << 29)) != 0;
    HW_ABM   = (info[2] & ((int)1 <<  5)) != 0;
    HW_SSE4a = (info[2] & ((int)1 <<  6)) != 0;
    HW_FMA4  = (info[2] & ((int)1 << 16)) != 0;
    HW_XOP   = (info[2] & ((int)1 << 11)) != 0;
}
    
    std::cout << HW_SSE3 << '\n';
    return 0;
}

   */
   
#endif
 
}

to convert dec to hex: divide dec by 16
to convert hex to dec: multiply each digit by 16 in power of "digit position from right - 1"
to convert dec to bin: divide dec by 2, or add the powers of two (use the greatest avialable)
to convert bin to hex: work with each digit separately - 4 bits is one hex-value
to convert bin to dec: add the powers of two

ASM:
регистр флагов Intel хранит вещи. флаг Z поднимается, когда результат операции равен нулю.
флаг C это флаг переноса, ставится, когда есть перенос в старший разряд.
в него записывается самый старший бит в 33-ем разряде бит, не поместившийся в 32-битном регистре
флаг O - переполнение
флаг S - изменение знака суммы (1для отрицательного значения, 0 для положительного)


пробегать по координатам игрока\на 32 (все это скастить к инту)
и потом уже смотреть по массиву с этим элеметом

координаты коровы:
идет вниз: 4 тайла, юзать IntRect
7, 75, 51, 54
для анимации мутить +65

движение

правила написания класса (от пысов):
еще класс предваряется буквой C и дальше имя с большой буквы CSomeShit
(в имени класса с большой буквы, в имени метода - с маленькой)
class SomeShit { // Скобки здесь
private:
	тип						NAME (6 табов)
	отступ при другом уровне доступа
protected:
	тип				имя(3 таба)				сигнатура()(4 таба)
отделять private-члены от private-методов
	
объект класса VIEW нужно обновлять в бесконечном цикле с помощью
_window.setView(_view);
а то я тупил час, пока не додумался (уже подумывал, что я не аля улю)	
	
в классе, где есть спрайты нужно мутить (ГАВНО!!!!)
с помощью включения объект Texture, Image и Sprite
иначе нихера не будет работать, наверное потому, что
Image и Texture удаляются, так как являются временными
(я туп)
	
	
можно объявить чистый виртуальный деструктор для класса и определить его, чтобы его наследники
могли вызывать его при удалении части базового класса	
	


прочесть надо:
Страуструп, Саттер, Майерс, Александресску (после Джоссатиса), Макконнелл
Липпман

в struct члены без m_, но указатели с префиксом p_
и табы не обязателньно выравнивать по одному столбцу в функциях. 1-2 таба достаточно
особенно дело касается вложенных областей видимости
		
STRUCTS INSIDE functions
// In some header
class Base
{
public:
    virtual ~Base() {}
    virtual void DoStuff() = 0;
};

Base* CreateBase( const Param& );

// in some .cpp file
Base* CreateBase( const Params& p )
{
    struct Impl: Base
    {
        virtual void DoStuff() { ... }
    };

    ...
    return new Impl;
}


#include <iostream>
using namespace std;

class C {
public:
  C(int x) : mData(x)  {}
  int method() { return mData; }
  // ...
private:
  int mData;
};

void f() {

  // Here I am in f.  I need an array of 50 C objects starting with C(22)

  class D : public C {
  public:
    D() : C(D::clicker()) {}
  private:
    // I want my C objects to be initialized with consecutive
    // integers, starting at 22.
    static int clicker() { 
      static int current = 22;
      return current++;
    } 
  };

  D array[50] ;

  // Now I will display the object in position 11 to verify it got initialized
  // with the right value.  

  cout << "This should be 33: --> " << array[11].method() << endl;

  cout << "sizodf(C): " << sizeof(C) << endl;
  cout << "sizeof(D): " << sizeof(D) << endl;

  return;

}

int main(int, char **) {
  f();
  return 0;
}

type traits
//template <typename T>
//struct is_swappable {
//    static const bool value=false;
//};
//
//template <>
//struct is_swappable<short> {
//    static const bool value=true;
//};
//
//template <>
//struct is_swappable<unsigned short> {
//    static const bool value=true;
//};

#include <type_traits>
template<typename T>
struct is_swappable {
    static const bool value =std::is_integral<T>::value&&sizeof(T)>=2;
};


template <typename T>
T Swap(T val)
{
    static_assert(is_swappable<T>::value,"VALUE ERROR");
    unsigned char* bytes=reinterpret_cast<unsigned char*>(&val);
    for(size_t i={0}; i<sizeof(T); i+=2) {
        unsigned char c =bytes[i];
        bytes[i]        =bytes[i+1];
        bytes[i+1]      =c;
    }

    return val;
}



template <typename T>
class elem_traits {
    public:
     typedef const T& arg_type;
     typedef       T& reference;
     typedef const T& const_reference;
};
//specialization for char
template <>
class elem_traits<char> {
    public:
     typedef const char  arg_type; // определили тип, который передает по значению типы char
     typedef       char& reference;
     typedef const char& const_reference;
};

// but it's better to use inheritance
class char_elem_traits : public elem_traits<char> {
 public:
  typedef char& arg_type; // определили тип, который передает по ссылке типы char

  // типы reference и const_reference наследуются
};

// use constant traits
template <typename T>
struct x_traits {
 static std::size_t T2 = sizeof(T) * 4;
 static std::size_t T3 = sizeof(T) * 2;
 static std::size_t T4 = sizeof(T);
};


// we can't take the address of ENUM-constant
template <typename T>
struct x_traits {
 enum { T2 = sizeof(T) * 4 };
 enum { T3 = sizeof(T) * 2 };
 enum { T4 = sizeof(T)      };
};

// if we need a double type

 static double T5() {
  return(sizeof(T) * 5 / 7);
 }
template <typename T, typename traits = x_traits<T> >
class X {
  // используем нужные константы через traits:
  // traits::T2 == sizeof(T) * 4
  // traits::T4 == sizeof(T)
};




// some temolate <typename T, typename traits = elem_traits<T> >
some class
/*
     typedef T                                value_type;
     typedef typename traits::arg_type        arg_type;
     typedef typename traits::reference       reference;
     typedef typename traits::const_reference const_reference;
*/

		
		
		void _Trim  (char* tgt)
{
    char        *p;
    size_t      c={0};
    size_t      slen={strlen(tgt)};
    while(0!=(p=_FindTrimChr(tgt))) {
        while(p[++c]<=' '&&p[c]!=0) {
            //if(p[c]==0) { std::cout<<"p[c]==0!\n"; }
        }
        //std::cout<<"P[c] = " << p[c] <<", C = " << c<<'\n';
        //std::cout<<"Found " << c <<"spaces together!\n";
        strcpy(p,(p+c));

        p[slen-c-1]=0;
        c=0;
        //std::cout<<"TGT len = "<<strlen(tgt)<<", P len="<<strlen(p)<<'\n';
       // std::cout<<"TGT ch = "<<tgt[0]<<", P len = "<<p[0]<<'\n';
        //std::cout <<tgt;
       // getch();
        // std::cout <<'\n';
    }

//    while(0!=(p=strchr(tgt,'\t'))) {
//        while(p[++c]=='\t');
//        //std::cout<<"Found " << c <<"spaces together!\n";
//        strcpy(p,(p+c));
//        p[slen-c]=0;
//        c=0;
//        //std::cout<<"TGT IS NOW: "<<tgt<<'\n';
//        //getch();
//    }
}
		
/*
void load(pcstr section, pcstr filename)
{
	float flt_from_ltx=Inifile{filename}::r_float(section, "float_value");
	// a t o i
}
*/
 int		    	_GetItemCount			( LPCSTR , char separator=',');
 LPSTR	    		_GetItem				( LPCSTR, int, LPSTR, u32 const dst_size, char separator=',', LPCSTR ="", bool trim=true );

template <int count>
inline LPSTR _GetItem( LPCSTR src, int index, char (&dst)[count], char separator=',', LPCSTR def="", bool trim=true )
{
	return	_GetItem(src,index,dst,count,separator,def,trim);
}

 LPSTR	    	_GetItems				( LPCSTR, int, int, LPSTR, char separator=',');
 LPCSTR	    	_SetPos					( LPCSTR src, u32 pos, char separator=',' );
LPCSTR	    	_CopyVal				( LPCSTR src, LPSTR dst, char separator=',' );
LPSTR	    	_Trim					( LPSTR str );
LPSTR	    	_TrimLeft				( LPSTR str );
LPSTR	    	_TrimRight				( LPSTR str );



		
***[Shell]*** OTHER BULLSHIT
---------------------------
интристики
to read with the cup of hot coffee in hand:

http://www.gotw.ca/publications/mill22.htm

https://msdn.microsoft.com/en-us/library/windows/desktop/ms681381(v=vs.85).aspx

http://www.vsokovikov.narod.ru/New_MSDN_API/Error_handling/fn_formatmessage.htm
https://habrahabr.ru/post/149116/

http://www.cyberforum.ru/win-api/thread894941-page2.html

https://www.viva64.com/ru/a/0004/

http://evgeny-lazin.blogspot.com/2008/08/blog-post.html -- CRITICAL_SECTIONs

*   http://www.gamedev.ru/code/forum/?id=137434 - про filesystem
*	http://vsokovikov.narod.ru/New_MSDN_API/Menage_files/create_name_mem.htm МЕМОРИ МАНАДЖЕМЕНТ
http://eax.me/winapi-file-mapping/
http://wm-help.net/books-online/book/59464/59464-10.html
* 	про интерфейсы https://msdn.microsoft.com/ru-ru/library/50h7kwtb.aspx
* 	typename keyword in templates
	https://stackoverflow.com/questions/642229/why-do-i-need-to-use-typedef-typename-in-g-but-not-vs
*	https://stackoverflow.com/questions/390615/finally-in-c
*	http://www.interface.ru/home.asp?artId=23057
*	https://msdn.microsoft.com/ru-ru/library/0603949d.aspx
*	http://www.cyberforum.ru/cpp-beginners/thread929964.html
*	https://msdn.microsoft.com/ru-ru/library/k13k85ky.aspx
*	http://www.c-cpp.ru/books/pragma
*	https://en.wikibooks.org/wiki/C++_Programming/Operators/Operator_Overloading#Address_of.2C_Reference.2C_and_Pointer_operators
*	https://habrahabr.ru/post/118010/
*	https://www.ibm.com/support/knowledgecenter/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/reference_collapsing.htm#reference_collapsing__suplink1
*	http://www.cyberguru.ru/cpp/cpp-exporting-cpp-classes-from-dll.html?showall=1
*	http://www.cyberforum.ru/cpp-beginners/thread1237768.html
*	https://blogs.msdn.microsoft.com/vcblog/2008/08/28/the-mallocator/
*	https://habrahabr.ru/post/274827/
*	http://alenacpp.blogspot.ru/2005/06/vector.html
*	https://blogs.msdn.microsoft.com/reiley/2011/08/12/macro-revisited/
*	http://rjaan.narod.ru/docs/main_operations_with_types_in_cpp.html
*	https://stackoverflow.com/questions/3350852/how-to-correctly-fix-zero-sized-array-in-struct-union-warning-c4200-without
*	https://stackoverflow.com/questions/7895879/using-member-variable-in-lambda-capture-list-inside-a-member-function
*	https://msdn.microsoft.com/en-us/library/1b3fsfxw.aspx
*	https://codecraft.co/2014/11/25/variadic-macros-tricks/
*	data race
декларативное и императивное парадигмы
https://toster.ru/q/386099


https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919

*	интервью с ЯСЕНЕВЫМ http://www.gametech.ru/articles/85/
*	олесь http://proigri.blogspot.ru/2010/01/blog-post_19.html
*	олесь http://allgame-metro.ucoz.com/news/o_metro_2034_intervju_s_olesem_shishkovcovym/2011-08-28-11
*	олесь https://www.gameru.net/forum/index.php?showtopic=33323
*	сталкер интервью http://www.gamedev.ru/articles/?id=90105
http://www.moddb.com/features/stalker-interview

*	ИНТРИСТИКИ http://www.gamedev.ru/code/forum/?id=35815

	opengl http://www.gamedev.ru/code/forum/?id=200531&page=2
	http://www.gamedev.ru/code/forum/?id=34382&page=2
	https://kubuntu.ru/node/3801
	
http://www.cyberforum.ru/cpp-beginners/thread1091543.html
	
	pimpl
	http://www.gamedev.ru/code/forum/?id=188242
	
	dll
	https://stackoverflow.com/questions/21394916/trouble-importing-dll-library-into-codeblocks-linker
	
	
УСТАНОВИТЬ MINGW НА 64БИТНУЮ ВИНДУ ТУТ
https://nuwen.net/mingw.html

http://alenacpp.blogspot.ru/2005/08/c.html // casts

because my system (and processor) is 64-bit, and as such working with an 8 byte int is faster than a 4 byte one. viliml's system presumably is different.
Time wasting action is that when CPU wants to communicate with memory controller with address and
data bus. If data bus is 64-bits length, then the fastest variable that CPU can handle is a 64-bit
integer (or anything that is 64-bits long). but if data bus is not 64-bits length (e.g. 32-bits),
for transferring a 64-bit value CPU needs to do the transfer twice. This is time wasting.

//или перегрузить оператор = ?
for(FS_iterator = FS_Path{"C:\\path\\*}.begin(); 

 memset вызывается еще до вызова конструктора
 memset'ом строго говоря можно заполнять только trivial типы
 https://habrahabr.ru/company/pvs-studio/blog/239915/
 https://htrd.su/wiki/zhurnal/2013/09/18/zabavnyj_bag

 https://stackoverflow.com/questions/11438372/code-description-of-ptmalloc-implementation
 
 boost::crc_32_type
 memcmp
 
 the destructors of standard containers are not virtual.
 std::map<vector2D,tilemap>

vector< T > v;
...
T *p = &v[0];

V strogom sootvetstvii so Standartom, kod dolzhen vyglyadet' vot tak:

vector< T > v;
...
vector< T >::pointer p = &v[0];

неинициализированный указатель - не нулевой. В нем мусор
ПОЭТОМУ НАДО ВОЗВРАЩАТЬ УКАЗАТЕЛЬ ИЗ ФУНКЦИИ, А НЕ ПРОСТО ИЗМЕНЯТЬ ДАННЫЕ

memcpy ожидает размер в байтах

C\C++ keywords
	d:\Program Files\Microsoft Visual Studio 14.0\VC\include\xkeycheck.h

the style of code:
*	NO ++/-- operators in subscript operator
*	не использовать c_style casts!!!!!!!!
*	printf("%s", str ? str : "<пусто>"); - use ternar operation
*	
*** Comments ***
* comment like this
* for ( int i = 0; i < 0; ++ i )
{

} // for
// if block is large then use
	// for ( int i = 0; i < 0; ++i )
	
while (n --> 0)
        printf("%d\n", groups[n]);
// (void) i; // без этой строчки будет warning в оптимизированной версии
если надо менять объект, на который ссылаться - поинтер
со ссылкой такое не проканает
void fp(char*p)
{
	while(*p)
		std::cout << ++*p;
}		
		
void fp2(char& r)
{
	char*p=&r; // get a pointer to the object referred to
	while(*p)
		std::cout << ++*p;
}		

если знать, что объект никогда не будет ссылаться на другой - референсе
template <class T> class Proxy { // proxy refers to the object with which it is initialized
	T& m;
public:
	Proxy(T& mm) : m{mm} {}
};

template <class T> class Handle { // handle refers to its current object
	T* m;
public:
	Proxy(T* mm) : m{mm} {}
	void rebind(T* mm) {m=mm;}
};

если использовать перегруженный оператор - ссылки
Matrix operator+(const Matrix&, const Matrix&); //ok
Matrix operator-(const Matrix&, const Matrix*); // error: no user-defined argument

Matrix y,z;
//...
Matrix x = y+z; // ok
Matrix x2 = &y + &z; // error and ugly

// if a collection of something is needed, use a pointer:
int x,y;
string& a1[] = {x,y}; // error: array of references
string* a2[] = {&x,&y}; // ok

// if NO value  notation is needed, a pointer offers nullptr, references don't offer that
void fp(X* p)
{
	if(p==nullptr) {
		//no value
	}
	else {
		// use *p
	}
}
		
if, while, case - statement (инструкция)
+,-,sizeof() 	- operator (операция, оператор)
conversion		- пеобразования
cast			- приведение
::				- оператор разрешения области видимости		
		
// по 3 таба до имени переменной или инициализации, сигнатуре. пробел между переменной и 
//	синтаксической конструкцией и после нее, нет пробелов в for между мат.операторами

it's really dangerous to export functions with std::string as parameters

Minor:
		............
Major:
		............

lvalue

int i=0;
int&const icr=i; // const here makes no sence, you
const int& h = i;
To find out what the above declaration means, read it right-to-left: “x is a const reference to a X”.
But that is redundant — references are always const, in the sense that you can never reseat a
reference to make it refer to a different object. Never. With or without the const.

In other words, “X& const x” is functionally equivalent to “X& x”. Since you’re gaining nothing by
adding the const after the &, you shouldn’t add it: it will confuse people — the const will make
some people think that the X is const, as if you had said “const X& x”.

We use a const lvalue reference to prevent modification of an argument. 
Oterwise, we use a rvalue reference

lvalue:
	Имя переменной или аргумента (даже если их тип rvalue-ссылка). Например std::cin.
	Вызов функции или оператора, тип возвращаемого значения которых является lvalue-ссылкой. Например std::cout << 1, ++it.
	Строковые литералы, например "Hello, world!".
rvalue:
	Нестроковый литерал, например 42, true, nullptr.
	Вызов функции или оператора, тип возвращаемого значения которых не является ссылочным
	Взятие адреса: &a.
	Вызов функции или оператора, тип возвращаемого значения которых является rvalue ссылкой. Например std::move(x).
	a.m, где a — rvalue.
	
 rvalue разбилась на две категории xvalue (eXpiring lvalue) и prvalue (pure rvalue).
 А lvalue вместе с xvalue стала называться glvalue (generalized lvalue)
К xvalue относятся следующие выражения:
Вызов функции или оператора, тип возвращаемого значения которых является rvalue-ссылкой.
	Например std::move(x).
	a.m, где a — rvalue.
 Выражение xvalue, хотя и является rvalue, но имеет некоторые свойства lvalue, например,
 оно может быть полиморфным
 
  Правила простые (в порядке убывания приоритета):

В первую очередь, подобное стремится к подобному (горизонтальные стрелки).
Константный вариант тоже подойдет.
И если все остальные варианты отсутствуют, то тип const T& будет рад всем выражениям.
Для VS: не забываем про неконстантные ссылки на rvalue (пунктирная стрелка).
Pimpl (pointer to implementation).

 
не надо модифицировать переменную больше одного раза между
двумя точками следования, поскольку это может привести к весьма неожиданным последствиям.
Неспецифицированное поведение!!!!
i = ++i; // undefined behavior, переменная модифицируется дважды 
i = i + 1; // все в порядке
i ? i=1 : i=5; // все в порядке (там, где знак ? есть точка следования, а потом выполнится лишь одно из выражений)
i=1; i++; // все в порядке (после каждого выражения находится точка следования)
i=1, i++; // все в порядке (на операторе запятая находится точка следования)

to get along with......

http://www.gamedev.ru/industry/forum/?id=11063
https://msdn.microsoft.com/ru-ru/library/ms182372.aspx

C++ поддерживает множественное наследование и абстрактные классы, поэтому отдельная синтаксическая
конструкция для интерфейсов в этом языке не нужна.
Интерфейсы определяются при помощи абстрактных классов, а реализация интерфейса производится путём
наследования этих классов.
Благодаря наличию множественного наследования, ничто не мешает реализовать в одном классе несколько
интерфейсов, если в этом есть необходимость

ESP - расширенный регистр указателя стека. С помощью этого регистра происходит обращение к данным, хранящимся в стеке. Пример использования:

      mov eax,[esp+0C]

EBP - расширенный регистр указателя стекового фрейма. Обычно используется при вызове функций для указания на аргументы функции и для ссылок на локальные переменные. Пример использования:

proc DialogProc ; HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam
      mov eax,[ebp+08] ; mov eax,hDlg
      mov eax,[ebp+0C] ; mov eax,uMsg
      mov eax,[ebp+10] ; mov eax,wParam
      mov eax,[ebp+14] ; mov eax,lParam
;...
endp

EIP - регистр указателя команд. Содержит адрес команды, которая будет выполнена следом за текущей. Напрямую используется довольно редко. Один из вариантов использования - при работе с функцими DebugApi для управления отлаживаемой программой. Или вот еще пример самой маленькой программы (2 байта), намертво вешающей Win9х:

      jmp eip ; бесконечный цикл

ESI - расширенный индексный регистр источника. Используется для быстрой пересылки данных из одной области памяти в другую. Пример использования:

      array rb 4
      ; ...
      mov esi,array
      mov al,byte [esi]
      mov ax,word [esi]
      mov [esi],eax


call convention
; F(A,B,C,D)

_cdecl: ; прямой порядок расположения данных на стеке
        ; обратный по времени способ запихивания
        ; допускает переменное число параметров
        ; поскольку стек очищает тот, кто вызвал функцию
  push D
  push C
  push B
  push A
  call F
  ; ret
  inc esp, 16  ; очистка стека здесь

_stdcall: ; порядок данных - тот же самый
          ; но стек очищает функция
          ; поэтому число параметров фиксировано
  push D
  push C
  push B
  push A
  call F
  ; ret 16 ; очистка стека - в функции

_fastcall: ; аналогично stdcall, но два первых параметра передаются через регистры
  push D
  push C
  mov edx, B
  mov eax, A
  call F
  ; ret 8 ; очистка стека - в функции

_pascal: ; обратный порядок данных на стеке, прямой порядок запихивания
         ; поэтому число параметров фиксировано, и следовательно, стек очищает функция
  push A
  push B
  push C
  push D
  call F
  ; ret 16

  cdecl.org
  

если че то не компилится, то проверь:
1. при наследовании, часть базового класса должна инициализироваться в списке
инициализации, а не где-то еще.
2. при динамическом выделении памяти для строки смотреть аргументы у strlen
3. при дружественных функциях-членах при обращении к члену из дружественного
метода тупой компилятор пишет, что она типа inaccessible, но это не так.
4. inline методы нужно объявлять исключительно в *.h файле, а не в *.cpp, иначе
линковщик выдаст ошибку
5. проверить аргументы функции (особенно по-умолчанию)
6. при использовании объектов std::string в качестве агрументов добавлять
квалификатор const
7. при наследовании не забывать про виртуальный деструктор
8. не забывать про break в switch
9. смотреть на имена членов, ну там, если например метод принимает аргумент, как в случае с
Remote- и TV-классами, кто знает, тот поймет меня.
10. задание номер 4 из главы 15 :
	catch (Sales::bad_index & bad)
	{
		try {
			LabeledSales::nbad_index& nbad = dynamic_cast<LabeledSales::nbad_index&>(bad);
			cout << nbad.what();
			cout << "company: " << nbad.label_val() << '\n';
			cout << "bad index: " << nbad.bi_val() << endl;
		}
		catch (std::bad_cast&) // не удалось выполнить dynamic_cast, т.е. bad не является LabeledSales::nbad_index
		{
			cout << bad.what();
			cout << "bad index: " << bad.bi_val() << endl;
		}
	}

заметка про исключения: VS C++ их не поддерживает нормально,
но чтобы указать, что исключений нет, в целях оптимизации можно добавить
__declspec(nothrow). Example: void __declspec(nothrow) stupidAss()
или throw() в конце.

Как-будто ты пришла и ... осталась. Вернее ушла, но что-то оставила. Вернее как будто неправильно, что ушла. Должна была прийти и остаться, а то что ушла - недоразумение. Блин, опять не так. Как будто тебя нет, а на самом деле должна быть. Вернее есть. Но не здесь. А быть должна тут. Вот. В общем, тебя не хватает, хотя не хватать не может, потому что не было. Парадокс. © Gavrosh

заметка про интеллектуальные указатели: нельзя делать такой херни:
string shit("I'm so stupid");
shared_ptr<string> p_shit(&shit);
потому что при удалении p_shit его деструктор попытается удалить shit,
и получится memory leak или другая ошибка

еще одна: чтобы разыменовать, используем * (а то забываю постоянно)
в интеллектуальных указателях запрещено неявное преобразование
unique_ptr может разрешить присваивание, если присваемый объект - временный
библиотечная функция move разрешает присваивание объектов, так как
она возвращает временный объект, являющийся копией, переданного в качестве
формального параметра
unique_ptr может использовать массив:
unique_ptr<double[]>pda(new double(5));

ctor - конструктор

для различения префиксной и постфиксной версий операторов ++ для
префиксной функция без аргументов, для постфиксной - с безымянном int-ом

STL:
1. в STL вместо begin и end лучше использовать for_each или range-based for
2. диапазон определяется так [итератор1 - начало; итератор2 - элемент, следующий за концом)
3. для сортировки в STL надо определять автономную функцию сравнения (которая не является членом класса)
или определять метод операции < в классе. вторая версия sort принимает три аргумента: начало, конец
и функтор (указатель на функцию в частном случае). функция возвращает bool и называется как угодно
и принимает два параметра (как и friend operatorчтото)

виды итераторов:
1. входной
	1)используется для чтения из контейнера
	2)алгоритмы не могут изменять значение входных итераторов
	3)имеет доступ ко всем элементам (операция ++ pre- и post-фиксная форма)
	4)он однопроходный, не должен зависеть от значения итераторов из прошлого прохода, или прошлых значений итератора
	5)он однонаправленный - можно инкрементировать, но нельзя возвращать в предшествующее состояние
	
2. выходной
	1)используется для записи значения контейнера, но не для чтения (как объект cout см. стр. 909)
	2)те же пункты, что и для входного за исключением пункта 1
	
3. однонаправленный
	1)использует только операцию ++ для поэлементного доступа
	2)проход всегда выполняется в одном и том же порядке (для многопроходных алгоритмов)
	3)после инкрементирования данного итератора можно гарантированно получить предыдущее значение
	4)используется и для записи, и для чтения(int* pirw; <-- для записи и чтения; const int* pit; <-- read only)
	
4. двунаправленный
	1)использует операцию -- для обратного прохода
	2)те же пункты, что и для однонаправленного
	
5. произвольного доступа
	1)доступ к произвольному элементу, без считывания предыдущих
	2)имеет операции сложения с указателями (iterator + 1) для доступа и операции отношения для упорядочения элементов
	3)те же пункты, что и для двунаправленного
	
адаптер - класс или функция, которая преобразует какой-то другой интерфейс в интерфейс, используемый в STL
(пример - ostream_iterator из STL, который явдяется моделью концепции выходного итератора)

концепция - набор требований (например, для итераторов или для контейнеров) (концепция входного итератора и т.д)

уточнение - концептуальное наследование (например, при наследовании встроенного указателя двунаправленным итератором)
двунаправленный итератор является  уточнением однонаправленного итератора

модель - конкретная реализация концепции. Так, указатель на целое число  - это модель концепции итератора произвольного доступа

Итераторы входного\выходного потока - std::istream_iterator<тип элемента, тип входного потока>(используемый входной поток (std::cin), std::ostream_iterator<тип элемента, символьный тип выходного потока>(используемый выходной поток (std::cout, std::cerr), разделитель ("\n", " ") 
Другие итераторы:
reverse_iterator - обратный итератор. Инкремент этого итератора вызывает его декремент (для вывода в обратном порядке, например).
Пользуемся методами rbegin() и rend().
Запомнить:
И rbegin(), и end(), как и rend() и begin(), возвращают одно и то же значение, но разного типа (reverse_iterator и iterator)

back_insert_iterator - вставляет (а не копирует) элементы, выделяя память, в конец контейнера
front_insert_iterator - вставляет элементы, выделяя память, в начало контейнера
insert_iterator - вставляет элементы, выделяя память, перед позицией, указанной в конструкторе
Ограничения: back_insert_iterator может использоваться только с контейнерами, позволяющими осуществлять
быструю в ставку (т.е за постоянное время) в конец
front_insert_iterator может использоваться только с контейнерами, позволяющими осуществлять
быструю в ставку (т.е за постоянное время) в началл

insert_iterator не имеет этих ограничений и его можно использовать для вставки элементов, а не копирования,
но, если доступны front\back итераторы, то лучше использовать их, т.к они производят вставку быстрее

Концепции контейнера - это общие категории с названиями наподобие контейнер, последовательный контейнер,
ассоциативный контейнер.
Типы контейнеров - это шаблоны, которые можно применять для создания специфических объектов-контейнеров.

Сложность - время, необходимое для выполнения операции. Встречаются 3 возможных обозначения (по возрастанию)
а) время компиляции - действие выполняется во время компиляции и не требует времени при выполнении
б) постоянная - операция происходит во время выполнения, но не зависит от кол-ва элементов в объекте
в) линейная - время операции пропорционально кол-ву объектов (надо обращаться к каждому объекту). Самый нехороший способ.


к адресам элемента массива обращаться можно так: &mass[0] и mass, &mass[5] и mass + 5

если возвращаем ссылку, значит возвращенный объект не временный!

в определении дружественной функции не нужно указывать, какому классу она является другом!

шаблоны объявляем только за пределами функции (а не в main, you dumbass)

sizeof это оператор, возвращающий size_t
как получить размер массива: sizeof array / sizeof array[0]

Функторы
Функтор это объект, который может использоваться с операцией (), как функция.
Пример:
class Linear
{
private:
	double slope;
	double y0;
public:
	Linear(double s1_ = 1, double y_ = 0) : slope(s1_), y0(y_) {;}
	double operator()(double x) {return y0 + slope * x;}
};
Использование:
Linear f1;
Linear f2(2.5, 10);
double y1 = f1(12.5); // <-- f1.operator()(12.5) in right. Vals: 0 + 1 * 12.5
double y2 = f2(0.4); // Vals: 10.0 + 2.5 * 0.4;

Концепции функторов:
1)Генератор - функтор, который может вызываться без аргументов
2)Унарная функция - функтор, который может вызываться с одним аргументом
3)Бинарная функция - функтор, который может вызываться с двумя аргументами

Уточнения:
1)Унарная функция, возвращающая булевское значение - предикат
1)Бинарная функция, возвращающая булевское значение - бинарный предикат

Адаптируемые функторы и функциональные адаптеры:
Встроенные функторы STL являются адаптируемыми. Адаптируемыми их делает тот факт, что они используют
члены typedef, указывающие типы их аргументов (first_argument_type, second_argument_type)
и тип возвращаемых значений (result_type).
Важность адаптируемости функтора в том, что тогда он может применяться объектами функционального
адаптера, который исходит из существования этих typedef. Так, адаптируемый функтор может использовать
член result_type для объявления переменной, соответствующей возвращаемому типу функции.
Классы, которые преобразуют адаптируемые бинарные функции в адаптируемые унарные функции - binder1st,
binder2nd.
Пример:
binder1st(f2, val) f1;
Тогда f1(x) становится эквивалентной f2(val, x). Различие в том, что f1 - унарная, а f2 - бинарная ф-ия.
Такое можно делать только с адаптируемыми функциями.
Упрощенный класс bind1st
bind1st(multiplies<double>(), 2.5);
Так можно умножить каждый элемент контейнера на 2.5
transform(gr8.begin(), gr8.end(), out_iterator, bind1st(multiplies<double>(), 2.5);

Алгоритмы:
Группы алгоритмов:
1)Немодифицирующие последовательные операции(find, for_each)
2)Модифицирующие последовательные операции(transform, random_shuffle, copy)
3)Сортирующие и связанные с ними операции(sort, а также действия с наборами (set_union и т.д)
4)Обобщеннные числовые операции(сумма элементов, вычисление внутреннего произведения двух контейнеров и т.д)

Типы алгоритмов:
1) Делающие свою работу на месте(sort)
2) Копирующие(copy), к ним добавляется постфикс _copy
3) Условные(replace_if), к ним добавляется постфикс _if

Копирующие алгоритмы возвращают итератор, указывающий на позицию, следующую за последним скопированным значением


Контейнеры для работы с числами: valarray. В C++11 может использовать функции STL с помощью метода
begin(object) и end(object), возвращающий итераторы, также удобные методы slice и gslice.

Для работы с массивами - контейнер array. Поддерживает STL. Более безопасен, чем встроенный массив

Шаблон initializer_list является дополнением С++11. С его помощью можно инициализировать контейнер (и встроенные типы)
списком значений.
std::vector<double> payments {45.99, 39.23, 19.95, 89.01};
Этот оператор создает контейнер из четырех элементов и инициализирует значениями из списка инициализации.
Это возможно, потому что теперь классы имеют конструкторы, принимающие аргумент initializer_list<T>
У vector<double> есть initializer_list<double>, поэтому это объявление:
std::vector<double> payments {45.99, 39.23, 19.95, 89.01};
эквивалентно std::vector<double> payments ({45.99, 39.23, 19.95, 89.01}); <- явный вызов конструктора
Обычно, с помощью списка инициализации можно вызвать конструктор, используя нотацию {} вместо ()
shared_ptr<double> pd {new double};
Но при наличии конструктора с initializer_list, это вызывает проблемы:
std::vector<int> vi(10); // 10 неинициализированных значений
std::vector<int> vi({10}); // первый элемент установлен в 10 or std::vector<int> vi{10}
Если класс имеет конструктор с initializer_list, то будет вызван конкретный данный конструктор (случ. 2)
Элементы initializer_list должны быть одного типа, но компилятор может проводить преобразования
(например int в double, но не наоборот, т.к неявное преобразование double к int не допускается)
можно сделать так:
std::vector<int> p = { 1, 2, static_cast<int>(3.6) }; // но без статик каста не обойтись
не обязательно использовать класс initializer_list, если класс не предназначен для работы со списками
переменных размеров

class Position
{
private:
	int x,y,z;
public:
Position(int xx = 0, int yy = 0, int zz = 0);
// no initializer_list exists
}

так можно применять синтаксис {} с этим Position(int,int,int);
Position A = {20, -3} // x = 20, y = -3, z = 0;

возможно такое объявление:
std::initializer_list<double> dl = { 1.1, 2.2, 3.3, 4.4, 5.5 };
у него есть два указателя - begin и end или begin и int-кол-во элементов.
тип итераторов = const, поэтому нельзя сделать так
*dl.being() = 2011.6;
можно менять списки
dl = { 0.34, 2.2, 32.1, 4.4, 1.5 }
но цель из введение - конструкторы и аргументы

class Vector {
public:
	Vector(std::initializer_list<double>);
	void push_back(double);
};

// Vector::Vector(std::initializer_list<double> lst)
		: elem{new double[lst.size()]}, sz{lst.size()} 
{
	copy(lst.begin(), lst.end(), elem);
}
Vector read(istream& is)
{
	Vector v;
	for(double d; is >> d;)
		v.push_back(d);
	return v;
}



полезности:
передача неименованной структуры в функцию: function(struct_name{member1, member2});

Ввод, вывод и файлы.
Ввод и вывод в С++ предлагается библиотекой iostream, fstream и т.д Это не является частью языка,
как в бейсик или паскаль
Ввод и вывод программа воспринимает как потоки байтов. При вводе программа извлекает байты из входного
потока, а при выводе - помещает их в выходной поток. Для текстовых программ каждый байт может представлять
символ. В общем случае байты могут образовывать двоичное представление символов и числовых данных.
Потоки служат посредниками между программой и источником или местом нахождения потока. Таким образом,
не нужно знать, откуда идут данные. Главное просто просмотреть поток байтов. Также можно обрабатывать
вывод - т.е. не зная, куда идут байты.
Управление вводом включает две стадии:
1. Ассоциирование потока с вводом программы
2. Подключение потока к файлу
Таким образом, необходимы два подключения - по одному на сторону. Подключение со стороны файла
(или устройства, например, клавиатуры) представляет собой источник данных для потока, а подключение
со стороны программы загружает выходные данные потока в программу. Аналогично, управление выводом
предусматривает подключение выходного потока и ассоциирование некоторого выходного места назначения,
связанного с этим потоком.
Обычно вывод и ввод может более эффективно обрабатываться посредством буфера. Буфер - это блок памяти,
используемый в качестве промежуточного временного хранилища при передаче информации от устройства
в программу или из программы устройству.
Буфер из устройства в программу равен 512+ Байт. Для программы - 1 байт. Так как обращение к устройству
для считывания по 1 байту проходит медленно, чем чтение из памяти, лучше сохранить в буфер
часть данных и читать из него. При достижении конца буфера загружаем новый. Также при выводе прога
может сначала наполнять буфер, затем передавать его целиком на жесткий диск, очищая буфер для следующего
пакета выходных данных. Это называется очисткой буфера.
Клава не нуждается в буферах, так как читает по 1-му символу. Однако буферизованный ввод для клавы
обеспечивает пользователю вернуться назад и исправить ввод до того, как он будет передан в программу
Обычно прога очищает буфер при нажатии Enter. Поэтому проги не начинают обработку данных до нажатия.
При выводе на дисплей программа С++ обычно очищает выходной буфер при передаче символа новой строки.

О выводе cout: C++ интерпретирует указатель любого другого типа
как void* и выводит числовое представление адреса. Если потребуется
получить адрес строки необходимо выполнить приведение типов:
char* amount = "dozen";
cout << amount; //value
cout << (void*)amount; //adress

метод write у cout не прекращает вывод по достижении конца строки
вместо этого он тупо выводит количество символов залезая в область
памяти другой переменной!
чтобы использовать write с числовыми данными надо привести его к типу char*,
а для кол-ва символов юзать оператор sizeof

при отображении очищаем буфер у cout. также можно очистить с помощью
манипуляторов endl и flush

для отображения чисел экспоненциальная форма записи используется,
если число содержит >= 6 разрядов или <= -5 разрядов

ios_base->ios->ostream

можно менять системы счисления с помощью манипуляторов hex, dec, etc.

метод width(i) у cout устанавливает ширину поля равной i и
возвращает предыдущее значение, а функция без аргументов - 
текущее значение. метод касается только следующего отображаемого
элемента, потом устанавливается значение по умолчанию.

width() добавляет пробелы слева от значений. символ, используемый
для заполнения - символ-заполнитель. это используется для выравнивания

метод fill() меняет символ-заполнитель на указанный

метод precision() устанавливает кол-во выводимых разрядов чисел

метод setf() позволяет устанавливать флаги форматирования.
например можно сделать вывод заверщающих число нулей с помощью
флага ios_base::showpoint, который бы выводил число 2.00 не 2, а
2.00000, если по умолчанию точность равна 6

битовые флаги - программный эквивалент установки двухрядных 
(dual-in-line package, DIP) переключателей при конфигурировании
комп. оборудования. установка флага (бита) - установка его значения в 1
например, манипуляторы hex, dec и oct настраивают три битовых
флага, управляющих выбором системы счисления. очистка бита - 
установка в 0

cout.setf(ios_base::hex, ios_base::basefiled) = использование
манипулятора hex
эта версия используется для форматирования нюансов отображения,
которые управляются более чем одним битом. Первый аргумент - 
значение fmtflags, которое содержит требуемые установки. Второй
аргумент - значение, которое очищает соответствующие биты.
Так, второй аргумент очищает пакет связанных битов. Затем первый
устанавливает какое-либо значение из них в 1

метод unsetf используется для отмены эффекта от setf
прототип:
void unsetf(fmtflags mask /*<- битовый шаблон, устанавливающий
все установленные биты в 1 ставятся в 0*/)
пример:
cout.setf(ios_base::showpoint);
cout.unsetf(ios_base::showpoint);

cout.setf(ios_base::boolalpha);
cout.unsetf(ios_base::boolalpha);

режим отображения чисел с плавающей точкой не имеет флага "по умолчанию".
вместо этого форма с фиксированной точкой используется, если установлен
бит фиксированного режима (и только он), так же с научным.
любая другая комбинация ведет к активизации режима по умолчанию
установка режима по умолчанию:
cout.setf(0 /*не ставит не одного бита*/,
	ios_base::floatfield /*очистка всех битов*/)
проще однако:
cout.unsetf(ios_base::floatfield /*очищает все биты*/)
можно также очистить только один бит:
cout.unsetf(ios_base::fixed /*очищает один бит*/)
но так делать можно только если известно точно, что очищать,
а первый вариант универсальный

круче однако использовать манипуляторы, вместо setf, так как
они сами ее вызывают. например:
cout << left /*выравнивание по левому краю*/
	<< fixed /*фиксированный размер float-чисел*/
	
иногда, например при установке точности или ширины поля использовать
средства iostream неудобно. для упрощения этих действий C++ предлагает
дополнительные манипуляторы в заголовочном файле iomanip. они
обеспечивают такие же возможности, но более удобным способом.
три самых частых - setprecision() для установки точности, setfill()
для установки символа-заполнителя, setw() для установки ширины поля.
эти манипуляторы принимают аргументы. setprecision() принимает
целочисленный тип, задающий точность, setw() тот же тип, но задающий
ширину поля, setfill() принимает символ char, для установки его
заполнителем






ВВОД И CIN
cin представляет стандартный ввод в виде потока байтов. обычно этот поток генерится клавой
при вводе например 2011 объект cin извлекает эти символы из входного потока. этот ввод может
являться частью строки, значением int, float, etc. таким образом извлечение из потока предполагает
также преобразование типа. таким образом, объект cin на основании типа переменной, предназначенной
для приема значения преобразует значение последовательности в нужный тип

использование cin
cin >> value_holder; // <-- область памяти, в которую помещается ввод. переменная, ссылка, разыменованный указатель, etc
cin интерпретирует ввод, в зависимости от типа переменной
cin имеет методы для всех встроенных типов. они называются функциями форматированного ввода

при использовании
int value_holder;
cin >> value_holder;
прога ищет нужную функцию, читает поток символов, отправляемой программе - например, символы
2, 3, 1, 8, 4
для двубайтовых intов cin преобразует символы в двоичное представление. если бы переменная
была double, то использовался бы прототип с double&, чтобы преобразовать этот же ввод в восьмибайтное
представление 23184.0
с cin можно использовать манипуляторы hex, oct, dec для указания, как должно интерпретироваться
целое число. в 16- 8- 10-чном формате
cin >> hex;
теперь ввод 12 или 0x12 воспринимается как 16ричное 12 или 10ное 18, а ff или FF считывается
как 10чное 255
также класс имеет операции по работе с указателями на символы
для этих типов cin читает слово из входного потока и помещает его по нужному адресу, добавляя
нулевой символ
можно мутить конкатенацию
cin >> lol >> you >> fakeassnigger
здесь, к примеру, cin, возвращенный операцией cin >> lol, становится
тем объектом, который принимает you

ВОСПРИЯТИЕ ВВОДА ОПЕРАЦИЕЙ CIN
различные версии операции извлечения одинаково воспринимают входной поток
Они опускают пробельные символы(пробелы, табы, символы новой строки
до тех пор, пока не встретят непробельный символ)
это справедливо даже для односимвольных режимов (тип char, unsigned char,
signed char), но не относится к функциям символьного ввода языка С
в односимвольных режимах операция >> читает символ и присваивает
ее объекту. в других режимах она читает один элемент данных.
т.е она читает все с начального символа, отличного от пробельного,
до первого символа, не соответствующего типу.
например, при
int elev;
cin >> elev;
вводе -123Z
то операция >> прочитает -123, так как они допустимы, но отбросит Z,
оставив его во входном потоке, поэтому следующий оператор cin начнет
чтение с этой позиции. потом операция преобразует введенную последовательность
в значение нужного типа и присваивает ее elev.
если ввести совсем херню, типа gvdeg453, то ничего присвоено не будет
и cin возвратит 0 или false

СОСТОЯние потока
cin и cout содержит член данных, унаследованный от ios_base, описывающий состояние потока
состояние потока (тип iostate, представляющий собой тип битовой маски) состоит из трех элементов:
ios_base::eofbit, failbit, badbit. при достижении конца файла eofbit ставится в 1, когда cin
не может прочитать символы failbit в 1, чтение из недоступного файла,
запись на защищенный диск ставит failbit в 1
badbit ставится в 1, когда происходит непонятный сбой,
который может повредить поток. когда все биты в 0, то все ок
можно пользоваться информацией о состоянии, чтобы делать что-то
goodbit - значит все ок, все биты ошибок в 0
good() - true, если все норм
eof() - true, если eofbit == 1
bad(), true, если badbit == 1
fail() - true, если failbit или badbit == 1
rdstate() - состояние потока

cin.exceptions(badbit) // badbit throws exception
cin.exceptions(badbit | failbit) // badbit and failbit does
//badbit | failbit result is:
//if badbit == 0001, failbit == 0010
//then result == 0011
// | operator set 1 with 1 and 0, 1. and 0 with 0 and 0

if and while (cin >> value) return true only if
stream's state is normal (all bits are 0)
жно проверять методы cin для определения причины.
можно в цикле использовать:
while(cin >> smt)
{
// do some things
}
if(cin.eof())
cout << "EOF reached\n";
установка состояний имеет важное значение: поток закрывается
для дальнейшего ввода или вывода, пока не будут очищены
биты
while(cin >> smt)
{
// do some things
}
cin >> smt // doesn't work if goodbit == false
для этой возможности можно очищать биты в 0
перед попыткой ввода

while(cin >> smt)
{
// do some things
}
cin.clear();
while(!isspace(cin.get())
	continue;
cin >> smt // it'll work
в этом примере очщения битов недостаточно
т.к надо очистить входной поток от некорректных символов
это делается
while(!isspace(cin.get())
	continue;
прога читает до пробела
но баще читать сразу до конца тупого ввода
while(cin.get() != '\n') continue;
но если произойдет не некорректный ввод, а EOF
или другая петруха, то код выше будет херней
поэтому нужно проверять, что явилось причиной 
сброса ввода
это делается так:
	while (cin >> input)
	{
		sum += input;
	}
	cout << "last val entered: " << input << '\n';
	cout << "sum = " << sum << endl;		
	if(cin.fail() && !cin.eof()) // failbit = 1, eof = 0
	{
		cin.clear(); //сброс состояния потока
		while(!isspace(cin.get())) continue;
	}
	else
	{
		cout << "some horrible shit's happened";
		exit(1);
	}
	cout << "now enter a new number: ";
	cin >> input;
	

	ДРУГИЕ МЕТОДЫ GET(), GETLINE()
	методы get(char&), get(void) - односимвольный ввод без пропуска пробельных символов

	get(char*, int, char), getline(char*,int,char) по умолчанию читают строки целиком, а не
	отдельные слова
	это - функции неформатированного ввода, потому что они просто читают символьный ввод,
	как есть, не пропуская пробелы, переводы строк и символы табуляции и не выполняя никаких
	преобразований данных.
	ОДНОСИМВОЛЬНЫЙ ВВОД
	когда метод get() вызываются с аргументом типа char или без аргументов он извлекает
	символ ввода, даже если это пробел, знак табуляции или символ новой строки. версия
	get(char& ch) присваивает введенный символ своему аргументу, а версия get(void) просто
	использует введенный символ, преобразованный в целочисленный тип (usually, int), в
	качестве своего возвращаемого значения
	если есть цикл:
	int ct{ 0 };
	char ch;
	cin.get(ch);
	while (ch != '\n')
	{
		cout << ch;
		ct++;
		cin.get(ch);
	}
	cout << ct << endl;
	и вводим I C++ clearly. <Enter>
	Нажатие enter отправляет эту строку ввода программе. фрагмент проги читает символ I
, отображает его с cout и увеличивает счетчик до 1. затем читает пробел, идущий за I, отображает его,
и увеличивает счетчик до 2. Это продолжается, пока не будет обработано нажатие клавиши
enter и когда символ новой строки не прекратит цикл.
идея в том, что get(ch) код читает, считает и отображает как пробелы так и символы
если использовать вместо cin.get(ch) cin >> ch;
то прога будет пропускать пробелы. также могут быть глюки с циклом, так как операция извлечения
пропускает табы и символы новой строки, то условие цикла не будет работать как надо
функция-член get(char &) возвращает ссылку на объект isteram, применяемый для ее вызова.
значит, можно исользовать конкатенацию извлечений, следующих за get(char&):
	char c1, c2, c3;
	cin.get(c1).get(c2) >> c3;
сначала cin.get(c1) присваивает первый введенный символ c1 и возвращает вызывающий объект,
в данном случае - cin. это сокращает код до cin.get(c2) >> c3, который присваивает второй
введенный символ c2 и возвращает cin. остается cin >> c3; этот оператор присваивает c3
отличный от пробела символ, хотя в первых двух операциях это возможно.
если метод cin.get(char &) встречает реальный или имитированный с клавы (в винде Ctrl + Z) конец файла
он не присваивает значение своему аргументу, так как значение в конце файла нету. еще вызывает
метод setstate(failbit), что приводит к возврату значения false в результате проверки cin:
char ch;
while(cin.get(ch))
{
// do smt
}
пока ввод корректен, возвращаемым значением cin.get(ch) является остается объект cin, проверка
которого возвращает true, поэтому цикл работает. при достижении конца файла возвращается
false и цикл breakается

функция get(void) также читает пробельные символы и использует свое возвращаемое значение
для передачи ввода в прогу. поэтому можно делать так:

	char c1;
	int ct{};

	c1 = cin.get();
	while (c1 != '\n')
	{
		cout << c1;
		++ct;
		c1 = cin.get();
	}
	cout << ct << endl;

	функция-член get(void) возвращает тип int (или какой-либо другой целый тип, это зависит
	от набора символов и региональных установок)
	так делать нельзя:
	char ch1, ch2, ch3;
	cin.get().get() >> c3; // it can't be, 'cause returning value of get(void) is ineger,
	not class's object
	но можно использовать get(воид) в конце последовательности
	char ch1;
	cin.get(ch1).get(); // прочитает символ и присвоит его ch1, прочитает символ и отбросит его
	при достижении конца файла get(void) возвращает константное значение EOF, определенное в iostream,
	как признак конца файла
	так, можно читать ввод:
	int ch{};
	while((ch = cin.get()) != EOF)
	{
	// do some shit
	}
	если пропуск пробелов необходим, то можно пользоваться >>
	char ch;
	cin >> ch;
	while(ch != 'q')
	{
		switch(ch)
		{
		}
		cout << "Enter a,b,c,d\n";
		cin >> ch;
	}

	если нужен пункт b, вводится b и жмется ентер, генерируя двухсимвольный ответ b\n,
	если пользоваться формами get(), надо добавлять код, обрабатывающий символ \n на каждом
	шаге цикла, но операция извлечения без трудя пропускает его
	если нужна обработка каждого символа, то юзаем get(), например, программа подсчета символов
	может использовать пробел, как символ конца слова.

	СТРОКОВЫЕ функции getline(), get(), ignore()
	сигнатуры у них одинаковые
	istream& get(-line)(char* /*место помещения строки*/, int /*кол-во символов/*, char 
	/*необязательный, служащий разделителем*/);
	читает символьный ввод в символьный массив:
	char ch[50]
	cin.get(ch, 50);
	прекращает читать по достижении 49 символа или символа новой строки - что произойдет раньше
	get() оставляет символ перевода строки (или разделитель) во входном потоке, делая его доступным для след.
	операции ввода, а getline() - отбрасывает ввод из входного потока
	теперь функция istream&  ignore(int = 1, int = EOF), которая принимает два аргумента:
	число, указывающее максимальное кол-во символов для чтения, и симол, служащий разделителем
	при вводе
	cin.ignore(255, '\n'); // читает и отбрасывает 255 символов или все символы до символа
	перевода строки - смотря, что произойдет раньше

	непредусмотренный строковый ввод
	1. отсутствие ввода
	если не удается извлечь символов из входной строки, то в нее помещается нулевой символ
	и setstate() включает failbit. может быть из-за немедленного достижения конца файла
	или может быть ввод пустой строки
	char temp[80];
	while(cin.get(temp, 80))// завершение ввода на пустой строке
	однако пустая строка введенная с помощью getline не ставит флаг failbit, поскольку 
	она извлекает символ перевода строки, даже если и не сохраняет его, если надо, чтобы
	цикл getline завершался на пустой строке, надо сделать:
	char temp[80];
	while(cin.getline(temp, 80)) && temp[0] != '\0')
	2. соответствие или превышение макс. значение, указанное методом ввода
	getline;
	char temp[80];
	while(cin.getline(temp,80));
	метод getline будет помещать символы последовательно в массив, пока в ходе проверки не будет
	достигнут конец файла, или след. символ не будет символом новой строки, или пока не будет
	сохранено 79 элементов. при достижении конца файла ставится eofbit, если символом является
	символ новой строки, он читается и отбрасывается. при чтении 79 символов флаг failbit
	ставится только если след. символ не есть символ перевода строки. так, строки в 80+ символов
	завершит ввод
	теперь get(char*, int). сначала он проверяет кол-во символов, затем - признак конца файла,
	- наконец -, является ли очередной символ символом перевода строки. он не ставит failbit
	после чтения макс. кол-ва символов. тем не менее, можно определить, когда окончание считывания в методе вызвано
	слишком большим кол-во вводимых данных. можно юзануть peek() для проверки след. символа ввода. если это
	перевод строки, get() должен прочитать полную строку. если это не символ перевода строки
	get() должен прекратить выполнение до достижения конца.

	ДРУГИЕ МЕТОДЫ:
	метод read() - читает заданное кол-во байт и помещает их в указанное место.
	char gross[144];
	cin.read(gross, 144) // <- читает 144 символа и помещает их в gross НЕ добавляя нулевой символ
						// и не преобразует в строковую форму. не предназначени для ввода с клавы
						// чаще применяется с методом write при работе с файлами. возвращает istream&, доступна конкатенация
	метод peek() - возвращает след. символ без извлечения из входного потока. можно посмотреть символ.
	можно проверять так:
	char great_input[80];
	char ch;
	int i{};
	while((ch = cin.peek()) != '.' && ch != '\n')
	cin.get(great_input[i++]);
	great_input[i] = '\0';
	
	метод gcount() возвращает кол-во символов, прочитанных последним методом неформат. извлечения
	это подразумевает символы, считанные методом get(), getline(), ignore() или read(),
	но не операцией извлечения >>, которая форматирует ввод, в зависимости от типа.
	если использовалось 
	cin.get(myarray, 80) и надо узнать, сколько символов было прочитано. для массива можно
	использовать strlenght, но быстрее применить cin.getcount(), чтобы выяснить, сколько
	символов только что было считано из входного потока

	метод putback() вставляет символ обратно в строку ввода. вставленный символ будет первый
	для чтения. конкатенация, аргумент char.
	peek() = get() для чтения след. символа + putback() ложение обратно во входной поток
	но putback() дает возможность вернуть поток символов, отличающийся от последнего прочитанного

	ФАЙЛОВЫЙ ВВОД ВЫВОД. для вывода в файл используется ofstream с операциями << или write
	для ввода из файла используется ifstream с операциями >> и get()
	есть еще класс fstream для ввода и вывода.
	с файлами, однако, больше гемора.
	1. только что открытый файл, нужно ассоциировать с потоком. можно открыть файл для чтения,
	записи или и то, и то. при записи в файл может потребоваться создать новый файл, замена
	старого или добавление инфы в существующий файл. или может понадобиться перемещение по файлу.

	ПРОСТОЙ Файловый ввод\вывод
	действия для вывода:
	1. создать объект ofstream для управления выходным потоком.
	#include <fstream>
	...
	std::ofstream fout;
	2. ассоциировать объект с конкретным файлом
	fout.open("jar.txt");
	или в конструкторе
	std::osftream fout("jar.txt");
	3. использовать объект, так как cout
	fout << "Some data";
	так как ostream is inherited by ofstream можно применять все методы ostream. операция
	вставки, методы форматирования и манипуляторы.
	класс использует буферизованный, поэтому при создании объекта прога выделяет память
	для выходного буфера. для каждого объекта выделяется свой буфер.
	такой метод создает новый файл, если его не существует. если файл уже существует, то он
	становится пустым для записи.
	
	действия для ввода:
	1. создать объект ifstream для управления входным потоком.
	#include <fstream>
	...
	ifstream fin;
	2. ассоциировать объект с файлом
	fin.open("somedata.txt");
	OR
	ifstream fin("somedata.txt");
	3. использовать объект как cin
	char ch;
	fin >> ch; //читаем символ из файла
	char buf[80];
	fin >> buf; //читаем слово из файла
	fin.getline(buf, 80); // читаем строку из файла
	string line;
	getilne(fin, line); // читаем из файла в строковый объект
	ввод как и вывод буферизуется. поэтому при объявлении объекта ему выделяется память под
	буфер. это обеспечивает более быструю передачу данных, нежели побайтовая передача
	соединение с файлом закрывается автоматом, когда объект уничтожается. можно сделать это явно:
	fin.close(); // закрытие соединения ввода с файлом
	fout.close(); // закрытие вывода
	закрытие такого соединения не уничтожает поток; оно просто отключает его от файла.
	объект и буфер продолжают существовать. этот поток можно подрубить к тому или иному файлу после закрытия
	закрытие файла очищает буфер, гарантируя обновление файла
	ПРОВЕРКА ПОТОКА И is_open()
	классы файловых потоков наследуют член, описывающий состояние потока, от ios_base. Этот
	член, хранит инфу о состояни потока - все ли в порядке, достигнут ли EOF, был ли сбой операции ввода-вывода
	если все в порядке - состояние потока = 0. другие состояния ставят какие-либо биты в 1
	например, попытка открытия несуществующего файла завершится установкой failbit в 1
	fin.open(argv[file]);
	if(fin.fail())
	{
		couldn't read from file
	}
	или можно использовать сам объект, тогда тип преобразуется в bool
	if(!fin)
	{}
	но лучше использовать современный способ проверки открытия файла:
	if(!fin.is_open())
	{
	}
	так как он проверяет еще некоторые детали

	раньше проверка успешности открытия проверялась:
	if(fin.fail())
	if(!fin.good())
	if(!fin) // работает подобно fin.good()

	ОТКРЫТИЕ НЕСКОЛЬКИХ ФАЙЛОВ
	1. если надо, чтобы два файла были открыты одновременно, то надо создать два потока
	пример: прога сортирует два файла и складывает результат в третий. нужно создать
	два ifstream  для входных файлов, и один ofstream - для выходного. кол-во файлов, которые
	можно открыть одновременно зависит от операционки
	2. последовательная обработка файлов. подсчитать слово в 10 файлах. можно открыть один
	поток и последовательно ассоциировать его с файлом. это более экономно.
	нужно объявить один объект без инициализации, а потом открывать последовательно файлы.
	ifstream fin; // создание потока конструктором по умолчанию
	fin.open("fat.txt"); // ассоциирование потока с файлом
	...// делаем чето
	fin.close(); // разрыв связи с файлом
	fin.clear(); // сброс fin
	fin.open("rat.txt"); //ассоциирование потока с файлом 
	...
	fin.close();

	ОБРАБОТКА КОМАНДНОЙ СТРОКИ
	Программы использую аргументы ком.строки для идентификации файлов. Аргументы ком.строки
	это параметры, вводимые в ком строке после команды. Например, для подсчета слов в файле
	можно использовать.
	wc report1 report2 report3
	wc- имя проги, report... имена файлов, переданные в качестве аргументов ком.строки.
	С++ позволяет получать прогам, запущенным из ком.строки, доступ к параметрам.
	int main(int argc, char* argv[])
	argc - кол-во аргументов ком-строки
	argv - указатель на указатель на char или массив указателей на аргументы ком. строки.
	argv[0] - первый символ строки самой команды, argv[1] - первый символ первого аргумента,
	т.е argv[1] - указатель на первый аргумент.
	wc report1 report2 report3 тут у нас argc = 4
	argv[0] - wc, argv[1] - report1 ...
	for(int i{1}, i < argc, ++i)
		cout << argv[i] << endl;

	РЕЖИМ ФАЙЛА
	ifstream fin("banjo", mode1) // конструктор с аргументом режима
	ofstream fout;
	fout.open("harp", mode2) // open() с аргументом режима
	ios_base представляет тип openmode, представляющий режим, с типом bitmask.

	using bit = ios_base;
	bit::in; // для чтения
	bit::out; // записи
	bit::ate; // перейти в конце файла после открытия
	bit::app; // добавлять в конец файла
	bit::trunc; // усечь файл, если существует
	bit::binary; // двоичный файл

	если режим не указывать, будет использован режим по умолчанию. у open() и ifstream
	используется ios_base::in. аналогично, у ofstream по умолчанию используется ios_base::out | ios_base::trunc
	для fstream биты нужно указывать явно
	
	если нужно, чтобы из проги в файл посылалась инфа без стирания уже имеющейся, то делаем так:
	ofstream fout("badgels", ios_base::out | ios_base::app);

	бит out (эквивалентен out | trunc) вызывает усечение файла, но не делает этого, если используется в паре с in
	in | trunc вызовет ошибку, типа читаем из пустого файла

	out | app - открытие с разрешением на добавление only

	in | out - для чтение и записи в произвольном месте

	in | out | trunc - чтение и запись с усечением

	c++mode типа in | binary - открытие в бинарном (не текстовом) режиме для чтения (из файла)

	c++mode типа ate - открытие в указанном режиме и переход к концу файла

	разница между app и ate <- app позволяет только добавлять данные, ate просто переходит в конец

	Бинарные файлы
	Текстовая форма - хранение всех данных - даже числе - в виде текста. Например, число
	-45644.64 будет сохранено символами. Это требует преобразования числа в символы, что делает
	операция вставки. А бинарный формат хранения означает хранение в виде внутреннего компьютерного
	представления значения. Т.е вместо символов комп сохраняет (обычно) 64-разрядное представление
	типа double. Для символа бинарное представление совпадает с текстовым представлением - 
	бинарным представлением ASCII-кода, (or equals) символа
	Однако для чисел бинарное представление значительно отличается от символьного
	Бинарное представление 0.375
	Бит знака Биты экспоненты Биты дробной части
	0		  0111110		  11000000000000000000000
	Текстовое представление 0.375
	00110000	  00101110		00110011	  00110111		00110111
	Код символа 0 Код символа . Код символа 3 Код символа 7 Код символа 5 (как 7??)
	Текстовый формат легко читать. Лего передать из системы в систему.
	Бинарный более точен для чисел, поскольку сохраняет внутренее представление значения
	Его применение позволяет избежать ошибок, связанных с округлением или преобразованием.
	Сохранение в бинарном формате идет быстрее, так как там не нужны преобразования.
	Бинарный формат обычно требует меньше места. Однако нормально передать в другую систему
	бывает проблемно, если там другое внутреннее представление значений. Тогда может
	понадобиться написать прогу для преобразования из одного формата данных в другой.
	Рассмотрим пример:
	const int LIM = 20;
	struct planet
	{
		char name[LIM];
		double population;
		double g;
	};
	planet pl;
	чтобы сохранить в текстовом формате, надо сделать так:
	ofstream fout("planets.dat", ios_base::out | ios_base::app);
	fout << pl.name << " " << pl.population << " " << pl.g << endl;
	Для сохранения той же инфы в бинарном формате:
	ofstream fout("planets.dat", ios_base::out | ios_base::app | ios_base::binary);
	fout.write((char*) &pl, sizeof pl);
	Этот код сохраняет всю структуру, используя внутреннее компьютерное представление данных.
	Этот файл не удастся прочитать как текстовый, так как инфа там будет сохранена в более 
	компактном и точном виде, чем в тексте.
	Этот подход использует бинарный режим файла и метод write(), который копирует указанное
	кол-во байт из памяти в файл. Он будет побайтно копировать данные любых типов.
	Единственное, нужно нужно привести адрес к типу char*. Для кол-во байт - оператор sizeof
	Чтобы восстановить инфу из файла, нужно использовать метод read() с объектом ifstream:
	ifstream fin("planet.dat", ios_base::in | ios_base::binary);
	fin.read((char*)&p1, sizeof p1);
	Этот код копирует sizeof байт из файла в структуру p1. Так же можно делать с классами
	без виртуальных функций. В этом случае буду сохранены только данные члены, но не методы.
	Если есть вирт.методы, то скрытый указатель на таблицу указателей виртуальных функций
	также будет скопирован. Посколку при следующем запуске проги таблица может быть размещена
	в другом месте, то копирование старого значение может привести к краху.
	В системах типа Windows есть два формата файлов: бин и текст. ДЛя бинарного формата, нужно
	использовать бинарный режим, как в С++ ios_base::binary.
	запомните: НЕЛЬЗЯ использовать в той структуре объект string, так как он реально
	не содержит строку, а только содержит адрес ее хранения в памяти. При повторном запуске
	этот адрес утрачивает смысл.

	ПРОИЗВОЛЬНЫЙ ДОСТУП
	Произвольный доступ позволяет перемещатся по файлу без необходимости последовательного
	считывания символов. Программа будет иметь отдельный индексный файл с инфой о местоположении
	данных в основном файле. В этом случае прога сможет перепрыгивать к нужным данным, читать их
	и модифицировать, если чо.
	fstream используется для ввода и вывода сразу, поддерживая два потока.
	Для открытия бинарного файла для ввода-вывода используем
	finout.open(file, ios_base::in | ios_base::out | ios_base::binary);
	методы для перемещения по файлу. метод seekg() перемещает в заданную позицию файла указатель ввода,
	метод seekp() - аналогично для вывода. На самом деле, так как fstream использует буферы
	для промежуточного хранения данных, эти указатели указывают на положения в буферах, а не в реалтайме.
	Можно такде применять seekg() с ifstream и seekp() с ofstream().
	У seekg() есть две версии:
	(специализация для типа char)
	ifstream& seekg(streamoff, ios_base::seekdir);
	ищет позицию в файле, измеренной смещением в байтах от позиции, заданной вторым аргументом.
	об аргументах: значение типа streamoff используются для для измерения смещений в байтах от
	определенного положения в файле. Аргумент streamoff представляет позицию в файле в байтах,
	измеренную смещение одного из трех возможных положений. Тип - целочисленный или класс.
	seek_dir- еще один целый тип, который определен вместе с тремя возможными значениями в классе
	ios_base. Константа beg (в ios_base) означает смещения от начала, cur - от текущей позиции,
	end- от конца.
	fin.seekg(30, ios_base::beg) // 30 байт с начала
	fin.seekg(-1, ios_base::cur) // на один байт назад.
	fin.seekg(0, ios_base::end) // в конец
	ifstream& seekg(streampos);
	ищет позицию с начала файла
	streampos представляет смещение от начала файла.
	fin.seekg(112) устанавливает указатель на 112 байт, который в файле есть 113
	для проверки позиций файлового указателя юзаем tellg() для входных потоков и tellp() - для выходных.
	каждый из них возвращает streampos измеренный от начала файла. однако, ifstream и ofstream
	выдают разные позиции в одном файле, так как они независимо перемещаются по нему.

	fstream finout;
	finout.open(file, in, out, binary);
	int ct{};
	if(finout.isopen())
	{
		finout.seekg(0); // to the beginning
		while(finout.read((char*) &pl, sizeof pl));
		{
			cout << ct++ << setw(LIM) << pl.name << ": " << setprecision(0) << setw(12)
			<< pl.population << setprecision(2) << setw(6) << pl.g << endl;
		}
		if(finout.eof()) finout.clear();
		else
		{
			cerr << "Error in reading " << file << ".\n";
			exit(1);
		}
	}
	else
	{
			cerr << "Error in opening " << file << ".\n";
			exit(1);
	}
	потом вводим запись, которую нужно изменить и умножаем ее на sizeof pl, чтобы получить нужную запись.
	long rec;
	cin >> rec;
	eatline();
	if(rec < 0 || rec >= ct)
	{
	 // shows some error;
	}
	streampos place = rec * sizeof pl;
	finout.seekg(place);
	потом прога отображает текущую запись:
	finout.read((char*) &pl, sizeof pl);
			cout << ct++ << setw(LIM) << pl.name << ": " << setprecision(0) << setw(12)
			<< pl.population << setprecision(2) << setw(6) << pl.g << endl;
		if(finout.eof()) finout.clear();

	после отображения вводим новые данные.
	cout << "enter planet\n";
	cin.get(pl.name, 20);
	eatline();
	cout << "population\n";
	cin >> pl.population;
	cout << "gravity\n";
	cin >>  pl.g;
	finout.seekp(place);
	finout.write((char*)&pl, sizeof pl) << flush;
	if(finout.fail())
	{
	// error
	}

	если нужна работа с временными файлами, будет полезна функция из cstdio
	char* tmpnam(char* pszName);
	L_tmpnam const - кол-во символов
	TMP_MAX = макс. кол во вызовов

	char* name[L_tmpnam] = {'\0'};
	for(int i{}; i < 10; i++)
	{
		tmpnam(pszName);
		cout << pszName << endl;
	}

	ВНУТРЕННЕЕ ФОРМАТИРОВАНИЕ
	Библиотека с++ предоставляет класс sstream, который представляет тот же интерфейс для
	организации ввода-вывода между прогой и объектом string.
	это значит, что для записи форматированной инфы в объект string можно применять те же
	методы  ostream, которые применялись с cout, а для чтения инфы из объекта string - такие
	методы как getline(). Процесс чтения форматированной инфы из объекта string и запись
	 форматированной инфы в него называется внутренним форматированием
	Заголовочный файл sstream определяет класс ostringstream, производный от ostream.
	Можно применять те же методы, что и с cout.
	ostringstream outstr;
	double price{380.0};
	char* ps{" for a copy of the ISO\EIC C++ standard!"};
	outstr.precision(2);
	outstr << fixed;
	outstr << " Pay only CHF " << price << ps << endl;
	Форматированный текст помещается в буфер, и объект использует динамическое выделение памяти
	для расширения буфера, если надо.
	Класс ostringstream имеет функцию-член str(), которая возвращает объект string,
	инициализированный содержимым буфера.
	string mesg = outstr.str(); 
	применение str() замораживает объект и дальнейшая запись в него становится недоступной.
	
	класс istringstream позволяет использовать семейство методов istream для чтения данных
	из объекта istringstream, который может быть инициализирован объектом string.
	Предположим, что facts - string type object. Чтобы создать istringstream, ассоциированный
	с этой строкой, можно использовать следующий код:
	istringstream instr(facts);
	Затем можно применять методы istream для чтения данных из instr. Например, если instr
	содержит ряд чисел в символьном формате, их можно прочесть следующим образом.
	int n{}, sum{};
	while(instr >> n) sum += n;

	При подключении iostream в проге открываются 8 потоков для работы с восемью объектами.
	cin управляет станлартным потоком ввода, cout - вывода. cerr и clog управляют небуферизованными
	и буферизованными подключенными к устройству ошибок - как правило, монитору.
	у этих объектов есть аналоги с префиксом w, для работы с широкими символами.


	C++11!!!!!!!!!!!!!!!!!!!!!!

	Новые типы - long long, unsigned long long для поддержки 64-х битных (или шире) чисел,
	а также типы char16_t и char32_t для поддержки представлений 16 и 32-х битных символов.
	Добавились необработанные raw строки.

	Унифицированная инициализация.
	Эта инициализация используется со всеми встроенными типами и пользовательскими типами.
	Список может применяться как со знаком, так и без знака =:
	int x = {5};
	double y{2.75};
	short quar[5] {4,5,2,76,1};
	Кроме того, синтаксис списковой инициализации может применяться в новых выражениях:
	int* ar = new int[4] {2,4,6,7};
	С объектами может применяться вместо списка в круглых скобках для вызова конструктора:
	Stump s1(3,5.6); // old
	Stump s2/*=*/{4,5.6}; // C++11.
	Однако если класс имеет конструктор, аргумент которого является std::initializer_list,
	то только этот конструктор может использовать форму списковой инициализации.
	Синтаксис списковой инициализации предоставляет защиту от сужения - т.е присваивания
	числового значения числовому типу, который недостаточно вместителен, чтобы хранить
	такое значение.
	char c1 = 1.57e27; // инициализируем char типом double. UB
	char c2 = 547257358; // инициализируем char типом int. UB
	Однако в случае применения синтаксиса списковой инициализации компилятор не разрешает
	преобразование типов, при которых производится попытка сохранить значение в типе,
	который является более "узким", чем указанное значение.
	В то же время преобразование в более широкие типы разрешены. Кроме того преобразование
	в более узкий тип допускается, если значение находится в разрешенном для типа
	диапозоне.
	char c1{66};
	double c2 = {66};

	AUTO
	В С++11 применяется для автоматического выведения типа при условии, что задан явный
	инициализатор.
	auto l = 5;
	auto pt = &l;
	double fm(double, int);
	auto pf = fm;
	Также можно упростить объявления шаблонов:
	for(std::initializer_list<double>::iterator p = il.begin(); p != il.end(); ++p);
	for(auto p = il.begin()/*someotherstuff*/)
	
	DECLTYPE
	Ключевое слово decltype создает переменную типа, который указан выражением.
	decltype(x) y; // назначить y тот же самый тип, что и у x

	double x;
	int n;
	decltype(x*n) q; // получает тип double
	decltype(&x) pd; // double*
	Это особенно полезно при определении шаблонов, где тип может быть не определен
	вплоть до создания специфического экземпляра.
	template <class T,
				class U>
	void ef(T t, U u)
	{
		decltype(t*u) tu;
	}
	Здесь tu - любой тип, полученный в результате выполнения операции T*U, при условии,
	что эта операция определена. Если тип U - char, а T - short, то tu получит тип int,
	поскольку происходит автоматическое целочисленное расширение, принятое в целочисленной арифметике.
	int j = 3;
	int& k = j;
	const int&n = j;
	decltype(n) i1; // const int &
	decltype(j) i2; // int
	decltype((j)) i3; // int&
	decltype(k+1) i4; // int
	В С++11 появился хвостовой возвращаемый тип функции.
	double f1(double, int); // traditional
	auto f2(double,int)->double; // new; returning type is double
	С этим синтаксисом можно использовать decltype для указания возвращаемого типа:
	template <class T,
			class U>
	auto ef(T t, U u) -> decltype(t*u)
	{
		 ...
	}
	
	Псевдонимы шаблонов: using = 
	Для создания псевдонимов длинных идентификаторов типов есть typedef;
	typedef std::vector<std::string>::iterator itType;
	В С++11 новый синтаксис:
	using itType = std::vector<std::string>::iterator;
	Отличие в том, что новый синтаксис может применяться и для частичных специализаций шаблонов,
	а typedef  - нет.
	template <typename T>
	using arr12 = std::array<T,12>; // шаблон для множества псевдонимов.
	Этот оператор специализирует шаблон array<T,int>, устанавливая параметр int в 12.
	std::array<int,12> a1;
	std::array<std::string, 12> a2;
	//Can be replaced with
	arr12<int> a1;
	arr12<std::string> a2;

	ИНТЕЛЛЕКТУАЛЬНЫЕ УКАЗАТЕЛИ
	Переменная, использующая new должна использовать delete, когда она больше не нужна
	Для автоматизации этого был введен smart pointer auto_ptr. Благодаря STL стало
	понятно, что нужно что-то более изощренное. Руководствуясь опытом и средствами
	библиотеки BOOST, в С++11 были представлены три smart pointer (unique, shared, weak ptrs), а auto_ptr - declared as deprecated.
	Все новые смартпоинтеры спроектированы для работы с контейнерами и семантикой переноса.

	Изменения в спецификации исключений.
	С++ предоставляет синтаксис для указания, какие исключения (если есть) функция может сгенерить:
	void f45 throw(bad_dog); // can generate bad-dog exception
	void g454 throw(); // doesn't throw anything
	Но опыт показал, что это не очень хорошо работает. Это объявлено устаревшим.
	Тем не менее, для указания того, что функция не генерит исключения используется спецификатор noexcept
	void f343(int, short) noexcept; // doesn't throw anything

	ПЕРЕчисления с областью видимости.
	Перечисления предоставляют способ создания именованных констант. Однако они обеспечивают
	слишком низкий уровень контроля типов. Областью видимости перечисления является
	область видимости, в которой они объявлены, а это значит, что перечисления в одной
	области не должны содержать одинаковые члены. Они могут также оказаться не полностью
	переносимы, т.к. в различных реализациях для них могут быть выбраны разные типы.
	В С++11 включена новая форма, использующая struct или class:
	enum Old1{yes,no,maybe}; // old
	enum class New1{never,sometimes,often}; // new
	enum struct New2{never,lever,sever}; // New
	За счет явного указания области видимости новые формы не создают конфликтов имен

	ИЗМЕНЕНИЯ В КЛАССАХ
	Операции преобразования explicit.
	explicit подавляет автоматическое преобразования, вызванное конструктором с одним аргументом.
	class Plebe
	{
		Plebe(int); // автоматическое преобразование к int
		explicit Plebe(double); // явное использование only
	};
	Plebe a,b;
	a = 5; // неявное преобразование. вызов первого конструктора.
	b = 0.5; // низя
	b = Plebe(0.5); // явное преобразование.
	В С++11 использование ключевого слова explicit расширено и на функции преобразования.
	class Plebe
	{
		operator int() const; //
		explicit operator double() const; // явное использование only
	};
	Plebe a,b;
	int n = a; // автоматическое преобразование int в Plebe
	double x = b; // can't be done
	x = double(b); // явное преобразование разрешено

	ИНИЦИАЛИЗАЦИЯ членов внутри класса.
	class Session
	{
		int mem1 = 10; // here
		double mem2{1677.5}; // here
		short mem3;
	public:
		Session() {}
		Session(short s) : mem3(s) {}
		Session(int i, double d, short s) : mem1(i), mem2(d), mem3(s) {}
	};
	Можно использовать оператор = или фигурные скобки, но не оператор (). Результат
	будет тем же, что и в случае предоставления первых двух конструкторов с элементами
	списка инициализации для mem1 и mem2:
	Session() : mem1(10), mem2(1677.5) {}
	Session(short s) : mem1(10), mem2(1677.5), mem2(s) {}
	Это позволяет избежать дублирование кода. Третий конструктор переопределяет значения внутри класса.
	
	ИЗМЕНЕНИЯ В STL:
	range-based for, new containers, new methods and some other crap
	Завершени использования export
	В С++98 было введено ключевое слово export в надежде создать способ разделения определений
	шаблонов на интерфейсные файлы, содержащие прототипы и объявления шаблонов, и файлы
	реализации, содержащие определения шаблонных функций и методов. Это оказалось непрактичным и 
	export больше не пашет.

	ССЫЛКИ L- и RVALUE
	Традиционная ссылка привязывает идентификатор к значению lvalue. lvalue - это выражение,
	такое как имя переменной или разыменованный указатель, предоставляющий данные, для
	которых программа может получить адрес. Первоначально lvalue было значением, которое могло
	встречаться в левой стороне оператора присваивания, но появление модификатора const
	позволило конструкциям, не допускаюющим присваивание, быть ардесумеыми
	int n;
	int* pt = new int;
	const int b = 101; присваивать b не разрешено, но &b можно.
	int &rn = n;// n идентифицирует элемент данных по адресу &n
	int& tr = *pt; // *pt идентифицирует элемент данных по адресу pt
	const int &rb = b;// b идентифицирует элемент данных const по адресу &b
	В С++11 добавлена ссылка rvalue, которая может привязываться к значениям, находящимся справа от оператора
	присваивания, к которым нельзя применить операцию взятия адреса. Литеральные константы (но не C-строки,
	которые вычисляются как адреса)., выражения наподобие x + y и возвращаемые значения функции, если они не ссылки.
	int x{10};
	int y{23};
	int&& r1 = 13;
	int && r2 = x + y;
	double && r2 = std::sqrt(2.0);
	r2 в действительности привязывается к значению, которое получается в результате x + y, т.е. 23, и последующие
	изменения x or y на r2 влияния не оказывают.
	Привязка ссылки rvalue к ссылке rvalue дает в итоге значение, хранящееся в ячейке, адрес которой можно получить.
	Это значит, что хоть и нельзя делать &13, можно делать &r1. Такая привязка данных к определенному адресу
	и делает возможным доступ к данным через ссылки rvalue.
	Одна из причин внедрения rvalue = реаллизация семантики переноса, которая будет далее.

	CЕМАНТИКА ПЕРЕНОСА И ССЫЛКА rvalue
	Работа процесса копирования до С++11.
	vector<string> vstr;
	// vector contains 20k lines, each line has 1k symbols
	vector<string> vstr_copy1(vstr); // vstr_copy1 is the copy of vstr
	Вектор и стринг использую динамическую аллокацию памяти, поэтому имею определенные конструкторы копирования,
	в которых применяется какая-то версия new. для инициализации vstr_copy1 конструктор копирования будет использовать
	операцию new для выделения памяти под 20к объектов стринг, а стринг будет вызывать конструктор копирования, выделяющий
	память под 1к символов.
	Затем все 2000к символов будут копироваться из памяти, управляемую vstr, в память, управляемую vstr1_copy
	Но это не всегда нужно делать.
	Функция возвращает vector<string>
	vector<string> allcaps(const vector<string>& vs)
	{
		vector<string> temp;
		// someotheractions
		return remp;
	}
	Код используется например так:
	vector<string> vstr;
	vector<string> vstr1_copy(str);
	vector<string> vstr2_copy(allcaps(vstr));
	Для избежания копирования и удаления данных используется семантика переноса: она позволяет избежать
	перемещения основных данных; она только корректирует учетные данные.
	Для реализации семантики переноса нужно сообщать компилятору, когда должна производиться действительная копия,
	а когда - нет.

	
	ПЕРЕГРУЗКА МЕТОДОВ БАЗОВОГО КЛАССА В ПРОИЗВОДНОМ
	есть такое определение классов:
			class A{
			int a;
		public:
			A(int i) : a{ i } {}
			void show(char ch) { cout << a << " A " << ch << endl; }
		};

		class B : public A{
			int b;
		public:
			B(int F) : b{ F }, A{ 0 } {}

			using A::show; /*делает доступным методы базового класса для перегрузки
			если этого нет и нет перегруженных методов, то будут вызываться методы
			базового класса*/

			void show(char ch)  { cout << b << " B " << ch << endl; } 
			/*можно определить метод с таким же названием и той же сигнатурой, что и
			у базового варианта метода без или с оператором using сверху*/

			void show(char *ch)  { cout << b << " " << ch << endl; }
			/*без using этот метод скроет метод базового класса*/

		};

		ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДОВ БАЗОВОГО КЛАССА
				class A{
			int a;
		public:
			A(int i) : a{ i } {}
			virtual void show(char ch) final /*чтобы нельзя было переопределить*/  { cout << a << " A " << ch << endl; }
		};

		class B : public A{
			int b;
		public:
			B(int F) : b{ F }, A{ 0 } {}
			void show(char ch) override /*для намерения переопределить*/  { cout << b << " B " << ch << endl; } 

		};

		еще можно использовать default и delete. делегировать конструкторы и наследовать их с помощью using, как было показано
		выше. но если конструктор производного имеет те же аргументы, что и базовый, то
		базовый вариант не используется.
		еще можно использовать операцию разрешения контекста, чтобы указать, какой метод
		надо использовать с виртуальными функциями
	


	LAMBDA
	#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

inline bool f3(int x) { return x % 3 == 0; }
inline bool f13(int x) { return x % 13 == 0; }

int main(int argc, char* argv[])
{
	std::vector<int> number(1000);
	generate(number.begin(), number.end(), std::rand);

	// using pointer to function
	//int count3{ count_if(number.begin(), number.end(), f3) };
	//int count13{ count_if(number.begin(), number.end(), f13) };

	// using functors
	//class f_mod {
	//private: int dv;
	//public: f_mod(int d = 1) : dv{ d } {}; bool operator()(int x)
	//											{ return x % dv == 0; }
	//};

	// using lambda
	//int count3{ count_if(number.begin(), number.end(), 
	//	[](int x) {return x % 3 == 0; }) };
	//int count13{ count_if(number.begin(), number.end(), [](int x) {return x % 13 == 0; }) };

	//cout << count3;

	double x{ sqrt(2) };
	system("pause");
	return EXIT_SUCCESS;
}

	auto mod3 = [](int x) {return x%3 == 0;}
	int c1{count_if(n1.begin(), n1.end(), mod3)};

	[=] - доступ ко всем автоматическим переменным в области видимости по значению
	[&] - по ссылке
	[=, &var1] - доступ ко всем по значению, к var1 - по ссылке
	[&, var1] - доступ ко всем по ссылке, к var1 - по значению

	int c{};
	std::for_each(c1.begin(), c1.end(), [&c](int x)
	{
		c += x % 13 == 0; // x % 13 == 0 = true или false. при + преобразуется в 1 или 0
	})



	ЧТОБЫ применять unique для vector, надо сначала отсортировать его. потом вызвать vect.erase(unique(vect.begin(), vect.end()),
	vect.end())
	так как юник не удаляет элементы, а перемещает их в конец контейнера.

	Шаблоны с переменным кол-вом аргументов.
	Пакеты параметров шаблонов и функций.
	template <typename T>
	void show_list0(T value)
	{
		std::cout << value << ", ";
	}
	Это определение содержит 2 списка параметров. Список параметров шаблона это T.
	Список параметров функции это value;
	show_list0(2.15) устанавливает Список параметров шаблона тут ставится в T, а список
	параметров функции это double.

	В С++11 появилась мета-операция троеточия, которая позволяет объявить идентификатор
	для пакета шаблона, в сущности являющего списком типов. Аналогично она позволяет
	объявить идентификатор для пакетов параметров функции, который представляет список
	значений.
	template<typename... Args> // Args - пакет параметров шаблона
	void show_list1(Args... args) // args - пакет параметров функции
	например, show_list1('S', 80, "sweet", 4.5) содержит типы, соответствующие параметрам
	в вызове функции: char, int, const char*, double.
	show_list1(Args... args) тут args (как и T value указывает, что value имеет тип T)
	указывает, что args имеет тип Args. Это значит, что пакет функции args содержит список
	значений, которые соответствуют пакету шаблона Args, причем как и по типам, так и 
	по их кол-ву. args содержат значения 'S', 80, "sweet", 4.5.
	Распаковка пакета.
	Пакет можно распаковать, поместив троеточие справа от имени пакета параметров функции.
	template<typename... Args>
	void show_list1(Args... args)
	{
		// warning! crappy cod detected
		show_list1(args...); // передача распакованного args в show_list1();
	}
	предположим, что используется следующий вызов:
	show_list1(5,'L',0.5);
	это помещает эти значения в args.
	вызов show_list1(args...);
	развертывается в следующий код:
	show_list1(5,'L',0.5);
	и так до бесконечности. так как одиночная сущность args развертывается в отдельные аргументы,
	содержащиеся в пакете.
	Использование рекурсии в шаблонных функциях с переменным числом аргументов.
	Идея состоит в том, чтобы распаковать пакет параметров функции, обработать первый
	элемент в списке, передать оставшуюся часть списка рекурсивному вызову и так до тех
	пор, пока список не окажется пустым.
	Часть трюка предусматривает изменение заголовка шаблона:
	template<typename T, typename ... Args>
	void show_list3(T value, Args ... args);
	например тут show_list3(x*x, '!', 7, mr);
	первый аргумент сопоставляет тип T с double и value с x*x. Оставшиеся три типа
	(char, int, std::string) помещается в пакет Args, а оставшиеся три значения
	(!,7,mr) - в пакет args.
	Затем cout выводит значение value(которое x*x). Это есть вывод первого элемента
	в списке.
	Далее идет вызов show_list3(args...);
	С учетом развертывание он будет выглядеть так
	show_list3('!', 7, mr);
	И теперь выводится '!' и т.д. когда пакет пуст, вызывается версия без аргументов.
битовые операции.
операция сдвига.
операция сдвига имеет следующий синтаксис:
значение << сдвиг
значение - целочисленное значение, к котрому будет применена операция сдвига, а сдвиг - кол-во
байтов сдвига
например, выражение
13 << 3
сдвигает биты значения 13 на 3 позиции влево
при этом три бита выходят за пределы значения и отбрасываются, а новообразованные позиции справа
заполняются нулями
нумерация битов в байте соответствует связанной степени с основанием 2. поэтому самый правый
бит имеет номер 0, следующий бит - 1.
поскольку значение в каждой позиции бита представляет удвоенное значение бита, находящегося справа
, то смещение на одну позицию эквивалентно умножению на 2. так, смещение на две позиции влево
эквивалентно умножению на 2^2, а на n позиций - умножению на 2^n. таким образом, результатом
операции 13 << 3 является 13*2^3, или 104
exm:
int x = 20;
int y = x << 3;
этот код не изменяет значение x, а получает новое значение
чтобы в результате выполнения сдвига влево изменить значение переменной, необходимо использовать
присваивание, или операцию <<=, которая объединяет сдвиг и присваивание
x = x << 4;
y <<= 2;
операция сдвига вправо (>>) осуществляет сдвиг битов вправо. синтаксис:
значение >> сдвиг
пример:
17 >> 2 <- сдвигает биты в значении 17 на две позиции вправо
для беззнаковых целых чисел новообразованные позиции слева заполняются нулями, а биты, выходящие
за границы значения, отбрасываются. для целых чисел со знаками новообразованные позиции могут
быть заполнены нулями или значением исходного крайнего левого бита. выбор зависит от реализации
сдвиг на позицию вправо эквивалентен целочисленному делению на 2. в общем случае сдвиг на n
позиций вправо эквивалентен целочисленному движению на 2^n

операция ! преобразует true значение (!= 0) в false (0) и наоборот
операция ~ (отрицание) преобразует каждый отдельный бит в противоположный
операция | (или) комбинирует два целочисленных значения с целью получения нового целочисленного значения
каждый бит в новом значении устанавливается в 1, если первый или (и) второй бит == 1, иначе 0
операция |= комбинирует операцию | и =, т .е присваивание. a |= b -> (a | b)
операция ^ (исключающее или) комбинирует два целочисленных значения с целью получения нового целочисленного значения
каждый бит в новом значении устанавливается в 1, если первый или второй бит == 1, если первый
и второй бит == 0, то новый бит = 0, если первый и второй бит == 1, то новый бит = 0
операция ^= комбинирует операцию ^ и =, т .е присваивание. a ^= b -> (a ^ b)
операция & (и) комбинирует два целочисленных значения с целью получения нового целочисленного значения
каждый бит в новом значении устанавливается в 1, если первый И (!) второй бит == 1, иначе 0
операция &= комбинирует операцию & и =, т .е присваивание. a &= b -> (a & b)

В том случае, если вправо сдвигается отрицательное число, слева появляются единицы (поддерживается знаковый бит).

полубайт состоит из четырех бит
байт восемь бит
слово 16 бит
двойное слова 32 бит
4-байтное слово: 64 бит
Для 32-битных процессоров архитектуры x86: исторически машинным словом
считается 16 бит, реально — 32 бита.

11011011
1101 старший полубайт
1011 младший

Биты пронумерованы справа налево,  
начиная с нулевого, поэтому значение, соответствующее биту п, равно 2п. Например, целое 
число, в котором установлен в 1 только третий бит, имеет значение 2^3, или 8. В общем 
случае каждый индивидуальный бит соответствует степени 2, как было показано в  
приложении А. Таким образом, мы будем использовать термин бит для обозначения  
степени 2; это будет соответствовать ситуации, когда определенный бит установлен в 1, 
а все остальные биты — в 0. 

Освобождать память надо в обратном порядке выделения памяти
важно после.
delete pPointer;

делать 
pPointer = NULL;

Чтобы если не дай бох деструктор вызовется второй раз, то не
произойдет осовобождения по невалидному адресу, и не начнутся
странные трудновоспроизводимые баги.

namespace
Пространство имен может быть объявлено в нескольких блоках в одном файле и в нескольких
файлах. Компилятор соединит вместе все части во время
предварительной обработки и полученное в результате
пространство имен будет содержать все члены, объявленные во
всех частях. Примером этого является пространство имен std,
которое объявляется в каждом из файлов заголовка в стандартной библиотеке.

Директиву using можно поместить в верхнюю часть CPP-файла (в области видимости файла) или внутрь определения класса или функции.
Без особой необходимости не размещайте директивы using в файлах заголовков (*.h), так как любой файл, содержащий этот заголовок,
добавит все идентификаторы пространства имен в область видимости,
что может вызвать скрытие или конфликты имен, которые очень трудно отлаживать.

псевдонимы пространств имен:
namespace a_very_long_namespace_name { class Foo {}; }  
namespace AVLNN = a_very_long_namespace_name;  
void Bar(AVLNN::Foo foo){ }  

C++11
range-based for:
1. лучше использовать спецификатор auto, вместо конкретного типа
2. лучше использовать передачу по (константной)ссылке, чтобы не было временных переменных
for(auto x : {1,2,3,4}) cout << x << endl;


nullptr
использовать вместо макроса NULL или 0
для функций, которые возвращают указатель, можно возвращать nullptr
можно передавать его функцию с формальным параметром типа std::nullptr_t

auto:
1. для итераторов STL вместо
vector<double>::iterator pd = something.begin();
писать
autor pd = something.begin();

enums:
новые enum class и enum struct позволяют избежать конфликта одинаковых имен у перечислений.
enum class Color {red,blue,green};
enum class Traffic_light {green, yellow, red};
Color col = Color::red;
Traffic_light light Traffic_light::red;
class после enum определяет, что перечисление строго типизированно и что его перечислители
находятся в своей области видимости.
Мы не можем миксовать значение Traffic_light и Color
Color x = red // which red?
Color y = Traffic_light::red; // that red is not a Color
Color z = Color::red; // ok
Также мы не можем неявно миксовать целочисленные значения и Color
int i = Color::red; // red is not an int
Color c = 2; // 2 is not a color
Если нужна необходимость в этом, можно убрать class из определения перечисления.
enum class имеет только инициализацию, присваивание и сравнение. (== и <). Но так как это
пользовательский тип мы можем определить операторы для него:
Traffic_light& operator++(Traffic_light& t) // prefix increment
{
	switch(t) {
	case Traffic_light::green:		return t = Traffic_light::yellow;
	case Traffic_light::yellow:		return t = Traffic_light::red;
	case Traffic_light::red:		return t = Traffic_light::green;
	}
}
Traffic_light next = ++light; // name becomes Traffic_light::green cuz light = Traffic_light::red;

static_assert(A,S) print S as a compiler error message if A is not true.
например для проверки типа static_assert(4 <= sizeof(int), "int is smaller than we thought!");
static_assert mechanism can be used for anything that can be expressed in terms of constant
expressions.
The most important uses of static_asserts come when we make assertions about types used as 
parameters in generic programming.

constexpr: meaning rougly "to be evaluated at compile time". это используется обычно для определения
констант, которые размещаются в памяти, которая не должна быть испорчена, и для выполнения.
чтобы функция могла использоваться в константных выражениях, т.е., в выражениях, которые будут
подсчитаны компилятором, она должна быть определена как constexpr.

constexpr int SQRT(const int x) { return x*x; }
constexpr int CEX = 5*SQRT(5);
constexpr функция должна быть простой: просто возвращать подсчитываемое значение. conxtexpr
функция может быть использована для неконстантных аргументов, но когда это сделано, результат
не является constexpr. разрешено constexpr-функции вызывать с неконстантным аргументом в контексте,
который не запрашивает constexpr, поэтому не надо определять две таких же функции: с constexpr
и без.
в некоторых местах, constexpr запрашиваются языком(точки массива, case-метки, некоторые
аргументы шаблонов и константы, объявленные с constexpr). в других случаях подсчитывание во 
время компиляции важно для выполнения. независимо от этого, нотация о неизменяемости - важный
дизайн-вопрос.

Указатели и const
int integer{ 5 }, integer2{ 6 };
int* const Pi = &integer; // Константный указатель
const int* PiC = &integer2; //Указатель на константные данные
const int* const PiC = &integer; // Константный указатель на константные 
								//данные
правило, позволяющее легко запомнить, к чему относится const. Надо провести черту через "*",
если const слева, то оно относится к значению данных; если справа — к значению указателя.


как использовать неCONST методы в const-методах
Это мутицо при помощи адартера обьекта. 

// Вообщето православный адартер объекта должен работать с ссылкой или указателем на
адаптируемый обьект, ну да ладно
class ContainerAdapter
{
public:
unsigned count () const {return cont_.count () /*вызывается по-сути неконстантный метод*/}
private:
mutable Container cont_;
};

class MyContainer: public ContainerAdapter
{
//…
};

массивом указателей (int *a[]) или указателем на массив (int (*a)[]).

исключения out_of_range, lenght_error


как правильно писать:
if(answer == 'y') retrun true;
return false;

switch(answer) {
case 'y':
	return true;
case 'n':
	return false;
}

while() {
}

int count_x(char*p, char x)
{
	if(p == nullptr) return 0;
	int count = 0;
	for(; *p!=0; ++p)
		if(*p == x)
			++count;
	return count;
}

class Vector {
public:
private:
};

class complex {
	double re, im;
public:
	complex()
};

if(c !=b )
	c = -(b/a)+2*b;

использование абстрактного класса:
void use(Container& c)
{
	const int sz = c.size();
	
	for(int i{}; i != sz; ++i)
		cout << c[i] << '\n';
}

void g()
{
	Vector_container vc {10,6,4,2,6,7};
	use(vc);
}

double& List_container::operator[](int i)
{
	for(auto& x : Id) {
		if(i == 0) return x;
		--i;
	}
	throw out_of_range("list_container");
}	

ФУНКЦИИ ПРЕОБРАЗОВАНИЯ
#include <iostream>
#include <stdarg.h>
#include <ctime>
using namespace std;

template <typename ...Args>
void OK(const char* const format, Args ... args)
{
	va_list ap;
	va_start(ap, format);
	
	for (char *p = const_cast<char*>(format); *p; p++) {
		if (*p == '%') {
			switch (*++p) {
			case 'd': {
				cout << va_arg(ap, int); break; }
			case 'f': {
				cout << va_arg(ap, double); break; }
			case 'c': {
				//char chval = va_arg(ap, char);
				cout << va_arg(ap, char); break; }
			case 's': {
				cout << va_arg(ap, const char* const); break; }
			}
		} else cout << *p /*<< " "*/;
	}
	va_end(ap);
}

class smt {
private:
	double a = 5.4;
public:
	operator int() const; // можно использовать explicit, чтобы запретить неявное преобразование
							// или использовать функцию, вместо функции преобразования
};

smt::operator int() const { return int(a + 0.5); // округление int; }

int main() {
	smt s;
	int d{ s };
	cout << s /*если > 1 функции преобразования, то надо кастить явно*/ << endl;
}

подсчет времени
clock_t start{ clock() };

cout  << endl << (double)(clock() - start) / CLOCKS_PER_SEC << endl;

НАСЛЕДОВАНИЕ СТРАУСТРУПА
class Shape {
protected:
	typedef int Point;
public:
	// see 3.3.4 to know
	Shape(const Shape&) = delete;
	Shape& operator=(const Shape&) = delete;
	Shape(Shape&&) = delete;
	Shape& operator=(Shape&&) = delete;

	virtual Point center() const = 0;
	virtual void move(Point to) = 0;
	virtual void draw() const = 0;
	virtual void rotate(int angle) = 0;

	virtual ~Shape() {}
};

class Circle : public Shape {
public:
	Circle(Point p, int rr);
	Point center() const { return x; }
	void move(Point to) { x = to; }
	void draw() const;
	void rotate(int) {}
private:
	Point x;
	int r;
};

class Smiley : public Circle {
	Smiley(Point p, int r) : Circle{ p,r }, mouth{ nullptr } {}
	~Smiley() { delete mouth; for (auto p : eyes) delete p; }
	void move(Point to);
	void draw() const;
	void rotate(int);
	void add_eye(Shape* s) { eyes.push_back(s); }
	void set_mouth(Shape* s);
	virtual void wink(int i);

private:
	vector<Shape*> eyes;
	Shape* mouth;
};

void Smiley::draw() const
{
	Circle::draw();
	for (auto p : eyes)
		p->draw();
	mouth->draw();
}

void rotate_all(vector<Shape*>& v, int angle)
{
	for (auto p : v)
		p->rotate(angle);
}

enum class Kind {circle, triangle, smiley };
// лучше тут возвращать unique_ptr<Shape>
Shape* read_shape(istream& is)
{
	Kind k;
	switch (k) {
	case Kind::circle:
		// лучше возвращать unique_ptr<Shape>{new Circle{p,r}}; итд
		return new Circle{ p,r };
	case Kind::triangle:
		return new Triangle{ p1,p2,p3 };
	case Kind::smiley:
		Smiley* ps = new Smiley{ p,r };
		ps->add_eye(e1);
		ps->add_eye(e2);
		ps->set_mouth(m);
		return ps;
	}
}

void user() // version 1
{
	// а тут использовать unique_ptr<std::vector<Shape>> v
	std::vector<Shape*> v;
	while (cin)
		v.push_back(read_shape(cin));
	draw_all(v);
	rotate_all(v, 45);
	for (auto p : v) delete p;// тогда не надо вызывать delete
}

template<class C, class Oper>
void for_all(C& c, Oper op)
{
	for(auto& x: c)
		op(*x); // pass op() a reference to each element pointed to
}

void user() // version2
{
	vector<unique_ptr<Shape>> v;
	while(cin)
		v.push_back(read_shape(cin));
	for_all(v, [](Shape& s) {s.draw();}; // draw all;
	for_all(v, [](Shape& s) {s.rotate(45)}; // rotate all(45)
	
}





COPY CONSTRUCTOR
Vector::Vector(const Vector& a)
	:elem{new double[sz]}, sz{a.sz}
{
	for(int i = 0; i != sz; ++i)
		elem[i] = a.elem[i];
}

COPY ASSIGNMENT
Vector::operator=(const Vector& a)
{
	double* p = new double[a.sz];
	for(int i =0 ; i != a.sz; ++i)
		p[i] = a.elem[i];
	delete[] elem;
	elem = p;
	sz = a.sz;
	return *this;
}

MOVE CONSTRUCTOR
Vector::Vector(Vector&& a)
	:elem{a.elem},
	sz{a.sz}
{
	a.elem = nullptr;
	a.sz = 0;
}

z = x; // we get a copy
y = std::move(x); // we get a move
return z; // we get a move

Vector operator+(const Vector& a, const Vector& b)
{
	if(a.size() != b.size())
		throw Vector_size_mismatch{};
	
	Vector res(a.size());
	for(int i = 0; i != a.size(); ++i)
		res[i] = a[i] + b[i];
	return res;
}

TEMPLATES
To support the range-for loop for our class, we must define suitable begin() and end() function:
template <typename T>
T* begin(Vector<T>& x) 
{
	return &x[0];
}

template <typename T>
T* end(Vector<T>& x) 
{
	return &x[0]+x.size(); // pointer to one-last-past element.
}

Given those, we can write:
void f2(const Vector<string>& vs)
{
	for(auto& s : vs)
		cout << s << endl;
}

Funtors:
template <typename T>
class Less_than {
	const T val;
public:
	Less_than(const T& val) : val(v) {}
	bool operator()(const T& x) {return x < val;}
};

Less_than<int> lti{42};
Less_than<string> lts{"Backus"};

void fct(int n, const string& s)
{
	bool b1 = lti(n); // true if n < 42
	bool b2 = its(s); // true if s < "Backus"
}

template<typename C, typename P>
int count(const C& c, P pred)
{
	int cnt = 0;
	for(const auto& x : c)
		if(pred(x))
			++cnt;
	return cnt;
}

void f(const Vector<int>& vec, const list<string>& lst, int x, const string& s)
{
	cout << "number of values less than " << x << ": "
		<< cout << count(vec,Less_than<int>{x});
	
}

We don't have to write a separate function for each value (and each type), and we don't have
to introduce nasty global variables to hold values.
We have to define Less_than separately from its use. That could be seen as inconvenient

void f(const Vector<int>& vec, const list<string>& lst, int x, const string& s)
{
	cout << "number of values less than " << x << ": "
		<< cout << count(vec,[&](int a) {return a < x ;});
	
}

template <typename T, typename ... Tail>
void f(T head, Tail.... tail)
{
	g(head);
	f(tail...);
}

void f() {}

the standard header <cstddef> contains a definition of the alias size_t, maybe:
using size_t = unsigned int;

This allows us to write code that will work for every container that follows this conversation.
template <typename T>
class Vector {
public:
	using value_type = T;
};

template <typename C>
using Element_type = typename C::value_type;

template <typename Container>
// примерный тип Container COut<int>>, так как он имеет value_type alias
void algo(Container& c)
{
	Vector<Element_type<Container>> vec;
}

This aliasing mechanism can be used to define a new template by binding some or all template args.
template <typename Key, typename Value>
class Map {
};

template <typename Value>
using String_map = Map<string, Value>

String_map<int> m; // m is a Map<string, int>

INPUT\OUTPUT STREAM IN C++
struct Entry {
	string name;
	int number;
};

ostream& operator<<(ostream& os, const Entry& e)
{
	return os << "{\"" << e.name << "\", " << e.number << "}";
}

istream& operator>>(istream& is, Entry& e)
{
	char c, c2;
	if (is >> c && c == '{' && is >> c2 && c2 == '"') {// starts with a {"
		string name;
		while (is.get(c) && c != '"')
			name += c;

		if (is >> c && c == ',') {
			int number = 0;
			if (is >> number >> c && c == '}') { // read the number and a }
				e = { name, number }; // assign to the entry
				return is;
			}
		}
	}
	is.setf(ios_base::failbit);
	return is;
}

The is >> c skips whitespace by default, but is.get(c) does not, so that this Entry-operator
ignores whitespace outside the name string, but not within it. For example:
{ "John Marwood Cleese", 123456		}
{"NOT John Marwood Cleese",123456}

int main()
{
	for (Entry ee; cin >> ee;)
		cout << ee << '\n';

	system("PAUSE");
}

Consequently, I often use a simple range-checking adaptation of vector:
template <typename T>
class Vec : public vector<T> {
public:
	using vector<T>::vector; // use the constructors from vector (under the Vec name);

	T& operator[](int i) // range check
		{ return vector<T>::at(i); }

	const T& operator[](int i) const // range check const objects
		{return vector<T>::at(i);}
};
Vec inherits everything from vector except for the subscript operations that it redifines to
do range checking.
The at() operation is a vector subscript operation that throws an exception of type out_of_range
if its argument is out of the vector's range.
For Vec, an out-of-range access will throw an exception that the user can catch. For example:
void checked(Vec<Entry>& book)
{
	try {
		book[book.size()] = {"Joe", 99999};
		//...
	}
	catch(out_of_range) {
		cout << "range_error\n";
	}
}
The exception will be thrown, and the caught.
One way to minimize surprises from uncaught exceptions is to use a main() with a try-block
as its body. For example:
int main()
{
	try {
		// your code
	}
	catch(out_of_range) {
		cerr << "range error\n";
	}
	catch(...) {
		cerr << "unknown exception thrown\n";
	}
}
Some implementation save you the bother of defining Vec (or eqivalent) by providing a range-
checked vectsion of vector (e.g., as a complier option)

list
The standard library offers a double-linked list called list.
We use a list for sequences where we want to insert and delete elements without moving other
elements. Insertion and deletion of phone book entries could be common, so a list could be
appropriate for representing a simple phone book. For example:
list<Entry> phone_book = {
	{"david", 1345},
	{"adad", 34456},
	{"dergerg", 435}
};
When we use a linked list, we tend not to access elements using subscripting the way we commonly
do for vectors. Instead, we might search the list looking for an element with a given value.
To do this, we take an advantage of the fact that a list is a sequence as described in $4.5:
int get_number(const string& c)
{
	for(const auto& x: phone_book) 
		if(x.name == s)
			return x.number;
	return 0; // use 0 to represent "number not found"
}
The search for s starts at the beginning of the list and procceds until s is found or the end
of phone_book is reached.
Using iterators explicitly, we can - less elegantly - write the get_number() function like this:
int get_number(const string& s)
{
	for(auto p = phone_book.begin(); p != phone_book.end(); ++p)
		if(p->name==s)
			return p->number;
	return 0; // use 0 to represent "number not found"	
}
Given an iterator p, *p is the element to which it refers, ++p advances p to refer to the next
element, and when p refers to a class with element m, then p->m is equivalent to (*p).m;
Adding elements to a list and removing elements form a list is easy:
void f(const Entry& ee, list<Entry>::iterator p, list<Entry>::iterator q)
{
	phone_book.insert(p,ee); // add ee before the element reffered to by p
	phone_book.remove(q); // remove the element reffered to by q;
}
These examples could be written identically using vector and (surprisingly, unless you understand
machine architecture) perform better with a small vector than a small list.
When all we want is a sequence of elements, we have a choice between using a vector and a list.
Unless you have a reason not to, use a vector. A vector performs better for traversal (e.g.,
find() and count()) and for sorting and searching(e.g., sort(), and binary_search())
A LINEAR SEARCH IS UNIFFICIENT FOR ALL BUT THE SHORTEST LISTS

map
The standard library offers a search tree (a red-black tree) called map:
The standard library map is a container of paris of values optimized for lookup
map<string, int> phone_book = {
	{"david", 1345},
	{"adad", 34456},
	{"dergerg", 435}
};
When indexed by a value of its first type (called the key), a map returns the corresponding 
value of the second type (called the value or the mapped type). For example:
int get_number(const string& s)
{
	return phone_book[s];
}
If a key isn't found, it is entered into the map with a default value for its value (for
integer it's 0); the value I just happened to choose represents an invalid telephone number.
If we wanted to avoid entering invalid numbers into our phone book, we could use find() and
insert() instead of [].

unordered_map
The cost of a map lookup is O(log(n)) where n is the number of elements is the map. That's
pretty good. For example, for a map with 1,000,000 elements, we perform only about 20 comparsions
and indirections to find an element.
unordered_map<string, int> phone_book = {
	{"david", 1345},
	{"adad", 34456},
	{"dergerg", 435}
};
As for map, we can subscript an unordered_map.
The standard-library unordered_map provides a default hash function for strings. If necessary,
you can provide your own.

ALGORITHMS
The following sorts a vector and places a copy of each unique vector element on a list:
bool operator<(const Entry& x, const Entry& y) // less than
{
	return x.name < y.name; // order Entrys by their names
}

void f(vector<Entry>& vec, list<Entry>& lst)
{
	sort(vec.begin(), vec.end()); // use < for order
	// to avoid errors, lst must have at least as many elements as there are unique value in vec
	unique_copy(vec.begin(), vec.end(), lst.begin()); // don't copy adjacent equal elements
}

If we wanted to place the unique elements in new container, we could've written:
list<Entry> f(vector<Entry>& vec)
{
	list<Entry> res;
	sort(vec.begin(), vec.end());
	unique_copy(vec.begin(), vec.end(), back_inserter(res)); // append to res
	return res;
}

A back inserter() adds elements at the end of a container, extending the container to make room
for them. Thus, the standard container plus back inserter()s eliminate the need to use error-
prone, explicit C-style memory management using realloc().
If you find the pair-of-iterators style of code, such as sort(vec.begin(), vec.end()), tedious,
you can define container version of the algorithm and write sort(vec).

Use of iterators.
Many algorithms return iterators. For example, the standard algorithm find looks for a value
in a sequence and returns an iterator to the element found:
bool has_c(const string& s, char c) // does s contain the character c?
{
	auto p = find(s.begin(), s.end(), c);
	if(p!=s.end)
		return true;
	else
		return false;
}

Like many standard-library search algorithms, find returns end() to indicate "not found".
And equivalent, shorter, definition of has_c() is:
bool has_c(const string& s, char c) // does s contain the character c?
{
	return find(s.begin(), s.end(), c)!=s.end();
}
A more interesting excercise would be to find the location of all occurrences of a character
in a string. We can return the set of occurrences as a vector of string iterators. Returning
a vector is efficient because of vector provides move semantics. Assuming that we would like
to modify the location found, we pass a non-const string:
vector<string::iterator> find_all(string& s, char c) // find all occurrences of c in s
{
	vector<string::iterator> res;
	for(auto p = s.begin(), p != s.end(), ++p)
		if(*p == c)
			res.push_back(p);
	return res;
}

We iterate through the string using a conventional loop, moving the iterator p forward one
element at a time using ++ and looking at the elements using the dereference operator *. We
could test find_all() like this:
void test()
{
	string m {"Mary had a little lamb"};
	for(auto p : find_all(m,'a'))
		if(*p!='a')
			cerr << "a bug!\n";
}

Iterators and standard algorithms work equivalently on every standard container for which their
use makes sense. Consequently, we could generalize find_all():
template <typename C, typename V>
vector<typename C::iterator> find_all(C& c , V v) // find all occurrences of v in c
{
	vector<typename C::iterator> res;
	for(auto p = c.begin(); p != c.end(); ++p)
		if(*p==v)
			res.push_back(p);
	return res;
}
The typename is needed to inform the compiler that C's iterator is supposed to be a type and not
a value of some type, say, the integer 7. We can hide this implementation detail by introducing
a type alias for iterator:
template <typename T>
using iterator<T> = typename T::iterator;

template <typename C, typename V>
vector<iterator<C>> find_all(C& c , V v)
{
	vector<iterator<C>> res;
	for(auto p = c.begin(); p != c.end(); ++p)
		if(*p==v)
			res.push_back(p);
	return res;
}

We can now write:

void test()
{
	string m {"Mary had a little lamb"};
	for(auto p : find_all(m,'a'))
		if(*p!='a')
			cerr << "string bug!\n";
			
	list<double> ld{1.1,2.2,3.3,1.1};
	for(auto p : find_all(ld, 1.1))
		if(*p != 1.1)
			cerr << "list bug!\n";
			
	vector<string> vs {"red", "blue", "green", "green", "orange", "green"};
	for(auto p : find_all(vs, "green"));
		if(*p!="green")
			cerr << "vector bug!\n";
			
	for(auto p : find_all(vs, "green")
		*p = "vert";
}

Iterator types.
Any particular iterator is an object of some type. There are, however, many different iterator
types, because an iterator needs to hold the information necessary for doing its job for a
partucular container type.
For example, a vector's iterator could be an oridnary pointer, because a pointer is quite a
reasonable way of reffering to an element of a vector.
Alrernatively, a vector iterator could be implemented as a pointer to the vector plus an index:
What is common for all iterators is their semantics and the naming of their opeartions.
For example, applying ++ to any iterator yields an iterator that refers to the next element.
Similarly, * yields the element to which the iterator refers.
We rarely have to worry about the details of how that type is defined.

4.5.3 Stream iterators
Containers are not the only place where we find sequences of elements.
To make an ostream_iterator, we need to specify which stream will be using and the type of 
objects written to it. For example:
ostream_iterator<string> oo{cout}; // write strings to cout
int main()
{
	*oo = "Hello, "; // meaning cout << "Hello, ";
	++oo; // This is done to mimic writing into an array through a pointer.
	*oo = "world!\n";
}
Similarly, an istream_iterator is something that allows us to treat an input stream as a read-
only container. Again, we must specify the stream to be used and the type of values expected:
istream_iterator<string> ii {cin};
Typically, istream\ostream iterators are not used directly. Instead, they are provided as
arguments to algorithms. For example, we can write a simple program to read a file, sort the
words read, eliminate duplicates, and write the result to another file:

int main()
{
	string from, to;
	cin >> from >> to; // get source and target file names.
	
	ifstream is{from}; // input stream for file "from"
	istream_iterator<string> ii {is}; // input iterator for stream
	istream_iterator<string> eos {}; // input sentinel
	
	ofstream os{to}; // output stream for file "from"
	ostream_iterator<string> oo {os, "\n"}; // output iterator for stream
	
	vector<string> b {ii, eos}; // b is a vector initialized from input [ii:eos)
	sort(b.begin(), b.end()); // sort the buffer
	
	unique_copy(b.begin(), b.end(), oo); // copy to buffer output, discard replicated values
	
	return !is.eof() || !os; // return error state.
}

The ostream_iterator's second argument is used to delimit output values.
This program is longer than it needs to be. A more elegant  soultion is not to store duplicates
at all. This can be done by keeping the strings in a set, which does not keep duplicates and
keeps its elements in order. That way, we could replace the two lines using a vector with one
using a set and replace unique_copy() with the simpler copy():
set<string> b{ii, eos}; // collect strings from input
copy(b.begin(), b.end(), oo); // copy buffer to output

We used the name ii, eos, and oo only once, so we could further reduce the size of the program:
int main()
{
	string from, to;
	cin >> from >> to; // get source and target file names.
	
	ifstream is{from}; // input stream for file "from"
	ofstream os{to}; // output stream for file "from"
	
	set<string> b {istream_iterator<string> {is}, istream_iterator<string>{}}; // read input
	copy(b.begin(), b.end(), ostream_iterator<string>{os, "\n"}); // copy output
		
	return !is.eof() || !os; // return error state.
}

It's a matter of taste and experience whether or not this last simplification improves readability.

4.5.4 Predicates.
In the example above, the algorithms have simply "built in" the action to be done for each
element of a sequence. However, we often want to make that action a parameter to the algorithm.
For example, the find algorithm provides a convenient way of looking for a specific value.
A more general variant looks for an element that fulfills a specified requirement, a predicate.
For example, we might want to search a map for the first value larger than 42. A map allows us
to access its elements as a sequence (key, value) pairs, so we can search a map<string, int>'s
sequence for a pair<const string, int> where the int is greater than 42:
void f(map<string, int>& m)
{
	auto p = find_if(m.begin(), m.end(), Greater_than{42});
	// ...
}

Here, greater is a function object holding the value (42) to be compared agains:
struct Greater_than {
	int val;
	Greater_than(int v) : val{v};
	bool operator()(const pair<string, int>& r) {return r.second > val;}
};

Alternatively, we could use a lambda expression:
int cxx = count_if(m.begin(), m.end(), [](const pair<string, int> & r) {return r.second >42;});
A half-open sequence from b to e is referred to as [b:e).
Here are a few I have found particularly useful:
Selected Standard Algorithms 
p=find(b,e,x) p is the first p in [b:e) so that ?p==x 
p=find_if(b,e,f) p is the first p in [b:e) so that f(?p)==true 
n=count(b,e,x) n is the number of elements ?q in [b:e) so that ?q==x 
n=count_if(b,e,f) n is the number of elements ?q in [b:e) so that f(?q,x) 
replace(b,e,v,v2) Replace elements ?q in [b:e) so that ?q==v by v2 
replace_if(b,e,f,v2) Replace elements ?q in [b:e) so that f(?q) by v2 
p=copy(b,e,out) Copy [b:e)to[out:p) 
p=copy_if(b,e,out,f) Copy elements ?q from [b:e) so that f(?q) to [out:p) 
p=unique_copy(b,e,out) Copy [b:e)to[out:p); don’t copy adjacent duplicates 
sort(b,e) Sort elements of [b:e) using < as the sorting criterion 
sort(b,e,f) Sort elements of [b:e) using f as the sorting criterion 
(p1,p2)=equal_range(b,e,v) [p1:p2) is the subsequence of the sorted sequence [b:e) with the value v; basically a binary search for v 
p=merge(b,e,b2,e2,out) Merge two sorted sequences [b:e) and [b2:e2) into [out:p) 
These algorithms, and many more (see Chapter 32), can be applied to elements of containers, 
strings, and built-in arrays. 

A sequence is defined by a pair of iterators [begin:end). This is general and flexible, but most often, 
we apply an algorithm to a sequence that is the contents of a container. For example: 
sort(v.begin(),v.end()); 
Why don’t we just say sort(v)? We can easily provide that shorthand: 
namespace Estd {
	using namespace std;
	
	template <class C>
	void sort(C& c)
	{
		sort(c.begin(), c.end());
	}
	
	template <class C, class Pred>
	void sort(C& c, Pred p)
	{
		sort(c.begin(), c.end(), p);
	}
}

I put the container versions of sort() (and other algorithms) into their own namespace Estd 
(‘‘extended std’’) to avoid interfering with other programmers’ uses of namespace std. 

RESOURCE MANAGEMENT
This technique is used for STD lock classes:
mutex m; // used to protect access to shared data

void f()
{
	unique_lock<mutex> lck {m}; // acquire the mutex m
	// ... manipulate shared data ...
}

A thread will not proceed until lck's constructor has acquired its mutex, m. The corresponding
destrcutor releases the resource. So, in this example, unique_lock's destructor releases the
mutex when the thread of control leaves f() (through a return, by "falling off the end of the
function", or through an exception throw). This is an application of RAII.

UNIQUE_PTR, SHARED_PTR
void f(int i, int j)
{
	X* p = new X; // allocate a new X
	unique_ptr<X> sp {new X}; // allocate a new X and give its pointer to unique_ptr.
	// ...
	if (i < 99) throw Z{}; // may thrown an exception;
	if(j<77) return; // may return "early"
	p->do_something();  // may thrown an exception;
	sp->do_something(); // may thrown an exception;
	// ...
	delete p; // destroy *p;
}

Here, we "forgot" to delete p if i<99 or if j<77. On the other hand, unique_ptr ensures that
its object is properly destroyed whichever way we exit f(). Ironically, we could've solved
the problem simply by not using a pointer and not using new.
Unfortunately, overuse of new (and of pointers and references) seems to be an increasing problem.
However, when you really need the semantics of pointers, unique_ptr is a very lightweight 
mechanism with no space or time overhead compared to correct use of a built-in pointer.
Its further uses includes passing free-store allocated objects in and out of functions:
unique_ptr<X> make_X(int i)
	// make an X and immediately give it to a unique_ptr
{
	// check i, etc. ...
	return unique_ptr<X> {new X{i}};
}

The shared_ptr is similar to unique_ptr except that shared_ptrs are copied rather than moved.
The shared_ptr for an object share ownership of an object and that object is destroyed when
the last of its shared_ptr is destroyed. For example:

void f(shared_ptr<fstream>);
void g(shared_ptr<fstream>);

void user(const string& name, ios_base::openmode mode)
{
	shared_ptr<fstream> fp {new fstream(name, mode)};
	if(!*fp) throw No_file{}; // make sure the file was properly opened.
	
	f(fp);
	g(fp);
	// ...
}

THREADS
void f() {cout << "Hello, "; }; // function

struct F { // function object
	void operator()() {cout << "Parallel world!\n";}; // F's call operator
};

void user()
{
	thread t1 {f}; f() executes in separate thread
	thread t2 {F()}; // F()() executes in separate thread
	
	t1.join();  // wait for t1
	t2.join();  // wait for t2
}

The joins ensure that we don't exit user() until the threads have completed. To "join" means
to "wait for the thread to terminate".

The example above is an example of a bad error. Here, f and F() each use object cout without
any form of synchronization. The resultinh output would be unpredictable and could vary between
different executions of a program because the order of execution of the individual operations
in the two tasks is not defined. The program may produce "odd" output, such as
	PaHerallllel o World!
When defining tasks of a concurrent program, our aim is to keep tasks completely separated
except where they communicate in simple and obvious ways. The simplest way of thinking of a
concurrent tasks is as a function that happens to run concurrently with its caller. For that
to work, we just have to pass arguments, get a result back, and make sure that there's no use
of shared data in between (no data races).

5.3.2 Passing arguments.
Typically, a task needs data to work upon. We can easily pass data as arguments. Consider:
void f(vector<double>& v); // function do something with v

struct F { // function object: do something with v
	vector<double>& v;
	F(vector<double>& vv) : v{vv} {}
	void operator()(); // application operator
};

int main()
{
	vector<double> some_vec {1,4,6,3,7};
	vector<double> vec2 {10,11,12,13,14};
	thread t1{f, some vec}; // f(some_vec) executes in separate thread
	thread t2{F{vec2}}; // F(vec2)() executes in separate thread
	
	t1.join();
	t2.join();
}

5.3.3 Returning results
A less obscure technique is to pass the input data by const reference and to pass the location
of a place to deposit the result as a separate argument:
void f(const vector<double>& v, double* res); // take input from v; place result in *res

class F {
public:
	F(const vector<double>& vv, double *p) : v{vv}, res{p} {}
	void operator()(); // place result in *res
private:
	const vector<double>& v; // source of input
	double* res; // target for output
};

int main()
{
	vector<double> some_vec, vec2;
	// ...
	
	double res1, res2;
	
	thread t1 {f, some_vec, &res1}, t2 {F{vec2& res2}};
	
	t1.join(); t2.join();
	
	cout << res1 << ' ' << res2 << '\n';
}

5.3.4
Sharing Data
Sometimes tasks need to share data. 
In that case, the access has to be synchronized so that at most 
one task at a time has access.

mutex m; // controlling mutex
int sh; // shared data

void f()
{
	unique_lock<mutex> lck {m}; // acquire mutex
	sh += 7; // manipulate shared data
	// release mutex implicitly
}

The unique_lock’s constructor acquires the mutex (through a call m.lock()). If another thread has 
already acquired the mutex, the thread waits (‘‘blocks’’) until the other thread completes its access. 
Once a thread has completed its access to the shared data, the unique_lock releases the mutex (with 
a call m.unlock()). The mutual exclusion and locking facilities are found in <mutex>. 
The correspondence between the shared data and a mutex is conventional: the programmer simply 
has to know which mutex is supposed to correspond to which data. Obviously, this is error-prone, 
and equally obviously we try to make the correspondence clear through various language means. 
For example: 
class Record {
public:
	mutex rm;
	// ...
};

It doesn’t take a genius to guess that for a Record called rec, rec.rm is a mutex that you are supposed 
to acquire before accessing the other data of rec, though a comment or a better name might have 
helped a reader. 

It is not uncommon to need to simultaneously access several resources to perform some action. 
This can lead to deadlock. For example, if thread1 acquires mutex1 and then tries to acquire mutex2 
while thread2 acquires mutex2 and then tries to acquire mutex1, then neither task will ever proceed 
further. The standard library offers help in the form of an operation for acquiring several locks 
simultaneously: 
void f()
{
	// ...
	unique_lock<mutex> lck1 {m1, defer_lock}; // defer_lock : don't yet try to acquire the mutex
	unique_lock<mutex> lck2 {m2, defer_lock};
	unique_lock<mutex> lck3 {m3, defer_lock};
	// ...
	lock(lck1, lck2, lck3); // acquire all three locks
	//.. manipulate shared data
} // implicitly release all mutex

This lock() will only proceed after acquiring all its mutex arguments and will never block (‘‘go to 
sleep’’) while holding a mutex. The destructors for the individual unique_locks ensure that the 
mutexes are released when a thread leaves the scope. 

5.3.4.1 Waiting for Events 
Sometimes, a thread needs to wait for some kind of external event, such as another thread complet- 
ing a task or a certain amount of time having passed. The simplest ‘‘event’’ is simply time passing. 

using namespace std::chrono;

auto t0 = high_resolution_clock::now();
this_thread::sleep_for(milliseconds{20});
auto t1 = high_resolution_clock::now();
cout << duration_cast<nanoseconds>(t1-t0).count() << " nanoseconds passed\n";

Consider the classical example of two threads communicating by passing messages through a
queue.

class Message {
	// ...
};

queue<Message> mqueue; // the queue of messages
condition_variable mcond; // the variable communicating events
mutex mmutex; // the locking mechanism

The consumer() reads and processes Messages:

void consumer()
{
	while(true) {
		unique_lock<mutex> lck{mmutex}; // acquire mutex
		while(mcond.wait(lck) /*do nothing*/; // release lck and wait;
											// re-acquire lck upon wakeup
		auto m = mqueue.front(); // get the message;
		mqueue.pop();
		lck.unlock(); // release lck
		// ... process m ...
	}
}

The corresponding producer looks like this:

void producer()
{
	while(true) {
		Message m;
		// ... fill the message ...
		unique_lock<mutex> lck {mmutex}; // protect operations
		mqueue.push(m);
		mcond.notify_one(); // notify
	} // releases lock (at the end of scope)
}

FUTURE AND PROMISE
void f(promise<X>& px) // a task: place the result in px 
{ 
	// ... 
	try { 
	X res; 
	// ... compute a value for res ... 
	px.set_value(res); 
	} 
	catch (...) { 
	// oops: couldn’t compute res 
	// pass the exception to the future’s thread: 
	px.set_exception(current_exception()); 
	} 
}

The current_exception() refers to the caught exception (§30.4.1 .2). 
To deal with an exception transmitted through a future, the caller of get() must be prepared to 
catch it somewhere. For example: 
void g(future<X>& fx) 
	// a task: get the result from fx 
	{ 
	// ... 
	try { 
	Xv=fx.get(); // if necessary, wait for the value to get computed 
	//...usev... 
	} 
	catch (...) { 
	// oops: someone couldn’t compute v 
	// ... handle error ... 
	} 
} 

5.4 .2.1 iterator_traits 
The standard-library sort() takes a pair of iterators supposed to define a sequence (§4.5). Further- 
more, those iterators must offer random access to that sequence, that is, they must be random- 
access iterators. Some containers, such as forward_list, do not offer that. In particular, a for- 
ward_list is a singly-linked list so subscripting would be expensive and there is no reasonable way 
to refer back to a previous element. However, like most containers, forward_list offers forward iter- 
ators that can be used to traverse the sequence by algorithms and for-statements (§33.1 .1). 
The standard library provides a mechanism, iterator_traits that allows us to check which kind of 
iterator is supported. Given that, we can improve the range sort() from §4.5.6 to accept either a 
vector or a forward_list. For example: 
void test(vector<string>& v, forward_list<int>& lst) 
{ 
	sort(v); // sort the vector 
	sort(lst); // sort the singly-linked list 
} 
The techniques needed to make that work are generally useful. 
First, I write two helper functions that take an extra argument indicating whether they are to be 
used for random-access iterators or forward iterators. The version taking random-access iterator 
arguments is trivial: 
ptg10564057 
Section 5.4 .2 .1 
iterator_traits 125 
template<typename Ran> 
// for random-access iterators 
void sort_helper(Ran beg, Ran end, random_access _iterator_tag) 
// we can subscript into [beg:end) 
{ 
	sort(beg,end); 
	// just sort it 
} 
The version for forward iterators is almost as simple; just copy the list into a vector, sort, and copy 
back again: 
template<typename For> 
// for forward iterators 
void sort_helper(For beg, For end, forward_iterator_tag) // we can traverse [beg:end) 
{ 
	vector<decltype(?beg)> v {beg,end}; // initialize a vector from [beg:end) 
	sort(v.begin(),v.end()); 
	copy(v.begin(),v.end(),beg); 
	// copy the elements back 
} 
The decltype() is a built-in type function that returns the declared type of its argument (§6.3 .6 .3). 
Thus, v is a vector<X> where X is the element type of the input sequence. 
The real ‘‘type magic’’ is in the selection of helper functions: 
template<typname C> 
void sort(C& c) 
{ 
	using Iter = Iterator_type<C>; 
	sort_helper(c.begin(),c.end(),Iterator_category<Iter>{}); 
} 
Here, I use two type functions: Iterator_type<C> returns the iterator type of C (that is, C::iterator) and 
then Iterator_category<Iter>{} constructs a ‘‘tag’’ value indicating the kind of iterator provided: 
• 
std::random_access _iterator_tag if C’s iterator supports random access. 
• 
std::forward_iterator_tag if C’s iterator supports forward iteration. 
Given that, we can select between the two sorting algorithms at compile time. This technique, 
called tag dispatch is one of several used in the standard library and elsewhere to improve flexibil- 
ity and performance. 
The standard-library support for techniques for using iterators, such as tag dispatch, comes in 
the form of a simple class template iterator_traits from <iterator> (§33.1 .3). This allows simple defi- 
nitions of the type functions used in sort(): 
template<typename C> 
using Iterator_type = typename C::iterator; // C’s iterator type 
template<typename Iter> 
using Iterator_category = typename std::iterator_traits<Iter>::iterator_category; // Iter’s category 
If you don’t want to know what kind of ‘‘compile-time type magic’’ is used to provide the standard- 
library features, you are free to ignore facilities such as iterator_traits. But then you can’t use the 
techniques they support to improve your own code. 

5.4.2.2 Type Predicates


A standard-library type predicate is a simple type function that answers a fundamental question 
about types. For example: 
bool b1 = Is_arithmetic<int>(); // yes, int is an arithmetic type 
bool b2 = Is_arithmetic<string>(); // no, std::string is not an arithmetic type 

These predicates are found in <type_traits> and described in §35.4 .1 . Other examples are is_class, 
is_pod, is_literal_type, has_virtual_destructor, and is_base_of. They are most useful when we write 
templates. For example: 
template<typename Scalar>
class complex {
	Scalar re, im;
public:
	static_assert(Is_arithmetic<Scalar>(), "Sorry, I only support complex of arithmetic types");
};

To improve readability compared to using the standard library directly, I defined a type function:

template <typename T>
constexpr bool Is_arithmetic()
{
	return std::is_arithmetic<T>::value;
}

Older programs use ::value directly instead of (), but I consider that quite ugly and it exposes imple- 
mentation details. 

6.2.2 Booleans
A Boolean is used to express the result of logcal operations. For example:
void f(int a, int b)
{
	bool b1 {a==b}; // if a and b have the same value, b1 becomes true; otherwise, b1 becomes false.
}

A common use of bool is as the type of the result of a function that tests some conditions
(a predicate). For example:
bool is_open(File*);
bool greater(int a, int b) {return a > b;}
By definition, true has the value 1 when converted to an integer and false has the value 0.
Con-versely, integers can be implicitly converted to bool values: nonzero integers convert to true and 0 
converts to false. For example: 
bool b1 = 7; // 7!=0, so b becomes true 
bool b2 {7}; // error: narrowing (§2.2 .2, §10.5) 
int i1 = true; // i1 becomes 1 
int i2 {true}; // i2 becomes 1 
If you prefer to use the {}-initializer syntax to prevent narrowing, yet still want to convert an int to a 
bool, you can be explicit: 
void f(int i) 
{ 
	bool b {i!=0}; 
// ... 
};

bool a = true, b = true;
bool x = a+b; // a+b is 2, so x becomes true
bool y = a||b; // a||b is 1, so x becomes true ('||' means 'or')
bool z = a-b; // a-b is 0, so z becomes false

A pointer can be implicitly converted to a bool. A non-null pointer converts to true; pointers
with the value nullptr converts to false. For example:
voif g(int* p)
{
	bool b = p; // narrows to true or false
	bool b2 {p!=nullptr}; // explicit test against nullptr
	
	if(p) { // eqivalent to p!=nullptr
		// ...
	}
}

I prefer if (p) over if (p!=nullptr) because it more directly expresses the notion ‘‘if p is valid’’ and also 
because it is shorter. The shorter form leaves fewer opportunities for mistakes. 

Characters.
_t suffix is often used to denote aliases (typedef use).
char fits in 1 byte. There are embedded processors without byte accessing hardware for 
which a char is 4 bytes. Also, one could reasonably use a 16-bit Unicode encoding for the 
basic chars. 
 Here's a loop that outputs the integer value of any character you care to input. For example:
 void intval()
 {
	for(char c; cin >> c; )
		cout << "the integer value of " << c << " is " << int{c} << '\n';
 }
 
The notation inc{c} gives the integer value for a character c ("the int we can construct from c").
The possibility of converting a char to an integer raises the question: is a char signed or unsigned? 
The 256 values represented by an 8-bit byte can be interpreted as the values 0 to 255 or as the val- 
ues ?127 to 127. No, not ?128 to 127 as one might expect: the C++ standard leaves open the possi- 
bility of one’s-complement hardware and that eliminates one value; thus, a use of ?128 is non- 
portable. Unfortunately, the choice of signed or unsigned for a plain char is implementation- 
defined. 
C++ provides two types for which the answer is definite: signed char, which can hold at least
the values -127 to 127, and unsigned char, which can hold at least the values 0 to 255.

Note that the character types are integral types so that arithmetical and bitwise logical
operations apply. For example:
void digits()
{
	for(int i=0;i!=10;++i)
		cout << static_cast<char>('0'+i);
}
Plain '0'+i is an int, so if i had left out the static_cast<char>, the output would've been
something like 48, 49, and so on, rather than 0, 1, and so on.

6.2.3.1 Signed and Unsigned Characters
It's implementation-defined whether a plain char is considered signed or unsigned. This opens
the possibility for some nasty surprises and implementation dependencies. For example:
char c  = 255; // 255 is "all ones", hexadecimal 0xFF
int i = c;
What will be the value of i? Unfortunately, the answer is undefined. 
On an implementation with 8-bit bytes on a machine where a char is unsigned, the answer is 255;
on a machine where a char is signed, the answer is -1. One soultion is to avoid plain char and
use the specific char types only. Some STD libs take plain chars only.
A char must behave identically to either a signed char or unsigned char. However, the three
char types are distinct, so you can't mix pointers to different char types. For example:
void f(char c, signed char sc, unsigned char, uc)
{
	char *pc = &c; 		// error: no pointer conversation
	char *psc = &pc; 	// error: no pointer conversation
	char *puc = &psc; 	// error: no pointer conversation
	psc = puc; 			// error: no pointer conversation
}

Variables of the three char types can be freely assigned to each other. However, assigning a
too-large value to a signed char is still undefined. For example:
void g(char c, signed char sc, unsigned char, uc)
{
	c = 255; 	// implementation-defined if plain chars are signed and have 8-bits
	c = sc; 	// OK
	c = uc; 	// implementation-defined if plain chars are signed and if uc's value's too large
	sc = uc; 	// implementation-defined if uc's value's too large
	uc = sc;	// OK: conversion to unsigned
	sc = c; 	// implementation-defined if plain chars are unsigned and if c's value's too large
	uc = c;		// OK: conversion to unsigned
}

TEST
	char c = 255;
	unsigned char uc = 255;
	signed char sc = 127; // если больше 127, то SC-256 == SMT
	c = sc;
	cout << "C = " <<(int) c << '\n';
	c = uc;
	cout << "C = " << (int)c << '\n';
	sc = uc;
	cout << "SC = " << (int)sc << '\n';
	uc = sc;
	cout << "UC = " << (int)uc << '\n';
	sc = c;
	cout << "SC = " << (int)sc << '\n';
	uc = c;
	cout << "UC = " << (int)uc << '\n';

To be concrete, assume that a char is 8 bits:
signed char = - 160;
unsigned char uc = sc; // uc == 116 (because 256-160==116)
cout << uc; // print 't'

char count[256]; // assume 8-bit chars
++count[sc]; // likely disaster: out-of-range access
++count[uc]; // OK

	signed char sc = -160; // 256-160==96
	unsigned char uc = sc; // uc == 116 (because 256-160==116)
	char count[256]{ 's','a','b' };
	cout << ++count[uc] << ++count[sc];

None of these problems and confusions occur if you use plain char throughout and avoid 
negative character values.

6.2.3.2 Character literals
Name 			ASCII Name 			C++ Name 
Newline 		NL (LF) 			\n 
Horizontal tab 	HT 					\t 
Vertical tab 	VT 					\v 
Backspace 		BS 					\b 
Carriage return CR 					\r 
Form feed 		FF 					\f 
Alert 			BEL 				\a 
Backslash 		\ 					\\ 
Question mark 	? 					\? 
Single quote 	’ 					\’ 
Double quote 	" 					\" 
Octal number 	ooo 				\ooo 
Hexadecimal number hhh 				\xhhh ... 
Despite their appearance, these are single characters.

It is possible to enclose more than one character in a character literal, for example, 'ab'.
Such uses archaic, implementation-dependent, and best avoided. The type of such a multicharacter
literal is int.
There is no limit to the number of hexadecimal digits in the sequence. A 
sequence of octal or hexadecimal digits is terminated by the first character that is not an octal digit 
or a hexadecimal digit, respectively. For example: 
Octal 	Hexadecimal 	Decimal 	ASCII 
'\6' 	'\x6' 			6 			ACK 
'\60' 	'\x30' 			48 			'0' 
'\137' 	'\x05f' 		95 			'_' 

When embedding a numeric constant in a string using the octal notation, it is wise always to use 
three digits for the number. The notation is hard enough to read without having to worry about 
whether or not the character after a constant is a digit. For hexadecimal constants, use two digits. 
Consider these examples: 
char v1[] = "a\xah\129"; 	// 6 chars: 'a' '\xa' 'h' '\12' '9' '\0' 
char v2[] = "a\xah\127"; 	// 5 chars: 'a' '\xa' 'h' '\127' '\0' 
char v3[] = "a\xad\127"; 	// 4 chars: 'a' '\xad' '\127' '\0' 
char v4[] = "a\xad\0127"; 	// 5 chars: 'a' '\xad' '\012' '7' '\0' 

SIZES
This is what is guaranteed about sizes of fundamental types: 
1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long) 
1 <= sizeof(bool) <= sizeof(long) 
sizeof(char) <= sizeof(wchar_t) <= sizeof(long) 
sizeof(float) <= sizeof(double) <= sizeof(long double) 
sizeof(N) == sizeof(signed N) == sizeof(unsigned N) 

В стандарте С++  и по стандарту С sizeof(char) = 1.  
но при этом стандарты не гарантируют, что в байте содержится именно 8 бит 
sizeof( 'a' ) == 1 in c++, and is sizeof( int ) in c
C STANDARD: «An integer character constant has type int.»
Просто байтом называют размер, соответствующий char'у.
NTMBS (null-terminated multibyte strings) лучше NTWS (null-terminated wide strings)


There're machines with 32-bit chars.
size of int != size of pointer (many machines (64-bit architectures have pointers that are
larger than integers)
It's not guaranteed that
sizeof(long)<sizeof(long long) or sizeof(double)<sizeof(long double)

Some implementation-defined aspects of fundamental types can be found by a simple use of  sizeof,
and  more can be found in <limits>. For example:
#include <limits>
#include <iostream>

int main()
{
	cout << "size of long " << sizeof(1L) << '\n';
	cout << "size of long long " << sizeof(1LL) << '\n';
	
	cout << "the largest float == " << std::numeric_limits<float>::max() << '\n';
	cout << "char is signed == " << std::numeric_limits<char>::is_signed << '\n';
}

The functions in <limits> are constexpr so they can be used without run-time overhead and in
context that require a constant expression.
The fundamental types can be mixed freely in assignments and expressions. Whenever possible,
value are converted so as not to lose information.
If you need a specific size of an integer, say, a 16-bit integer, you can #include the standard
header <cstdint> that defines a variety of types (or rather type aliases). For example:
int16_t x {0xaabb}; // 2bytes
int64_t xxxx {0xaaabbbcccddd}; // 8 bytes
int_least16_t y; // at least 2 bytes (just like int)
int_least32_t yy; // at least 4 bytes (just like long)
int_fast32_t z; // the fastest int type with at least 4 bytes

The standard header <cstddef> defines an alias that is very widely used in both standard-library
declarations and user code: size_t is an implementation-defined unsigned integer type that
can hold the size in bytes of every object. Conseqently, it's used where we need to hold an
object size. For example:
void* allocate(size_t n); // get n bytes
Similarly, <cstddef> defines the signed integer type ptrdiff_t for holding the result of
substracting two pointers to get a number of elements.

ALign
STEPHEN PRATA:
#include <iostream>
using namespace std;

struct things1 {
	char ch; int a; double x;
};

struct things2 {
	int a; double x; char ch;
};

struct things3 {
	double x; int a; char ch;
};

int main()
{
	things1 th1;
	things2 th2;
	things3 th3;
	cout << "char alignment " << alignof(char) << endl;
	cout << "int alignment " << alignof(int) << endl;
	cout << "double alignment " << alignof(double) << endl;
	cout << "things1 alignment " << alignof(things1) << endl;
	cout << "things2 alignment " << alignof(things2) << endl;
	cout << "things3 alignment " << alignof(things3) << endl;
	cout << "things1 size: " << sizeof(things1) << endl;
	cout << "things2 size: " << alignof(things2) << endl;
	cout << "things3 size: " << alignof(things3) << endl;

	system("pause");
	return 0;
}

STROUSTRUP
You can write good C++ code for decades without needing to be explicit about alignment.
Where alignment most becomes visible is in object layouts: sometimes structs contain "holes"
to improve alignment.

The alignas(T) means "align just like a T."
For example, we can set aside uninitialized storage for some type X like this:
template <typename X>
void user(const vector<X>& vs)
{
	constexpr int bufmax = 1024;
	alignas(X)buffer[bufmax]; // unitialized

	const int max = min(vx.size(), bufmax / sizeof(X));
	unitialized_copy(vx.begin(), vx.begin() + max, buffer);
}

Declarations
Before a name can be used in a C++ program, it must be declared. That is, its type must be 
specified to inform the compiler what kind of entity the name refers to. For example:
char ch; 
string s; 
auto count = 1; 
const double pi {3.1415926535897}; 
extern int error_number; 
const char? name = "Njal"; 
const char? season[] = { "spring", "summer", "fall", "winter" }; 
vector<string> people { name, "Skarphedin", "Gunnar" }; 
struct Date { int d, m, y; }; 
int day(Date? p) { return p?>d; } 
double sqrt(double); 
template<class T> T abs(T a) { return a<0 ? -a : a; } 
constexpr int fac(int n) { return (n<2)?1:n*fac(n-1); } // possible compile-time evaluation (§2.2 .3) 
constexpr double zz { ii*fac(7) }; 
// compile-time initialization 
using Cmplx = std::complex<double>; 
struct User; 
// type name 
enum class Beer { Carlsberg, Tuborg, Thor }; 
namespace NS { int a; } 

As can be seen from these examples, a declaration can do more than simply associate a type with
a name. Most of these declarations are also definitions. A definition is a declaration that
supplies all that is need in a program for the use of an entity.

Assuming that these declarations are in the global scope (§6.3 .4), we have: 
char ch; // set aside memory for a char and initialize it to 0 
auto count = 1; // set aside memory for an int initialized to 1 
const char? name = "Njal"; 	// set aside memory for a pointer to char
							// set aside memory for a string literal "Njal" 
							// initialize the pointer with the address of that string literal 

struct Date {int d, m, y;}; // Data is a struct with three members
int day(Date* p) {return p->d;} // day is a function tha executes the specified code

using Pointer = std::complex<short>; // Point is a name for std::complex<short>
Of declarations above, only three are not also definitions:
double sqrt(double); // function declaration
extern int error_number; // variable declaration
struct User; // type name declaration
That is, if used, the entity they refer to must be defined elsewhere. For example:
double sqrt(double d) {/*...*/}
int error_number = 1;
struct User {/*...*/}

All declarations of an entity must agree on its type. So, this fragment has two errors:
int count;
int count; // redifinition
extern int error_number;
extern short error_number; // error: type mismatch
This has no errors(for the use of extern):
extern int error_number;
extern int error_number; // redeclaration

Some definitions explicitly specify a ‘‘value’’ for the entities they define. For example: 
struct Date { int d, m, y; }; 
using Point = std::complex<short>; // Point is a name for std::complex<short> 
int day(Date* p) { return p->d; } 
const double pi {3.1415926535897};

For types, aliases, templates, functions, and constants, the ‘‘value’’ is permanent. For non-const 
data types, the initial value may be changed later. For example: 
void f() 
{ 
int count {1}; // initialize count to 1 
const char* name {"Bjarne"}; // name is a variable that points to a constant (§7.5) 
count = 2; // assign 2 to count 
name = "Marian"; 
}

Of the definitions, only two do not specify values: 
char ch; 
string s; 
See §6.3 .5 and §17.3 .3 for explanations of how and when a variable is assigned a default value. 
Any declaration that specifies a value is a definition. 

The Structure of Declarations
The C++'s grammar evolved over four decades, starting with early C grammars, and is quite complicated.
However, without too many radical simplifictations, we can consider a declaration as having 
fiver parts (in order):
Optional prefix specifiers (e.g ., static or virtual) 
A base type (e.g., vector<double> or const int) 
A declarator optionally including a name (e.g., p[7], n,or *(*)[]) 
Optional suffix function specifiers (e.g., const or noexcept) 
An optional initializer or function body (e.g., ={7,5,3} or {return x;}) 

Except for function and namespace definitions, a declaration is terminated by a semicolon. Con- 
sider a definition of an array of C-style strings: 
const char* kings[] = { "Antigonus", "Seleucus", "Ptolemy" }; 
Here, the base type is const char, the declarator is ?kings[], and the initializer is the = followed by 
the {}-list. 
A specifier is an initial keyword, such as virtual (§3.2.3, §20.3 .2), extern (§15.2), or constexpr 
(§2.2 .3), that specifies some non-type attribute of what is being declared. 

A declarator is composed of a name and optionally some declarator operators. The most com- 
mon declarator operators are: 
Declarator Operators 
prefix *		pointer 
prefix *const  	constant pointer
prefix *volatile volatile pointer 
prefix & lvalue reference (§7.7 .1) 
prefix && rvalue reference (§7.7 .2) 
prefix auto function (using suffix return type) 
postfix [] array 
postfix () function 
postfix -> returns from function 
Their use would be simple if they were all either prefix or postfix. However, ?, [], and () were 
designed to mirror their use in expressions (§10.3). Thus, * is prefix and [] and () are postfix. The 
postfix declarator operators bind tighter than the prefix ones. Consequently, char*kings[] is an array 
of pointers to char, whereas char(*kings)[] is a pointer to an array of char. We have to use parenthe- 
ses to express types such as ‘‘pointer to array’’ and ‘‘pointer to function’’; see the examples in §7.2 . 
Note that the type cannot be left out of a declaration. For example: 
const c = 7; // error" no type
gt(int a, int b) {return (a>b) ? a : b;} // error: no return type
unsigned ui; // OK
long li; // OK
In this, standard C++ differs from early versions of C and C++ that allowed the first two examples 
by considering int to be the type when none was specified (§44.3). This ‘‘implicit int’’ rule was a 
source of subtle errors and much confusion. 

Declaring Multiple Names 
It is possible to declare several names in a single declaration. The declaration simply contains a list 
of comma-separated declarators. For example, we can declare two integers like this: 
int x, y; 
//intx;inty; 
ptg10564057 
Section 6.3 .2 
Declaring Multiple Names 155 
Operators apply to individual names only – and not to any subsequent names in the same declara- 
tion. For example: 
int* p, y; // int* p; int y; NOT int* y; 
int x, *q; // int x; int* q; 
int v[10], *pv; // int v[10]; int* pv; 
Such declarations with multiple names and nontrivial declarators make a program harder to read 
and should be avoided. 

Names
The underscore character, _, is considered a letter. C++ imposes no limit on the number of charac- 
ters in a name. However, some parts of an implementation are not under the control of the compiler 
writer (in particular, the linker), and those parts, unfortunately, sometimes do impose limits. Some 
run-time environments also make it necessary to extend or restrict the set of characters accepted in 
an identifier. Extensions (e.g ., allowing the character $ in a name) yield nonportable programs. A 
C++ keyword (§6.3 .3 .1), such as new or int, cannot be used as a name of a user-defined entity. 

Nonlocal names starting with an underscore are reserved for special facilities in the implementation 
and the run-time environment, so such names should not be used in application programs. Simi- 
larly, names starting with a double underscore (__) or an underscore followed by an uppercase letter 
(e.g., _Foo) are reserved (§iso.17 .6.4 .3). 

1 Encoding types in names lowers the abstraction level of the program; in particular, it pre- 
vents generic programming (which relies on a name being able to refer to entities of differ- 
ent types). 
2 The compiler is better at keeping track of types than you are. 
3 If you want to change the type of a name (e.g ., use a std::string to hold the name), you’ll 
have to change every use of the name (or the type encoding becomes a lie). 
4 Any system of type abbreviations you can come up with will become overelaborate and 
cryptic as the variety of types you use increases. 

Try to maintain a consistent naming style. For example, capitalize names of user-defined types 
and start names of non-type entities with a lowercase letter (for example, Shape and current_token). 
Also, use all capitals for macros (if you must use macros (§12.6); for example, HACK) and never for 
non-macros (not even for non-macro constants). Use underscores to separate words in an identifier; 
number_of_elements is more readable than numberOfElements. However, consistency is hard to 
achieve because programs are typically composed of fragments from different sources and several 
different reasonable styles are in use. Be consistent in your use of abbreviations and acronyms. 
Note that the language and the standard library use lowercase for types; this can be seen as a hint 
that they are part of the standard. 

Scope
Local scope: A name declared in a function (Chapter 12) or lambda (§11.4) is called a local 
name. Its scope extends from its point of declaration to the end of the block in which its de- 
claration occurs. A block is a section of code delimited by a {} pair. Function and lambda 
parameter names are considered local names in the outermost block of their function or 
lambda. 
• 
Class scope: A name is called a member name (or a class member name) if it is defined in a 
class outside any function, class (Chapter 16), enum class (§8.4 .1), or other namespace. Its 
scope extends from the opening { of the class declaration to the end of the class declaration. 
• 
Namespace scope: A name is called a namespace member name if it is defined in a name- 
space (§14.3 .1) outside any function, lambda (§11.4), class (Chapter 16), enum class 
(§8.4 .1), or other namespace. Its scope extends from the point of declaration to the end of 
its namespace. A namespace name may also be accessible from other translation units 
(§15.2). 
• 
Global scope: A name is called a global name if it is defined outside any function, class 
(Chapter 16), enum class (§8.4 .1), or namespace (§14.3 .1). The scope of a global name 
extends from the point of declaration to the end of the file in which its declaration occurs. A 
global name may also be accessible from other translation units (§15.2). Technically, the 
global namespace is considered a namespace, so a global name is an example of a name- 
space member name. 
• 
Statement scope: A name is in a statement scope if it is defined within the () part of a for-, 
while-, if-, or switch-statement. Its scope extends from its point of declaration to the end of 
its statement. All names in statement scope are local names. 
• 
Function scope: A label (§9.6) is in scope from its point of declaration until the end of the 
function. 
A declaration of a name in a block can hide a declaration in an enclosing block or a global name. 
That is, a name can be redefined to refer to a different entity within a block. After exit from the 
block, the name resumes its previous meaning. For example: 
int x; // global x 
void f() 
{ 
	int x; // local x hides global x 
	x=1; //assign to local x 
	{ 
		int x; // hides first local x 
		x=2; //assign to second local x 
	} 
	x=3; //assign to first local x 
} 
int*p=&x; // take address of global x 

A hidden global name can be referred to using the scope resolution operator, ::. For example: 
int x; 
void f2() 
{ 
	int x=1; //hide globalx 
	::x = 2; // assign to global x 
	x=2; //assign to local x 
	// ... 
	} 
There is no way to use a hidden local name. 

The scope of a name that is not a class member starts at its point of declaration, that is, after the 
complete declarator and before the initializer. This implies that a name can be used even to specify 
its own initial value. For example: 
int x=97; 
void f3() 
{ 
int x=x; // perverse: initialize x with its own (uninitialized) value 
} 
A good compiler warns if a variable is used before it has been initialized. 
It is possible to use a single name to refer to two different objects in a block without using the :: 
operator. For example: 
int x =11; 
void f4() // perverse: use of two different objects both called x in a single scope 
{ 
	int y=x; 
	//use globalx: y=11 
	int x=22; 
	y=x; //use local x: y = 22 
} 

The names of function arguments are considered declared in the outermost block of a function. 
For example: 
void f5(int x) 
{ 
	int x; // error 
} 

Names introduced in a for-statement are local to that statement (in statement scope). This 
allows us to use conventional names for loop variables repeatedly in a function. For example: 
void f(vector<string>& v, list<int>& lst) 
{ 
	for (const auto& x : v) cout << x << '\n'; 
	for (auto x : lst) cout << x << '\n'; 
	for (int i = 0, i!=v.size(), ++i) cout << v[i] << '\n'; 
	for(autoi:{1,2,3,4,5,6,7})cout<<i<<'\n'; 
} 
This contains no name clashes. 

INITIALIZATION
If an initializer is specified for an object, that initializer determines the initial value of an object. 
An initializer can use one of four syntactic styles: 
X a1 {v}; 
X a2={v}; 
X a3=v; 
X a4(v); 
Of these, only the first can be used in every context, and I strongly recommend its use. It is clearer 
and less error-prone than the alternatives. However, the first form (used for a1) is new in C++11, so 
the other three forms are what you find in older code. The two forms using = are what you use in 
C.
Old habits die hard, so I sometimes (inconsistently) use = when initializing a simple variable 
with a simple value. For example: 
intx1=0; 
char c1 = 'z';
However, anything much more complicated than that is better done using {}. Initialization using {}, 
list initialization, does not allow narrowing (§iso.8 .5 .4). That is: 
• 
An integer cannot be converted to another integer that cannot hold its value. For example, 
char to int is allowed, but not int to char. 
• 
A floating-point value cannot be converted to another floating-point type that cannot hold its 
value. For example, float to double is allowed, but not double to float. 
• 
A floating-point value cannot be converted to an integer type. 
• 
An integer value cannot be converted to a floating-point type. 
For example:
void f(double val, int val2)
{
	int x2 = val; // if val==7.9, x2 becomes 7
	char c2 = val2; // if val2=1025, c2 becomes 1
	int x3{val}; // error: possilbe truncation
	char c3 {val2}; // error: possible narrowing
	char c4{24}; // OK: 24 can be represented exactly as a char
	char c5{265}; // arror (assuming 8-bit chars): 265 cannot be represented as a char
	int x4{2.0}; // error: no double to int value conversion
}

There is no advantage to using {} initialization, and one trap, when using auto to get the type 
determined by the initializer. The trap is that if the initializer is a {}-list, we may not want its type 
deduced (§6.3 .6 .2). For example: 
auto z1 {99}; // z1 is an initializer_list<int> 
auto z2=99; //z2 is an int 
So prefer = when using auto. 
It is possible to define a class so that an object can be initialized by a list of values and alterna- 
tively be constructed given a couple of arguments that are not simply values to be stored. The clas- 
sical example is a vector of integers: 
vector<int> v1 {99}; // v1 is a vector of 1 element with the value 99 
vector<int> v2(99); // v2 is a vector of 99 elements each with the default value 0 

I use the explicit invocation of a constructor, (99), to get the second meaning. Most types do not 
offer such confusing alternatives – even most vectors do not; for example: 
vector<string> v1{"hello!"}; // v1 is a vector of 1 element with the value "hello!" 
vector<string> v2("hello!"); // error: no vector constructor takes a string literal 

The empty initializer list, {}, is used to indicate that a default value is desired. For example: 
int x4 {}; // x4 becomes 0 
double d4 {}; // d4 becomes 0.0 
char? p {}; // p becomes nullptr 
vector<int> v4{}; // v4 becomes the empty vector 
string s4 {}; // s4 becomes "" 
Most types have a default value. For integral types, the default value is a suitable representation of 
zero. For pointers, the default value is nullptr (§7.2.2). For user-defined types, the default value (if 
any) is determined by the type’s constructors (§17.3 .3). 

Missing Initializers
For many types, including all built-in types, it is possible to leave out the initializer. If you do that 
– and that has unfortunately been common – the situation is more complicated.
If you don’t like 
the complications, just initialize consistently. The only really good case for an uninitialized vari- 
able is a large input buffer. For example: 
constexpr int max = 1024*1024;
char buf[max];
some_stream.get(buf, max); // read at most max characters into buf
We could easily have initialized buf:
char buf[max] {}; // initialize every char to 0

If no initializer is specified, a global, namespace, local static, or static member is initialized
to {} of the appropriate type. For example:
int a; // means "int a{};" so that a becomes 0
double b; // means "double b{};" so that b becomes 0.0
Local variables and objects created on the free store (sometimes called dynamic objects or
heap objects) are not initialized by default unless they are of user-defined types with a default constructor.
For example:
void f()
{
	int x; // x does not have a well-defined value
	char buf[1024]; // buf[i] does not have a well-defined value
	int* p{new int}; // *p does not have a well-defined value
	char* q{new char[1024]}; // q[i] does not have a well-defined value
	string s; // s=="" because of string's default constructor
	vector<char> v; // v=={} because of vector's default constructor
	string* ps {new string}; // *ps is "" because of string's default constructor
	//...
}

If you want initialization of loval variables of built-in types or objects of built-in type
created with new, use {}. For example:
voif ff()
{
	int x{}; // x becomes 0
	char buf[1024] {}; // buf[i] becomes 0 for all i
	int* p {new int{10}}; // *p becomes 10
	char* q {new char[1024]{}}; // q[i] becomes 0 for all i
}

Initializer lists
So far, we have considered the cases of no initializers and one initializer value.
More complicated objects can require more than one value as an initializer. This is
primarily handled by initializer lists delimited by { and }. For example: 
int a[] = {1,2}; // array initializer
struct S {int x, string s};
S s = {1, "Helios"}; // struct initializer
complex<double> z = {0, pi}; // use constructor
vector<double> v = {0.0,1.1,2.2,3.3}: // use list constructor
In some cases, function-style argument lists can also be used (§2.3, §16.2 .5). For example: 
complex<double> z(0,pi); // use constructor 
vector<double> v(10,3.3); // use constructor: v gets 10 elements initialized to 3.3 
In a declaration, an empty pair of parentheses, (), always means ‘‘function’’ (§12.1). So,
if you want to be explicit about ‘‘use default initialization’’ you need {}. For example: 
complex<double> z1(1,2); // function-style initializer (initialization by constructor) 
complex<double> f1(); // function declaration 
complex<double> z2 {1,2}; // initialization by constructor to {1,2} 
complex<double> f2 {}; // initialization by constructor to the default value {0,0} 
Note that initialization using the {} notation does not narrow (§6.3 .5). 
When using auto, a {}-list has its type deduced to std::initializer_list<T>. For example:
auto x1{1,2,3,4};//x1 is an initializer_list<int>
auto x2{1.0,2.25, 3.5}; // x2 is an initializer_list of <double>
auto x3{1.0,2}; //error:cant deduce type

Deducing a type: auto and decltype().
The language provides two mechanisms for deducing a type from an expression:
auto for deducing a type of an object from its initializer; the type can be the type of a vari- 
able, a const,oraconstexpr. 
decltype(expr) for deducing the type of something that is not a simple initializer, such as the 
return type for a function or the type of a class member. 
When a declaration of a variable has an initializer, we don’t need to explicitly specify a type. 
Instead, we can let the variable have the type of its initializer. Consider: 
auto a = 123; // the type of a is "int"
That is, auto is a placeholder for the type of the initializer.
The harder type is to write and the harder type is to know, the more useful auto becomes.
For example:
template<class T> void f1(vector<T>& arg)
{
	for(vector<T>::iterator p = arg.begin(), p!=arg.end(); ++p)
		*p=7;
	
	for(auto p = arg.begin(), p!=arg.end(); ++p)
		*p = 7;
}

So, unless there's a good reason not to, use auto in small scopes.
If a scope is large, mentioning a type explicitly can help localize errors. For example:
void f(double d)
{
	constexpr auto max = d+7;
	int a[max]; // error: array bound not an integer
}

auto and {}-lists
char v1 = 12345; // 12345 is an int 
int v2 = 'c'; //'c' is a char 
T v3=f();

char v1 {12345}; // error: narrowing 
int v2 {'c'}; // fine: implicit char->int conversion 
T v3 {f()}; // works if and only if the type of f() can be implicitly converted to a T 

When we use auto, there is only one type involved, the type of the initializer, and we can safely use 
the = syntax: 
The type of a homogeneous list of elements of type T is taken to be of type initializer_list<T> 
(§3.2 .1 .3, §11.3 .3). In particular, the type of x1 is not deduced to be int. Had it been, what would 
be the types of x2 and x3? 
Consequently, I recommend using = rather than {} for objects specified auto whenever we don’t 
mean ‘‘list.’’ 

The decltype() Specifier
decltype(expr) is the declared type of expr.
Adding two matrices. Consider:
template <class T, class U>
auto operator+(const Matrix<T>& a, const Matrix<U>& b) -> Matrix<decltype(T{}+U{})>;
In definition, I again need decltype() to express Matrix's element type:
template <class T, class U>
auto operator+(const Matrix<T>& a, const Matrix<U>& b) -> Matrix<decltype(T{}+U{})>
{
	Matrix<decltype(T{} + U{})> res;
	for(int i=0;i!=a.rows(); ++i)
		for(int j=0;j!=a.cols();++j)
			res(i,j)+=a(i,j)+b(i,j);
	return res;
}

int v[] = {1,2,3,4};
int* p1 = v; // pointer to initial element (implicit conversion)
int* p2 = &v[0]; // pointer to initial element
int* p3 = v+4; // pointer to one-beyond-last element

 For every built-in array A and the integer J within the range of A, we have:
 a[j] == *(&a[0]+j) == *(a+j) == *(j+a) == j[a]
 
 #include <iostream>
using namespace std;

template <typename T>
int byte_diff(T*a, T*b)
{
	// находит адресное пространство b (как кол-во байтов?) и отнимает a.
	return reinterpret_cast<char*>(b) - reinterpret_cast<char*>(a);
}

int main()
{
	int vi[10];
	short vs[10];
	cout << vi << ' ' << &1[vi] << ' ' << &vi[1] - &vi[0] << ' ' << byte_diff(&vi[0], &vi[1]) << '\n';
	cout << vs << ' ' << &1[vs] << ' ' << &vs[1] - &vs[0] << ' ' << byte_diff(&vs[2], &vs[3]) << '\n';
	system("pause");
	return 0;
}

reinterpret_cast
The C++ standard guarantees the following:

static_casting a pointer to and from void* preserves the address. That is, in the following, a, b and c all point to the same address:

int* a = new int();
void* b = static_cast<void*>(a);
int* c = static_cast<int*>(b);
reinterpret_cast only guarantees that if you cast a pointer to a different type, and then reinterpret_cast it back to the original type, you get the original value. So in the following:

int* a = new int();
void* b = reinterpret_cast<void*>(a);
int* c = reinterpret_cast<int*>(b);
a and c contain the same value, but the value of b is unspecified. (in practice it will typically contain the same address as a and c, but that's not specified in the standard, and it may not be true on machines with more complex memory systems.)

For casting to and from void*, static_cast should be preferred.

POINTERS AND CONST
void f1(char* p)
{
	char s[]{ "Gorm" };
	
	// Value can't be changed, pointer can
	const char* pc = s; // pointer to constant
	pc[3] = 'F';		// error: pc points to constant
	pc = p;				// OK

	// Value can be changed, pointer can't
	char* const cp = s; // pointer to constant
	cp[3] = 'F';		// OK
	cp = p;				// error: cp is constant

	// Value can't be changed, so can't pointer
	const char* const cpc = s; // pointer to constant
	cpc[3] = 'F';		// error: cpc points to constant
	cpc = p;				// error: cpc is constant

	int a;
	int* const b = &a; //*const makes a pointer constant
						// There's no const* declarator operator,
						// so a const appearing before the *
						//is taken to be a part of the base type
	int const* c = &a; // if it's being read right-to-left, it'll be a pointer
						// to a const int
	*c = 5; // can't modify the value pointed to.

}

void f4()
{
	int a = 1;
	const int c = 2;
	const int* p1 = &c; // OK
	const int* p2 = &a; // OK
	int* p3 = &c; // error: initialization of int* with const int*
	*p3 = 7; // try to change the value of c
}

LVALUE AND RVALUE
string var{ "Cambridge" };
string f() { return { "dad" }; }

string& r1{ var };  // lvalue reference, bind r1 to var (an lvalue);
string& r2{ f() };  // lvalue reference, error: f() is an rvalue
string& r3{ "Princeton" }; // lvalue reference, error: can't bind to temporary

string&& rr1{ f() }; //rvalue reference, fine: bind rr1 to rvalue (a temporary)
string&& rr2{ var }; // rvalue reference, error: var is an lvalue
string&& rr3{ "Oxford" }; //rr3 refers to a temporary holding "Oxford"

const string& cr1{ "Harvard" }; // OK: make temporary and bind to cr1


class Entry2 {
private:
			enum class Tag { number, text };
			Tag 	type; // discriminant
			
			union { // representation
				int i;
				string s; // string has default constructor, copy operations, and destructor 
			};
public:
			struct Bad_entry { }; // used for exceptions
		
			string name;
			~Entry2				();
			Entry2& operator=	(const Entry2&); // necessary because of the string variant 
			Entry2 				(const Entry2&);
	// Stroustrup names get\set methods like that	
	int		number 				() const;
	string	text				() const;
	
	void 	set_number			(int n);
	void	set_string			(const string&);
};

int Entry2::number	() const
{
	if(type!=Tag::number) throw Bad_entry{};
	return 			i;
}

string Entry2::text	() const
{
	if(type!=Tag::text) throw Bad_entry{};
	return 			s;
}

void Entry2::set_number(int n)
{
	if(type==Tag::text) {
		s.~string();//explicitly destroy string
		tag	=Tag::number;
	}
	i	= n;
}

void Entry2::set_text(const string&ss)
{
	if(type==Tag::text) {
		s =ss;
	} else { 
		new (&s) string(ss);
		type = Tag::text;
	}
}

Entry2& Entry2::operator=(const Entry2& e)
{
	if(type==Tag::text&&e.type==Tag::text) {
		s=e.s; // usual assignment
	}
	
	if(type==Tag::text) s.~string(); // if it contains string, destroy it
	
	switch(e.type) {
	case Tag::number:
		i=e.i;
		break;
	case Tag::text:
		new(&s)(e.s); // alloc string
		type=e.type;
	}
	
	return	*this;
}

Entry2::~Entry2()
{
	if(type==Tag::text) s.~string(); // handle string type
}

Standard Container Summary 
vector<T> A variable-size vector (§31.4) 
list<T> A doubly-linked list (§31.4 .2) 
forward_list<T> A singly-linked list (§31.4.2) 
deque<T> A double-ended queue (§31.2) 
set<T> A set (§31.4 .3) 
multiset<T> A set in which a value can occur many times (§31.4 .3) 
map<K,V> An associative array (§31.4 .3) 
multimap<K,V> A map in which a key can occur many times (§31.4 .3) 
unordered_map<K,V> A map using a hashed lookup (§31.4 .3.2) 
unordered_multimap<K,V> A multimap using a hashed lookup (§31.4 .3.2) 
unordered_set<T> A set using a hashed lookup (§31.4 .3 .2) 
unordered_multiset<T> A multiset using a hashed lookup (§31.4 .3 .2) 

http://www.cyberforum.ru/cpp-beginners/thread27084.html

SELECTED STANDARD LIBRARY HEADERS
<algorithm> copy(), find(), sort() §32.2 §iso.25 
<array> array §34.2 .1 §iso.23.3 .2 
<chrono> duration, time_point §35.2 §iso.20.11.2 
<cmath> sqrt(), pow() §40.3 §iso.26.8 
<complex> complex, sqrt(), pow() §iso.26.8 
<fstream> fstream, ifstream, ofstream §38.2 .1 §iso.27 .9 .1 
<future> future, promise §5.3 .5 §iso.30 .6 
<iostream> istream, ostream, cin, cout §38.1 §iso.27 .4 
<map> map, multimap §31.4 .3 §iso.23.4 .4 
<memory> unique_ptr, shared_ptr, allocator §5.2 .1 §iso.20.6 
<random> default_random_engine, normal_distribution §40.7 §iso.26.5 
<regex> regex, smatch Chapter 37 §iso.28.8 
<string> string, basic_string Chapter 36 §iso.21 .3 
<set> set, multiset §31.4 .3 §iso.23.4 .6 
<sstream> istrstream, ostrstream §38.2 .2 §iso.27 .8 
<thread> §5.3 .1 §iso.30 .3 
<unordered_map> unordered_map, unordered_multimap §31.4 .3 .2 §iso.23.5 .4 
<utility> move(), swap(), pair §35.5 §iso.20.1 
<vector> vector §31.4 §iso.23.3 .6

АНГЛИЙСКИЕ ТЕРМИНЫ
С-style string - zero-terminated array of char
dereferencing (also indirection) - refering to the object pointed to by the pointer
handle-to-data - constructor\destructor.
RAII - acquiring resources in a constructor and releasing them in a destructor
free store, heap, dynamic store - куча.
polymorphic type - a class that provides the interface to a variety of other classes.
base - Container is a base of class Vector_Container.
subclass - Vector_container.
superclass - Container.
tagged union, discriminated union - a kind of union that uses enum to decide what member is to use
object - contiguous region of storage
lvalue - expression that refers to an object
modifable lvalue - a lvalue that has not been declared const
rvalue - "not a lvalue", such as a temporary value
inheritance - the use of base and derived classes.
override - function that overrides the base class function
virtual function - can be redifined in the derived class
virtual function table - converting the name of a virtual function into an index into a table of pointers to functions
RTTI - run time type identification
strong resource safety - eliminating resource leaks for a general notion of a resource.
template - a class or a function that we parametrize with a set of types or values.
function object - object that can be used like functions
predicate - something that we can invoke to return true or false
lambda expression - [&](int a) {return a < x;}. it generates a function object. (exactly like)
capture list - 		[&] specifies that local names used will be passed by reference.
Had we wanted to "capture" only x, we could've said so: [&x];
Had we wanted to give the generated object a copy of x, we could've said so: [=x];
Capture nothing is[], capture all local names used by reference is [&x], and capture all local
names used by value is [=].
Using lambdas can be convenient and terse, but also obscure.
variadic template (variadics) - can accept an arbitary number of an arguments of an arbitary types
ellipsis ...
a member of enumeration - enumerator
contatenation - "Addition" of strings 
subscripting - using []
underlying type - integer type that represents enumeration size
character constant - a character enclosed in single quotes.
double-precision floating-point number - double
key - value of map's first type
the value or the mapped type - the corresponding value of the second type
static objects - a global, namespace, local static, or static member
dynamic objects or heap objects - local variables and objects created on the free store
fixed-size array - array<T, N>, bitset<N>
task - a computation that can potentially be executed concurrently with other computations.
	a task is a function or a function object.
thread - the system-level representation of a task in a program.
mutex - mutual exclusion object
shadowing a name - hiding names
list initialization - C++11's form of initialization, which doesn't allow narrowing
implementation-defined - means that each implementation must provide a specific, well-defined
behavior for a construct and that behavior must be documented. For example:
unsigned char c1 = 64; // well defined: a char has at least 8 bits and can always hold 64
unsigned char c2 = 1256; // implementation-defined: truncation if a char has only 8 bits
unspecified behavior - a range of possible behaviors are acceptable, but the implementer is not
obliged to specify which actually occur. For example, the exact value returned by new is unspecified.
undefined bahavior - a construct is deemed undefined by the standard if no reasonable behavior
is required by an implementation. For example:
const int size = 4*1024;
char page[size];

void f() { page[size+size] = 7; // undefined
}

off-by-one error - miscalculation in a massive size
elaborated-type-specifier - keyword before a typename - struct STR name;
hosted (implementation) - includes all the standard-library facilities as described in the standard.
freestanding (implementation) - may provide fewer standard-library facilities, as long as the
following are provided:
Freestanding Implementation Headers 
Types <cstddef> §10.3 .1 
Implementation properties <cfloat> <limits> <climits> §40.2 
Integer types <cstdint> §43.7 
Start and termination <cstdlib> §43.7 
Dynamic memory management <new> §11.2 .3 
Type identification <typeinfo> §22.5 
Exception handling <exception> §30.4 .1 .1 
Initializer lists <initializer_list> §30.3 .1 
Other run-time support <cstdalign> <cstdarg> <cstdbool> §12.2 .4, §44.3 .4 
Type traits <type_traits> §35.4 .1 
Atomics <atomic> §41.3 

basic source character set - consists of the letters, digits, graphical characters and whitespace
characters from the U.S. variant of the international 7-bit character set ISO 646-1983 called
ASCII.
universal character names - the meaning of the hexadecimal number is defined by the ISO/IEC
10646 standard
extended integer types - these types must behave like integers, but they usually have greater
range (occupy more space)

namespace pollution-the injection of names into an enclosing scope.


integral types - boolean, character, and integer types
arithmetic types - the integral and floating-point types
user-defined types - enumerations and classes
built-in types - fundamental types, pointers, and references


Inexplicable Engine - рабочее название, или это херня?
intricate

http://rutracker.org/forum/viewtopic.php?t=1045448 GAME DEVELOPER'S BOOKS
http://rutracker.org/forum/viewtopic.php?t=1590249 AI

Programming in C++
[1] Represent ideas directly in code.
[2] Represent relationships among ideas directly in code (e.g., hierarchical, parametric, and
ownership relationships).
[3] Represent independent ideas independently in code.
[4] Keep simple things simple (without making complex things impossible).
Prefer statically type-checked solutions (when applicable).
[6] Keep information local (e.g., avoid global variables, minimize the use of pointers).
[7] Don’t overabstract (i.e., don’t generalize, introduce class hierarchies, or parameterize
beyond obvious needs and experience).

Suggestions for C++ Programmers
[1] Use constructors to establish invariants (§2.4.3.2, §13.4, §17.2.1).
[2] Use constructor/destructor pairs to simplify resource management (RAII; §5.2, §13.3).
[3] Avoid ‘‘naked’’ new and delete (§3.2.1.2, §11.2.1).
[4] Use containers and algorithms rather than built-in arrays and ad hoc code (§4.4, §4.5,
§7.4, Chapter 32).
[5] Prefer standard-library facilities to locally developed code (§1.2.4).
[6] Use exceptions, rather than error codes, to report errors that cannot be handled locally
(§2.4.3, §13.1).
[7] Use move semantics to avoid copying large objects (§3.3.2, §17.5.2).
[8] Use unique_ptr to reference objects of polymorphic type (§5.2.1).
[9] Use shared_ptr to reference shared objects, that is, objects without a single owner that is
responsible for their destruction (§5.2.1).
[10] Use templates to maintain static type safety (eliminate casts) and avoid unnecessary use
of class hierarchies (§27.2).

Suggestions for C Programmers
[1] Don’t think of C++ as C with a few features added. C++ can be used that way, but only
suboptimally. To get really major advantages from C++ as compared to C, you need to
apply different design and implementation styles.
[2] Don’t write C in C++; that is often seriously suboptimal for both maintenance and performance.
[3] Use the C++ standard library as a teacher of new techniques and programming styles.
Note the difference from the C standard library (e.g., = rather than strcpy() for copying
and == rather than strcmp() for comparing).
[4] Macro substitution is almost never necessary in C++. Use const (§7.5), constexpr (§2.2.3,
§10.4), enum or enum class (§8.4) to define manifest constants, inline (§12.1.5) to avoid
function-calling overhead, templates (§3.4, Chapter 23) to specify families of functions
and types, and namespaces (§2.4.2, §14.3.1) to avoid name clashes.
[5] Don’t declare a variable before you need it, and initialize it immediately. A declaration
can occur anywhere a statement can (§9.3), in for-statement initializers (§9.5), and in conditions
(§9.4.3).
[6] Don’t use malloc(). The new operator (§11.2) does the same job better, and instead of
realloc(), try a vector (§3.4.2). Don’t just replace malloc() and free() with ‘‘naked’’ new and
delete (§3.2.1.2, §11.2.1).
[7] Avoid void∗, unions, and casts, except deep within the implementation of some function
or class. Their use limits the support you can get from the type system and can harm performance.
In most cases, a cast is an indication of a design error. If you must use an
explicit type conversion, try using one of the named casts (e.g., static_cast; §11.5.2) for a
more precise statement of what you are trying to do.
[8] Minimize the use of arrays and C-style strings. C++ standard-library strings (§4.2), arrays
(§8.2.4), and vectors (§4.4.1) can often be used to write simpler and more maintainable
code compared to the traditional C style. In general, try not to build yourself what has
already been provided by the standard library.
[9] Avoid pointer arithmetic except in very specialized code (such as a memory manager) and
for simple array traversal (e.g., ++p).
[10] Do not assume that something laboriously written in C style (avoiding C++ features such
as classes, templates, and exceptions) is more efficient than a shorter alternative (e.g.,
using standard-library facilities). Often (but of course not always), the opposite is true.

Suggestions for Java Programmers
[1] Don’t simply mimic Java style in C++; that is often seriously suboptimal for both maintainability
and performance.
[2] Use the C++ abstraction mechanisms (e.g., classes and templates): don’t fall back to a C
style of programming out of a false feeling of familiarity.
[3] Use the C++ standard library as a teacher of new techniques and programming styles.
[4] Don’t immediately invent a unique base for all of your classes (an Object class). Typically,
you can do better without it for many/most classes.
[5] Minimize the use of reference and pointer variables: use local and member variables
(§3.2.1.2, §5.2, §16.3.4, §17.1).
[6] Remember: a variable is never implicitly a reference.
[7] Think of pointers as C++’s equivalent to Java references (C++ references are more limited;
there is no reseating of C++ references).
[8] A function is not virtual by default. Not ev ery class is meant for inheritance.
[9] Use abstract classes as interfaces to class hierarchies; avoid ‘‘brittle base classes,’’ that is,
base classes with data members.
[10] Use scoped resource management (‘‘Resource Acquisition Is Initialization’’; RAII) whenev
er possible.
[11] Use a constructor to establish a class invariant (and throw an exception if it can’t).
[12] If a cleanup action is needed when an object is deleted (e.g., goes out of scope), use a destructor
for that. Don’t imitate finally (doing so is more ad hoc and in the longer run far
more work than relying on destructors).
[13] Avoid ‘‘naked’’ new and delete; instead, use containers (e.g., vector, string, and map) and
handle classes (e.g., lock and unique_ptr).
[14] Use freestanding functions (nonmember functions) to minimize coupling (e.g., see the
standard algorithms), and use namespaces (§2.4.2, Chapter 14) to limit the scope of freestanding
functions.
[15] Don’t use exception specifications (except noexcept; §13.5.1.1).
[16] A C++ nested class does not have access to an object of the enclosing class.
[17] C++ offers only the most minimal run-time reflection: dynamic_cast and typeid (Chapter
22). Rely more on compile-time facilities (e.g., compile-time polymorphism; Chapter 27,
Chapter 28).

СОВЕТЫ СТРАУСТРУПА
[1] Represent ideas directly in code, for example, as a function, a class, or an enumeration
[2] Aim for your code to be both elegant and efficient
[3] Don't overabstract
[4] Focus design on the provision of elegand and efficient abstractions, possibly presented as
libraries.
[5] Represent relationships among ideas directly in code. through parametrization or a class
hierarchy.
[6] Represent independent ideas separately in code. Avoid mutual dependencies among classes.
[7] C++ is not just object-oriented
[8] C++ is not just for generic programming.
[9] Prefer solutions that can be statically checked.
[10] Make resources explicit(represent them as class objects)
[11] Express simply ideas simply
[12] Use libraries
[13] Use a type-rich style of programming.
[14] Low-level code is not necessarily efficient; don't avoid classes, templates and standard
library out of fear of performance problems.
[15] If data has an invariant, encapsulate it.
[16] C++ is not just C with a few extensions.

[1] Do not panic! All will become clear in time.
[2] You don't have to know every detail of C++ to write good programs.
[3] Focus on programming techniques, not on langauge features.

3.5 Advice
[1] Express ideas directly in code.
[2] Define classes to represent application concepts directly in code.
[3] Use concrete classes to represent simple concepts and performance-critical components
[4] Avoid "naked" new and delete operations
[5] Use resource handlers and RAII to manage resources
[6] Use abstract classes as interfaces when complete separation of interface and implementation
is needed
[7] Use class heirarchies to represent concepts with inherent heirarchical structure.
[8] When designing a class heirarchy, distingfush between implementation inheritance and
interface inheritance
[9] Control construction, copy, move, and destruction of objects.
[10] Return containers by value (relying on move for efficiency)
[11] Provide strong resource safety; that is, never leak anything that you think of as a resource
[12] Use containers, defined as resource handle templates, to hold collections of values of the
same type.
[13] Use function templates to represent general algorithms
[14] Use function objects, including lambdas, to represent policies and actions.
[15] Use type and template aliases to provide a uniform notation for types that may vary among
similar types or among implementations

4.6 Advice 
[1] Don’t reinvent the wheel; use libraries; §4.1 . 
[2] When you have a choice, prefer the standard library over other libraries; §4.1 . 
[3] Do not think that the standard library is ideal for everything; §4.1. 
[4] Remember to #include the headers for the facilities you use; §4.1 .2 . 
[5] Remember that standard-library facilities are defined in namespace std; §4.1 .2 . 
[6] Prefer strings over C-style strings (a char?; §2.2.5); §4.2, §4.3 .2. 
[7] iostreams are type sensitive, type-safe, and extensible; §4.3. 
[8] Prefer vector<T>, map<K,T>, and unordered_map<K,T> over T[]; §4.4 . 
[9] Know your standard containers and their tradeoffs; §4.4 . 
[10] Use vector as your default container; §4.4 .1. 
[11] Prefer compact data structures; §4.4 .1 .1 . 
[12] If in doubt, use a range-checked vector (such as Vec ); §4.4 .1 .2 . 
[13] Use push_back() or back_inserter() to add elements to a container; §4.4.1, §4.5. 
[14] Use push_back() on a vector rather than realloc() on an array; §4.5 . 
[15] Catch common exceptions in main(); §4.4 .1 .2 . 
[16] Know your standard algorithms and prefer them over handwritten loops; §4.5 .5 . 
[17] If iterator use gets tedious, define container algorithms; §4.5.6 . 

5.7 Advice 
[1] Use resource handles to manage resources (RAII); §5.2 . 
[2] Use unique_ptr to refer to objects of polymorphic type; §5.2 .1. 
[3] Use shared_ptr to refer to shared objects; §5.2 .1 . 
[4] Use type-safe mechanisms for concurrency; §5.3 . 
[5] Minimize the use of shared data; §5.3.4 . 
[6] Don’t choose shared data for communication because of ‘‘efficiency’’ without thought and 
preferably not without measurement; §5.3 .4. 
[7] Think in terms of concurrent tasks, rather than threads; §5.3 .5 . 
[8] A library doesn’t have to be large or complicated to be useful; §5.4 . 
[9] Time your programs before making claims about efficiency; §5.4.1 . 
[10] You can write code to explicitly depend on properties of types; §5.4 .2 . 
[11] Use regular expressions for simple pattern matching; §5.5 . 
[12] Don’t try to do serious numeric computation using only the language; use libraries; §5.6. 
[13] Properties of numeric types are accessible through numeric_limits; §5.6 .5 . 

Совет страуструпа 1: использовать члены класса в  inline-методах, в обычных методах
вызывать для получения члена соответствующий const-метод.

Совет страуструпа 2:
The unordered containers are optimized for lookup with a key (often a string); in other words, they are implemented using hash tables. 

Subscripting and traversing a vector is cheap and easy. On the other hand, vector elements are
moved when we insert or remove elements; list has exactly the opposite properties.
Please note, that a vector is usually more efficient than a list for short sequences of small
elements (even for insert() and erase()). I recommend the standard-library vector as the default
type for sequences of elements: you need a reason to choose another.

Don't panic! (c) Douglas Adams.
Why waste time learning when ignorance is instantaneous? - Hobbes
When you wish to be instruct, be brief. - Cicero
Perfection is achieved only on the point of collapse - C. N. Parkinson

‘‘... I have long entertained a suspicion, with regard to the decisions of philosophers 
upon all subjects, and found in myself a greater inclination to dispute, than assent to 
their conclusions. There is one mistake, to which they seem liable, almost without 
exception; they confine too much their principles, and make no account of that vast 
variety, which nature has so much affected in all her operations. When a philosopher 
has once laid hold of a favourite principle, which perhaps accounts for many natural 
effects, he extends the same principle over the whole creation, and reduces to it every 
ph?nomenon, though by the most violent and absurd reasoning. ...’’ 
– 
David Hume, 
Essays, Moral, Political, and Literary. PART I . (1752) 
