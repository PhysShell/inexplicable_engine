Пул это связанный список, хранящий блоки памяти ( каждый блок содержит свой размер, птр_ту_некст, и конкретно птр ), где конец указывает на
начало.
заметки: блоки граничат по возрастанию адресов;
фрагментацию чекаем: свободная память \ кол-во фри блоков
выравнивание: max_align_t, или pstr, xz
фри-блок управляющая инфа есть заголовок.
все блоки по длине кратны заголовку, который выровнен нормально
При аллоке:
1. размер запрашиваемый должен быть кратен алигну + 1 блок для самого заголовка, птр ретурнится на свободное пространство, а не заголовок
2. перебираем список до первого подходящего ( не обязательно саме сизе ):
	а ) если размер тот же, просто отцепляем его от списка;
	б ) если размер больше - сплитаем его, и оставшуюся часть оставляем в списке;
	в ) если не удалось найти, аллочим у оси ещё
при деаллоке:
1. ищем место для вставки:
	а ) если блок граничит со свободным с любой стороны - сливаем их в один
	
Для начала работы используется переменная base. Если f reep равен NULL, как это
имеет место при первом вызове malloc, создается вырожденный список свободных
блоков. Он содержит один блок нулевого размера и указывает сам на себя. В любом 
случае затем выполняется поиск по списку. Поиск свободного блока подходящей длины 
начинается в точке (f re ер), в которой был найден последний запрошенный блок; такая
схема позволяет поддерживать единообразие работы со списком. Если найден слишком
длинный блок, пользователю возвращается его "хвост"; благодаря этому в заголовке 
исходного блока остается исправить только размер. Во всех случаях указатель, 
возвращаемый пользователю, указывает на свободное пространство в блоке, которое начинается
через один блок после заголовка.
Функция morecore запрашивает и получает память от операционной системы. 
Детали реализации такого запроса меняются от системы к системе. Запрос памяти у 
системы — это сравнительно трудоемкая операция, и ее не стоит выполнять при каждом 
вызове malloc. Вот почему функция morecore запрашивает сразу как минимум NALLOC
блоков; полученный большой блок потом будет "нарезаться" по мере необходимости.
После установки поля размера morecore добавляет полученную память в общий фонд,
вызывая функцию free.
Системный вызов Unix под названием sbrk(n) возвращает указатель на
п дополнительных байт памяти. Эта функция возвращает -1, если места в памяти 
недостаточно, хотя возвращать NULL в этом случае было бы удачнее. Число -1 следует 
привести к типу char *, чтобы можно было сравнивать его с возвращаемым значением.
Приведение типов делает функцию сравнительно устойчивой к различиям представлений
указателей в разных системах. Правда, здесь сделано предположение о том, что 
указатели на различные блоки, возвращаемые из sbrk, можно сравнивать и получать при этом
правильные ответы. Стандарт этого не гарантирует, поскольку разрешает сравнивать
указатели только в пределах массива. Поэтому данная версия та 11 ос переносима 
только между системами, в которых сравнение произвольных указателей имеет смысл и 
реализовано корректно.
И последней в нашем наборе функций идет free. Она перебирает список свободных
блоков, начиная с freep, в поисках места для вставки освобождаемого блока. Такое 
место может найтись либо между двумя блоками, либо на одном из концов списка. В 
любом случае, если освобождаемый блок примыкает вплотную к одному из соседей, 
соседние блоки объединяются в один. Единственное, о чем следует тщательно 
позаботиться,— это о том, чтобы указатели указывали на правильные места и были заданы
правильные размеры.
Хотя распределение памяти — по самой своей сути всегда системно-зависимая 
операция, приведенный код иллюстрирует, как эту зависимость можно сделать управляемой
и локализовать в очень малой части программы. Выравнивание регулируется с помощью
typedef и объединений (при условии, что sbrk возвращает правильный указатель).
Приведение типов, применяемое к указателям, сделано явным и даже приспособлено к
неудачному системному интерфейсу. Хотя подробности реализации приведенных 
функций относятся к распределению памяти, общий подход можно применять и к решению
других проблем.
